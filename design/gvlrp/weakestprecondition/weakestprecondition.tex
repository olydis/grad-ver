\section{Weakest Predonditions}

\subsection{Concrete Weakest Liberal Precondition (WLP) Rules}

\begin{spacing}{1.5} \begin{align*} \begin{mathleftalign}
\WLP : \ \tsc{Statement} \times \tsc{FrmSatFormula} \rightarrow \tsc{FrmSatFormula} \\
\WLP(s, \phi) := \
\text{match} \ s \ \text{with} \\
\begin{mathmatchwith}
  %
  \code{skip} &\mapsto&
    \phi
  \\
  s_1 \code{;} \ s_2 &\mapsto&
    \WLP(s_1, \ \WLP(s_2, \phi))
  \\
  T \ x &\mapsto&
    \tsf{assert} \ \text{$x$ does not appear in $\phi$}; \
    \phi
  \\
  x \ \code{:=} \ e &\mapsto&
    \footprint{e} \ \land \
    [ e / x ] \phi
  \\
  x \ \code{:=} \ \code{new} \ C &\mapsto&
    [ \new(C) / x ] \phi
  \\
  x.f \ \code{:=} \ y &\mapsto&
    \footprint{x.f} \ \land \
    [ y / x.f ] \phi
  \\
  % method call
  y \ \code{:=} \ z.m_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    z \ \code{!=} \ \code{null} \ \land \\ &&
    [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \ \ast \\ &&
    \tsf{handleMethodCall}(z.m_C(\vec{e}), \phi)
  \\
  \code{if} \ (e) \ \{ s_\text{the} \} \ \code{else} \ \{ s_\text{els} \} &\mapsto&
    \footprint{e} \ \land \\ &&
    \code{if} \ (e) \
    \code{then} \ \WLP(s_\text{the}, \phi) \
    \code{else} \ \WLP(s_\text{els}, \phi)
  \\
  \code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \} &\mapsto&
    \footprint{e} \ \land \\ &&
      \code{if} \ (e) \
      \code{then} \ \WLP(s_\text{bod}, \phi_\text{inv}) \
      \code{else} \ \code{true} \ \ast \\ &&
    \tsf{handleWhileLoop}(e, \phi_\text{inv})
  \\
  \code{assert} \ \phi_\text{ass} &\mapsto&
    \footprint{\phi_\text{ass}} \ \land \
    \phi_\text{ass} \ \land \
    \phi
  \\
  \code{hold} \ \phi_\text{hol} \ \{ s_\text{bod} \} &\mapsto&
    \text{(unimplemented)} % UNIMPL
  \\
  \code{release} \ \phi_\text{rel} &\mapsto&
    \text{(unimplemented)} % UNIMPL
  \\
  \code{unfold} \ \alpha_C(\vec{e}) &\mapsto&
    \footprint{\alpha_C(\vec{e})}_\text{unf} \ \land \\ &&
    [ \body(\alpha_C(\vec{e})) / \alpha_C(\vec{e}), \
      \phi\p / \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p ]
    \phi
  \\
  \code{fold} \ \alpha_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    [ \alpha_C(\vec{e}) / \body(\alpha_C(\vec{e})) ] \phi
  %
  \end{mathmatchwith}
\end{mathleftalign} \end{align*} \end{spacing}

\noindent
Since \tsf{WLP} takes a framed, satisfiable formula and yields a framed, satisfiable formula, there is an implicit check that asserts these properties before and after \tsf{WLP} is computed. Note that the substitutions in the above rules do not substitute instances that appear inside of accesses (i.e. of the form $\cacc(e.f)$) or meta-predicates such as $\tainted$, etc.

Additionally, note the following syntax rules:
\begin{itemize}
  \item
  The OCaml-inspired syntax of the form $a; s$ for side-effects in evaluation is defined as ``execute side-effect $a$, then evaluate as $s$.''

  \item
  The meta-function $\tsf{assert} \ \cdot$ is executed imperitively, raising an error if the argument is false.
\end{itemize}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Assumed and Tainted Logic}

\tit{Assumed logic} concerns assumed formulas that do not result direcly from statically verifying the visible code.
\tit{Tainted logic} concerns how references (variables and field references) may have their referenced values changed by sources external to the visible code. These logics are handled in the following cases:
\begin{itemize}
  \item
  Method calls --- The specification of a called method is visible, but the body is not visible due to the (intended) modular structure of verification. So, the validity of the called method's implementation is assumed. Additionally, a method call taints references that it requires access to.

  \item
  While loops --- the actual execution of a while loop's body is statically invisible since the number of times the while loop's body will exectute is not statically calculated. So, references that are set inside the while loop's body are tainted.
\end{itemize}
Define a \tit{reference}, $r$, to be an instance of $x$ (a variable), $e.f$ or $\alpha_C(\vec{e})$.
Then \tit{access to a reference} is defined as follows:
\begin{align*} \begin{mathleftalign}
  \tsf{access}(r) :=
    \begin{cases}
      \code{false}      & \text{if} \ r = x \\
      \code{acc}(e.f)   & \text{if} \ r = e.f \\
      \alpha_C(\vec{e}) & \text{if} \ r = \alpha_C(\vec{e})
    \end{cases}
\end{mathleftalign} \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Handling Method Calls}

The \tsf{handleMethodCall} helper function,
for a given method call $z.m_C(\vec{e})$ and post-condition $\phi$,
does the following:
\begin{itemize}
  \item assert that permissions in $\footprint{\phi}$ and granted by $\pre(z.m_C(\vec{e}))$ are also granted by $\post(z.m_C(\vec{e}))$
  \item assume taint-substituted $\pre(z.m_C(\vec{e}))$
  \item return taint-substituted $\phi$
\end{itemize}
The following definition reflects the above descriptions, in order:
\begin{align*} \begin{mathleftalign}
\tsf{handleMethodCall}(z.m_C(\vec{e}), \phi) := \\ \hspace{2em}
  \tsf{assert} \ \tsf{granted}(\post(z.m_C(\vec{e}))), \
    \forall \pi :
      \footprint{\phi}, \
      \tsf{granted}(\pre(z.m_C(\vec{e}))) \implies \pi;
  \\ \hspace{2em}
  \tsf{assume} \
    [ \tainted_{\tsf{uid}(z.m_C(\vec{e}))}(r) / r : r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) ] \pre(z.m_C(\vec{e}));
  \\ \hspace{2em}
  [ \tainted_{\tsf{uid}(z.m_C(\vec{e}))}(r) / r : r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) ] \phi
\end{mathleftalign} \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Handling While Loops}

The $\tsf{handleWhileLoop}$ helper function,
for a given while loop with condition $e$, invariant $\phi_\text{inv}$, and post-condition $\phi$,
does the following:
\begin{itemize}
  \item taints all references that are set in the while loop's body
  \item assume taint-substututed $\phi_\text{inv}$
  \item return taint-substituted $\phi$
\end{itemize}
The following definition reflects the above descriptions, in order:
\begin{align*} \begin{mathleftalign}
\tsf{handleWhileLoop}(z.m_C(\vec{e}), s_\text{bod}, \phi) := \\ \hspace{2em}
  \tsf{assume} \
    [ \tainted_{\tsf{uid}(\tsf{while}(e, \phi_\text{inv}))}(r) / r : r \ \tsf{isTaintedBy} \ s_\text{bod} ]
    \phi_\text{inv}; \\ \hspace{2em}
  [ \tainted_{\tsf{uid}(\tsf{while}(e, \phi_\text{inv}))}(r) / r : r \ \tsf{isTaintedBy} \ s_\text{bod} ] \phi
\end{mathleftalign} \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Assumptions}

The \tit{assumed} formula, local to the encompassing highest-level $\WLP(s, \phi)$ calculation, represents the truths that are assumed via references external to the direct implications of $s$. For example, the post-condition of a method call appearing in $s$ may yield truths that are accepted as assumptions due to the modular structure of verification --- the method call is assumed to be verified seperately (modularly).

These truths must be kept separate from $\phi_\WLP := \WLP(s, \phi)$ because they do not need to be implied by the pre-condition concerning $\phi_\WLP$.
The $\tsf{assume}(\phi)$ function is how these truths are accumulated during the \WLP\ computation.
%
\begin{align*} \begin{mathleftalign}
\tsf{assume} \ \phi := \
  \text{set the \tit{assumed} formula, $\phi_\text{ass}$, to $\phi \land \phi_\text{ass}$}
\end{mathleftalign} \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Taints}

The \tainted\ meta-predicate indicates that the wrapped reference has been \tit{tainted} by a source identified by the given unique identifier.
A \tit{tainted} reference is one that relies on the values of parts of the heap that may have been changed externally.
For example, if a method call requires access to $x.f$, then $x.f$ is tainted because the method call could have changed the value of $x.f$.

\tit{Tainted} references can only be asserted in some specific ways.
For example, the previously mentioned method call could ensure that $x.f = v$, where $v$ is some value, and this would yield the \tit{assumption} that $\tainted_{\tsf{uid}(z.m_C(\vec{e}))}(x.f) = v$. The following rules define the \tsf{isTaintedBy}\ relation between references (left) and statements (right).
\begin{align*} \begin{mathdefinition}
  r \ \tsf{isTaintedBy} \ r := e && \\
  r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) &\iff& \footprint{\pre(z.m_C(\vec{e}))} \implies \tsf{access}(r) \\
  r \ \tsf{isTaintedBy} \ s_1 \code{;} s_2 &\iff& r \ \tsf{isTaintedBy} \ s_1 \ \lor \ r \ \tsf{isTaintedBy} \ s_2
\end{mathdefinition} \end{align*}
%
\noindent
The $\tsf{uid}(\cdot)$ function generates a unique identifier for the given instance. This is needed because instances that contain the same arguments but appear in different parts of a program (where heap state may be different) must be treated as unique. The following function gathers all the references tainted via the arguments:

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Utility Functions}

\noindent
The implementations of the functions in this section can be made much more efficient than the naive definition here in mathematical notation. For example, calculating the footprint of expressions and formulas can avoid redundancy by not generating permission-subformulas that are already satisfied. This can be implemented as implicit in $\land$ by a wrapper $\land_\text{wrap}$ operation in some way similar to this:
\begin{align*}
  \phi \ \land_\text{wrap} \ \phi\p := \begin{cases}
    \phi & \text{if} \ \phi \implies \phi\p \\
    \phi \land \phi\p & \text{otherwise}
  \end{cases}
\end{align*}

%
% abbreviations
%
\noindent
The following functions are useful abbreviations for common constructs.
\begin{align*} \begin{mathdefinition}
\new(C) & :=
  & \ \text{an object that is a new instance of class $C$,} \\ &
  & \ \text{where all fields are assigned to their default values}
\\
\pre(z.m_C(\vec{e})) & := & [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \\
\pre(m_C) & := & \ \text{the static-contract pre-condition of} \ m_C \\
\post(z.m_C(\vec{e})) & := &  [ z/\code{this}, \ \vec{e/\code{old}(x)} ] \post(m_C) \\
\post(m_C) & := & \ \text{the static-contract post-condition of} \ m_C \\
\body(\alpha_C) & := & \ \text{the body formula of} \ \alpha_C \\
\body(\alpha_C(\vec{e})) & := & \ [ \vec{e/x} ] \body(\alpha_C)
%
\end{mathdefinition} \end{align*}
%
% footprint
%
\noindent
The footprint function, $\footprint{\cdot}$, generates a formula containing all the permissions necessary to frame its argument. With efficient implementations of a wrapped $\land$, this can result in the smallest such formula.
\begin{align*} \begin{mathdefinition}
\footprint{e} & :=
  & \ \text{match} \ e \ \text{with} \\ &
  & \ \begin{mathmatchwith}
        e.f &\mt&
          \footprint{e\p} \ \land \
          e\p \ \code{!=} \ \code{null} \ \land \
          \cacc(e\p.f) \\
        e_1 \oplus e_2 &\mt&
          \footprint{e_1} \ \land \ \footprint{e_2} \\
        e_1 \odot e_2 &\mt&
          \footprint{e_1} \ \land \ \footprint{e_2} \\
        e &\mt&
          \code{true}
    \end{mathmatchwith}
\\
\footprint{\vec{e}} & :=
  & \ \bigwedge \footprint{e}
\\
\footprint{\alpha_C(\vec{e})}_\text{unf} & :=
  & \ \footprint{\vec{e}} \ \land
    \ \footprint{\body(\alpha_C(\vec{e}))}_\text{nunf}
\\
\footprint{\alpha_C(\vec{e})}_\text{nunf} & :=
  & \ \footprint{\vec{e}}
\\
\footprint{\phi} & :=
  & \ \bigwedge\set{ \footprint{e} :
                     e \ \text{appears in} \ \phi }
  \ \land \\ &
  & \ \bigwedge\set{ \footprint{\alpha_C(\vec{e})}_\text{unf} :
                     \alpha_C(\vec{e}) \ \text{appears in} \ \phi }
  \ \land \\ &
  & \ \bigwedge\set{ \alpha_C(\vec{e}) :
                     \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p \ \text{appears in} \ \phi }
\\
\footprint{\phi}_\text{nunf} & :=
& \ \bigwedge\set{ \footprint{e} :
                   e \ \text{appears in} \ \phi }
\ \land \\ &
& \ \bigwedge\set{ \footprint{\alpha_C(\vec{e})}_\text{nunf} :
                   \alpha_C(\vec{e}) \ \text{appears in} \ \phi }
\ \land \\ &
& \ \bigwedge\set{ \alpha_C(\vec{e}) :
                   \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p \ \text{appears in} \ \phi }
\end{mathdefinition} \end{align*}
