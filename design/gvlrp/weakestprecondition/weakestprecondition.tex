\section{Weakest Predonditions}

\subsection{Concrete Weakest Liberal Precondition (WLP) Rules}


\begin{spacing}{1.5} \begin{align*} \begin{mathleftalign}
\WLP : \ \tsc{Statement} \times \tsc{FrmSatFormula} \rightarrow \tsc{FrmSatFormula} \\
\WLP(s, \phi) := \
\text{match} \ s \ \text{with} \\
\begin{mathmatchwith}
  %
  \code{skip} &\mapsto&
    \phi
  \\
  s_1 \code{;} \ s_2 &\mapsto&
    \WLP(s_1, \ \WLP(s_2, \phi))
  \\
  T \ x &\mapsto&
    % TODO: implicit check that x is not in the freeVariables of \phi
    \phi \
    \textit{(assert that $x$ does not appear in $\phi$)}
  \\
  x \ \code{:=} \ e &\mapsto&
    \footprint{e} \ \land \
    [ e / x ] \phi
  \\
  x \ \code{:=} \ \code{new} \ C &\mapsto&
    [ \new(C) / x ] \phi
  \\
  x.f \ \code{:=} \ y &\mapsto&
    \footprint{x.f} \ \land \
    [ y / x.f ] \phi
  \\
  % method call
  y \ \code{:=} \ z.m_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    z \ \code{!=} \ \code{null} \ \land \\ &&
    [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \ \ast \\ &&
    \tsf{handleMethodPermissions}(z.m_C(\vec{e}), \phi)
  \\
  \code{if} \ (e) \ \{ s_\text{the} \} \ \code{else} \ \{ s_\text{els} \} &\mapsto&
    \footprint{e} \ \land \\ &&
    \code{if} \ (e) \
    \code{then} \ \WLP(s_\text{the}, \phi) \
    \code{else} \ \WLP(s_\text{els}, \phi)
  \\
  % TODO
  % problem is that some post-conditions of phi need to be transmitted up, not conditionally on e,
  % but also phi may contain ~e which would contradict the conditional
  % \code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \} &\mapsto&
  %   \footprint{e} \ \land \
  %   \phi_\text{inv} \ \land \\ &&
  %   \code{if} \ (e) \
  %     \code{then} \ \WLP(s_\text{bod}, \phi_\text{inv}) \
  %     \code{else} \ \phi
  %
  \code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \} &\mapsto&
    \footprint{e} \ \land \
    (\phi \ \setminus \pnot e) \ \land \\ &&
    \code{if} \ (e) \
      \code{then} \ \WLP(s_\text{bod}, \phi_\text{inv}) \
      \code{else} \ \code{true}
  \\
  \code{assert} \ \phi_\text{ass} &\mapsto&
    \footprint{\phi_\text{ass}} \ \land \
    \phi_\text{ass} \ \land \
    \phi
  \\
  \code{hold} \ \phi_\text{hol} \ \{ s_\text{bod} \} &\mapsto&
    \text{(unimplemented)} % UNIMPL
  \\
  \code{release} \ \phi_\text{rel} &\mapsto&
    \text{(unimplemented)} % UNIMPL
  \\
  \code{unfold} \ \alpha_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    [ \unfolded(\alpha_C(\vec{e})) / \alpha_C(\vec{e}), \\ && \
      \phi\p / \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p ]
    \phi
  \\
  \code{fold} \ \alpha_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    [ \alpha_C(\vec{e}) / \unfolded(\alpha_C(\vec{e})) ] \phi
  %
  \end{mathmatchwith}
\end{mathleftalign} \end{align*} \end{spacing}

\noindent
Since \tsf{WLP} takes a framed, satisfiable formula and yields a framed, satisfiable formula, there is an implicit check that asserts these properties before and after \tsf{WLP} is computed.

%
%

\newpage
\subsubsection{Utility Functions}

\noindent
The implementations of the functions in this section can be made much more efficient than the naive definition here in mathematical notation. For example, calculating the footprint of expressions and formulas can avoid redundancy by not generating permission-subformulas that are already satisfied. This can be implemented as implicit in $\land$ by a wrapper $\land_\text{wrap}$ operation in some way similar to this:
\begin{align*}
  \phi \ \land_\text{wrap} \ \phi\p := \begin{cases}
    \phi & \text{if} \ \phi \implies \phi\p \\
    \phi \land \phi\p & \text{otherwise}
  \end{cases}
\end{align*}

%
% abbreviations
%
\noindent
The following functions are useful abbreviations for common constructs.
\begin{align*} \begin{mathdefinition}
\new(C) & :=
  & \ \text{an object that is a new instance of class $C$,} \\ &
  & \ \text{where all fields are assigned to their default values}
\\
\unfolded(\alpha_C(\vec{e})) & :=
  & \ [ \vec{e/x} ] \tsf{body}(\alpha_C)
\\
\pre(z.m_C(\vec{e})) & := & [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \\
\pre(m_C) & := & \ \text{the static-contract pre-condition of} \ m_C \\
\post(z.m_C(\vec{e})) & := &  [ z/\code{this}, \ \vec{e/\code{old}(x)} ] \post(m_C) \\
\post(m_C) & := & \ \text{the static-contract post-condition of} \ m_C \\
\tsf{body}(\alpha_C) & := & \ \text{the body formula of} \ \alpha_C \\
%
\end{mathdefinition} \end{align*}
%
% footprint
%
\noindent
The footprint function, $\footprint{\cdot}$, generates a formula containing all the permissions necessary to frame its argument. With efficient implementations of a wrapped $\land$, this can result in the smallest such formula.
\begin{align*} \begin{mathdefinition}
\footprint{e} & :=
  & \ \text{match} \ e \ \text{with} \\ &
  & \ \begin{mathmatchwith}
        e.f &\mt&
          \footprint{e\p} \ \land \
          e\p \ \code{!=} \ \code{null} \ \land \
          \cacc(e\p.f) \\
        e_1 \oplus e_2 &\mt&
          \footprint{e_1} \ \land \ \footprint{e_2} \\
        e_1 \odot e_2 &\mt&
          \footprint{e_1} \ \land \ \footprint{e_2} \\
        e &\mt&
          \code{true}
    \end{mathmatchwith}
\\
\footprint{\vec{e}} & :=
  & \ \bigwedge \footprint{e}
\\
\footprint{\phi} & :=
  & \ \bigwedge\set{ \footprint{e} : e \ \text{appears in} \ \phi } \ \land \\ &
  & \ \bigwedge\set{ \alpha_C(\vec{e}) : \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p \
                                              \text{appears in} \ \phi }
\end{mathdefinition} \end{align*}
%
% handleMethodPermissions
%
\noindent
The \tsf{handleMethodPermissions} helper function assists in generating the \WLP\ for a method call.
It yields a formula that asserts the following:
\begin{itemize}
  \item[(a)]
  For all $\cacc(e.f)$ or $\alpha_C(\vec{e})$ that appear in $\footprint{\phi}$, $\cacc(e.f)$ or $\alpha_C(\vec{e})$ does not appear in $\pre(z.m_C(\vec{e})) \setminus \post(z.m_C(\vec{e}))$. This asserts that $\phi$ does not use access to a part of the heap whose access was required to call $z.m_C(\vec{e})$ and then not ensured after the call. Predicates are checked because they can possibly contain accesses.

  % TODO: problem is that the post-condition could give information about the value of [e.f], e.g [e.f = 1], which then would be allowed to be used in phi
  \item[(b)]
  For all $e.f$ that appear in $\phi$ (not including than those appearing in $\cacc(e.f)$), $\cacc(e.f)$ does not appear in $\footprint{\pre(z.m_C(\vec{e}))}$. This asserts that $\phi$ does not rely on the value of a part of the heap that was accessed by $z.m_C(\vec{e})$ and then not implied by $\post(z.m_C(\vec{e}))$.
\end{itemize}

\begin{align*} \begin{mathleftalign}
\tsf{handleMethodPermissions}(z.m_C(\vec{e}), \phi) := \\ \hspace{6em}
% (a)
\bigwedge\set{  (\pre(z.m_C(\vec{e})) \setminus \post(z.m_C(\vec{e}))) \ast \cacc(e.f) :
                \footprint{\phi} \implies \cacc(e.f) } \ \land \\ \hspace{6em}
\bigwedge\set{  (\pre(z.m_C(\vec{e})) \setminus \post(z.m_C(\vec{e}))) \ast \alpha_C(\vec{e}) :
                \footprint{\phi} \implies \alpha_C(\vec{e}) } \ \land \\ \hspace{6em}
% (b)
\bigwedge\set{  (\pre(z.m_C(\vec{e}))) \ast \cacc(e.f) :
                e.f \ \text{appears in} \ \phi } \ \land \\ \hspace{6em}
\end{mathleftalign} \end{align*}

\noindent
% TODO: can mostly deal with permissions
TODO: define \tit{without} function, $\phi \setminus e$.

%
% \pnot e :=
%   & \ e \ \code{=} \ \code{false}
% \\
% \phi \setminus e :=
%   & \ \text{match} \ \phi \ \text{with} \\
%   & \ \begin{mathmatchwith}
%         e\p &\mt&
%           \text{match} \ e\p \ \text{with} \\ &&
%           \begin{mathmatchwith}
%             e_1 \oplus e_2 &\mt& TODO \\
%             e_1 \odot  e_2 &\mt& TODO \\
%             e\p &\mt& e\p
%           \end{array}
%         \\
%         A &\mt&
%           TODO
%         \\
%         \cacc(e_\text{ba}.f) &\mt&
%           TODO
%         \\
%         \phi_1 \circast \phi_2 &\mt&
%           TODO
%         \\
%         \code{if} \ e\p \ \code{then} \ \phi_\text{the} \ \code{else} \ \phi_\text{els} &\mt&
%           TODO
%         \\
%         \cunfolding \ A \ \cin \ \phi_\text{un} &\mt&
%           TODO
%         %
%       \end{array}
% \end{align*}
