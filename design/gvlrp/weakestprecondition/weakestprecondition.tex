\section{Weakest Predonditions}

\subsection{Concrete Weakest Liberal Precondition Rules}

\newcommand{\WLP}{\tsf{WLP}}
\newcommand{\weakest}{\max\limits_{\implies}}

\begin{spacing}{1.5}
\begin{align*}
\begin{array}{l}
\WLP : \ \tsc{Statement} \times \tsc{SatFormula} \rightarrow \tsc{SatFormula} \\
\WLP(s, \phi) := \ \tsf{match} \ s \ \tsf{with} \\
\begin{array}{|lcl}
%
\code{skip} &\mapsto&
  \phi
\\
s_1 \code{;} \ s_3 &\mapsto&
  \WLP(s_1, \ \WLP(s_2, \phi))
\\
T \ x &\mapsto&
  \phi
\\
x \ \code{:=} \ e &\mapsto&
  % \weakest\set{ \phi\p : \phi\p \implies [e/x] \phi } \land \tsf{accessTo}(e)
  \tsf{accessTo}(e) \ \land \  [e/x] \phi
\\
x \ \code{:=} \ \code{new} \ C &\mapsto&
  % \weakest\set{ \phi\p : \phi\p \land (x = \tsf{newInstance}(C)) \implies \phi }
  x = \tsf{newInstance}(C) \ \land \  \phi
\\
x.f \ \code{:=} \ y &\mapsto&
  % \weakest\set{ \phi\p : \phi\p \land (x.f = y) \implies \phi }
  x.f = y \ \land \  \phi
\\
y \ \code{:=} \ z.m_C(\overline{e}) &\mapsto&
  \WLP(
    \code{assert} \ [ z/\code{this}, \overline{e/x} ] \tsf{pre}(z.m_C) \code{;} \\ && \hspace{2.5em}
    \text{[} z/\code{this}, \overline{e/x} \text{]} \tsf{body}(z.m_C) \\ && \hspace{2.5em}
    \code{assert} \ [ z/\code{this}, y/\code{result}, \overline{e/\code{old}(x)} ] \tsf{post}(z.m_C) \code{;}, \\ && \hspace{1em}
  \tsf{accessTo}(\overline{e}) \ \land \ \phi)
\\
\code{if} \ (e) \ \{ s_\text{th} \} \ \code{else} \ \{ s_\text{el} \} &\mapsto&
  % \weakest\set{ \phi\p : \phi\p \implies \tsf{if} \ e \ \tsf{then} \ \WLP(s_\text{th}, \phi) \ \tsf{else} \ \WLP(s_\text{el}, \phi) }
  % \weakest\set{ \phi\p :
  %   (\phi\p \land e \implies \WLP(s_\text{th}, \phi)) \ \land \
  %   (\phi\p \land \pnot e \implies \WLP(s_\text{el}, \phi))
  % }
  \tsf{accessTo}(e) \ \land \
  ((e \land \WLP(s_\text{th}, \phi)) \ \lor \
  (\pnot e \land \WLP(s_\text{el}, \phi)))
\\
\code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \} &\mapsto&
  % \weakest\set{ \phi\p :
  %   (\phi\p \implies \phi_\text{inv}) \ \land \
  %   (\phi\p \land (e = \code{false}) \implies \phi)
  % }
  \tsf{accessTo}(e) \ \land \
  \phi_\text{inv} \ \land \\ &&
  \WLP(s_\text{bod}, \
    (\pnot e \ \land \ \phi) \ \lor \ \\ && \hspace{5.3em}
    \WLP(\code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \}, \ \phi)
  )
\\
\code{assert} \ \phi_\text{ass} &\mapsto&
  % \weakest\set{ \phi\p : \phi\p \implies \phi \land \phi_\text{ass} }
  \phi_\text{ass} \ \land \ \phi
\\
\code{hold} \ \phi_\text{hol} &\mapsto&
  TODO
\\
\code{release} \ \phi_\text{rel} &\mapsto&
  TODO
\\
\code{unfold} \ \alpha_C(\overline{e}) &\mapsto&
  \tsf{accessTo}(\overline{e}) \ \land \
  \alpha_C(\overline{e}) \ \land \
  (\phi - [ \overline{e/x} ] \tsf{body}(\alpha_C))
\\
\code{fold} \ \alpha_C(\overline{e}) &\mapsto&
  \tsf{accessTo}(\overline{e}) \ \land \
  [ \overline{e/x} ] \tsf{body}(\alpha_C) \ \land \
  \phi
%
\end{array}
\end{array}
\end{align*}
\end{spacing}

\newpage
\noindent
Some utility functions are defined as follows:

\begin{spacing}{1.5}
\begin{align*}
\tsf{accessTo}(e) := & \begin{cases}
  % TODO: should the \land in the expression below in
  % stead be a \sep?
  \tsf{accessTo}(e\p) \land \code{acc}(e\p.f) & \text{if} \ e = e\p.f \\
  \code{true} & \text{otherwise}
\end{cases}
\\
\tsf{accessTo}(e_1, \dots, e_n) :=
  & \ \tsf{accessTo}(e_1) \land \cdots \land \tsf{accessTo}(e_n)
\\
\\
\tsf{newInstance}(C) :=
  & \ \text{an object that is a new instance of class $C$} \\
  & \ \text{where all fields are assigned to their default values}
\\
\\
\phi - \alpha_C(\overline{e}) :=
  & \ \phi \ \text{without a single $\land$-clause of the form} \ \alpha_C(\overline{e})
\end{align*}
\end{spacing}
