\section{Weakest Liberal Predonditions}



% TODO: make main subsection for describing syntactical conventions

\newcommand{\imprecise}{\ast \ ?}

\newcommand{\req}[1]{\tsf{required}\left(#1\right)}
\newcommand{\impr}[1]{\tsf{imprecision}(#1)}
\newcommand{\conc}[1]{\tsf{concrete}(#1)}

\newcommand{\GhandleWhileLoop}{\tsf{handle}\widetilde{\tsf{Whi}}\tsf{leLoop}}
\newcommand{\GhandleMethodCall}{\tsf{handle}\widetilde{\tsf{Met}}\tsf{hodCall}}

\subsection{Concrete Weakest Liberal Precondition (WLP) Rules}

\input{weakestprecondition/wlp-rules-concrete}

\noindent
Since \tsf{WLP} takes a framed, satisfiable formula and yields a framed, satisfiable formula, there is an implicit check that asserts these properties before and after \tsf{WLP} is computed. Note that the substitutions in the above rules do not substitute instances that appear inside of accesses (i.e. of the form $\cacc(e.f)$) or meta-predicates such as $\tainted$, etc.

Note the following syntax rules:
\begin{itemize}
  \item
  The OCaml-inspired syntax of the form $a; s$ for side-effects in evaluation is defined as ``execute side-effect $a$, then evaluate as $s$.''

  \item
  The meta-function $\tsf{assert} \ \cdot$ is executed imperitively, raising an error if the argument is false.
\end{itemize}

Finally, the idiom ``$a$ appears in $b$'' is defined as follows:
\begin{spacing}{1.5}
\begin{align*} \begin{mathdefinition}
  \text{$e$ appears in $e\p$} &\iff& \text{$\exists e\p_\text{sub}$ a sub-expression of $e\p : e = e\p_\text{sub}$} \\
  \text{$e$ appears in $\cacc(e\p)$} &\iff& \tsf{false} \\
  \text{$e$ appears in $\code{if} \ e\p \ \code{then} \ \phi_\text{the} \ \code{else} \ \phi_\text{els}$} &\iff& \text{$e$ appears in at least one of $e\p, \phi_\text{the}, \phi_\text{els}$} \\
  \text{$e$ appears in $\alpha_C(\vec{e})$} &\iff& \text{$e$ appears in at least one of $\vec{e}$} \\
  % TODO: rest of definitions
\end{mathdefinition}
\end{align*} \end{spacing}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Handling Method Calls}
\label{sec:handling method calls}

The \tsf{handleMethodCall} helper function,
for a given method call $z.m_C(\vec{e})$ and post-condition $\phi$,
does the following:
\begin{itemize}
  \item assert that permissions in $\required(\phi)$ and granted by $\pre(z.m_C(\vec{e}))$ are also granted by $\post(z.m_C(\vec{e}))$
  \item assume taint-substituted $\pre(z.m_C(\vec{e}))$
  \item return taint-substituted $\phi$
\end{itemize}
The following definition reflects the above descriptions, in order:
\begin{spacing}{1.5}
\begin{align*} \begin{mathleftalign}
\tsf{handleMethodCall}(z.m_C(\vec{e}), \phi) := \\ \hspace{2em}
  \tsf{assert} \ \granted(\post(z.m_C(\vec{e}))) \implies \pi, \\ \hspace{4em}
    \forall \pi :
      \required(\phi), \
      \granted(\pre(z.m_C(\vec{e}))) \implies \pi;
  \\ \hspace{2em}
  \tsf{assume} \
    [ \tainted_{\tsf{uid}(z.m_C(\vec{e}))}(r) / r : r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) ] \pre(z.m_C(\vec{e}));
  \\ \hspace{2em}
  [ \tainted_{\tsf{uid}(z.m_C(\vec{e}))}(r) / r : r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) ] \phi
\end{mathleftalign} \end{align*}
\end{spacing}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Handling While Loops}
\label{sec:handling while loops}

The $\tsf{handleWhileLoop}$ helper function,
for a given while loop with condition $e$, invariant $\phi_\text{inv}$, and post-condition $\phi$,
does the following:
\begin{itemize}
  \item assume taint-substututed $\phi_\text{inv}$
  \item return taint-substituted $\phi$
\end{itemize}
The following definition reflects the above descriptions, in order:
\begin{spacing}{1.5}
\begin{align*} \begin{mathleftalign}
\tsf{handleWhileLoop}(\phi_\text{inv}, s_\text{bod}, \phi) := \\ \hspace{2em}
  \tsf{assume} \
    [ \tainted_{\tsf{uid}(\tsf{while}(e, \phi_\text{inv}))}(r) / r : r \ \tsf{isTaintedBy} \ s_\text{bod} ]
    \phi_\text{inv}; \\ \hspace{2em}
  [ \tainted_{\tsf{uid}(\tsf{while}(e, \phi_\text{inv}))}(r) / r : r \ \tsf{isTaintedBy} \ s_\text{bod} ] \phi
\end{mathleftalign} \end{align*}
\end{spacing}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Assumed and Tainted Logic}

\tit{Assumed logic} concerns assumed formulas that do not result direcly from statically verifying the visible code.
\tit{Tainted logic} concerns how references (variables and field references) may have their referenced values changed by sources external to the visible code. These logics are handled in the following cases:
\begin{itemize}
  \item
  Method calls --- The specification of a called method is visible, but the body is not visible due to the (intended) modular structure of verification. So, the validity of the called method's implementation is assumed. Additionally, a method call taints references that it requires access to.

  \item
  While loops --- the actual execution of a while loop's body is statically invisible since the number of times the while loop's body will exectute is not statically calculated. So, references that are set inside the while loop's body are tainted.
\end{itemize}
Define a \tit{reference}, $r$, to be an instance of $x$ (a variable), $e.f$ or $\alpha_C(\vec{e})$.
Then \tit{access to a reference} is defined as follows:
\begin{align*} \begin{mathleftalign}
  \tsf{access}(r) :=
    \begin{cases}
      \code{false}      & \text{if} \ r = x \\
      \code{acc}(e.f)   & \text{if} \ r = e.f \\
      \alpha_C(\vec{e}) & \text{if} \ r = \alpha_C(\vec{e})
    \end{cases}
\end{mathleftalign} \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Assumptions}

The \tit{assumed} formula, local to the encompassing highest-level $\WLP(s, \phi)$ calculation, represents the truths that are assumed via references external to the direct implications of $s$. For example, the post-condition of a method call appearing in $s$ may yield truths that are accepted as assumptions due to the modular structure of verification --- the method call is assumed to be verified seperately (modularly).

These truths must be kept separate from $\phi_\WLP := \WLP(s, \phi)$ because they do not need to be implied by the pre-condition concerning $\phi_\WLP$.
The $\tsf{assume}(\phi)$ function is how these truths are accumulated during the \WLP\ computation.
%
\begin{align*} \begin{mathleftalign}
\tsf{assume} \ \phi := \
  \text{set the \tit{assumed} formula, $\phi_\text{ass}$, to $\phi \land \phi_\text{ass}$}
\end{mathleftalign} \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Taints}

The \tainted\ meta-predicate indicates that the wrapped reference has been \tit{tainted} by a source identified by the given unique identifier.
A \tit{tainted} reference is one that relies on the values of parts of the heap that may have been changed externally.
For example, if a method call requires access to $x.f$, then $x.f$ is tainted because the method call could have changed the value of $x.f$.

\tit{Tainted} references can only be asserted in some specific ways.
For example, the previously mentioned method call could ensure that $x.f = v$, where $v$ is some value, and this would yield the \tit{assumption} that $\tainted_{\tsf{uid}(z.m_C(\vec{e}))}(x.f) = v$. The following rules define the \tsf{isTaintedBy}\ relation between references (left) and statements or statement-fragments (right).
\begin{spacing}{1.5}
\begin{align*} \begin{mathdefinition}
  r \ \tsf{isTaintedBy} \ r \ \code{:=} \ e &\impliedby& \tsf{true} \\
  r \ \tsf{isTaintedBy} \ y \ \code{:=} \ z.m_C(\vec{e}) &\iff& r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) \\
  r \ \tsf{isTaintedBy} \ z.m_C(\vec{e}) &\iff& \required(\pre(z.m_C(\vec{e}))) \implies \tsf{access}(r) \\
  r \ \tsf{isTaintedBy} \ s_1 \code{;} s_2 &\iff& r \ \tsf{isTaintedBy} \ s_1 \ \lor \ r \ \tsf{isTaintedBy} \ s_2
\end{mathdefinition} \end{align*}
\end{spacing}
%
\noindent
The $\tsf{uid}(\cdot)$ function generates a unique identifier for the given instance. This is needed because instances that contain the same arguments but appear in different parts of a program (where heap state may be different) must be treated as unique. The following function gathers all the references tainted via the arguments:

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Utility Functions}

\noindent
The implementations of the functions in this section can be made much more efficient than the naive definition here in mathematical notation. For example, calculating the footprint of expressions and formulas can avoid redundancy by not generating permission-subformulas that are already satisfied. This can be implemented as implicit in $\land$ by a wrapper $\land_\text{wrap}$ operation in some way similar to this:
\begin{align*}
  \phi \ \land_\text{wrap} \ \phi\p := \begin{cases}
    \phi & \text{if} \ \phi \implies \phi\p \\
    \phi \land \phi\p & \text{otherwise}
  \end{cases}
\end{align*}

%
% abbreviations
%
\noindent
The following functions are useful abbreviations for common constructs.
\begin{spacing}{1.5}
\begin{align*} \begin{mathdefinition}
\new(C) & :=
  & \ \text{an object that is a new instance of class $C$,} \\ &
  & \ \text{where all fields are assigned to their default values}
\\
\pre(z.m_C(\vec{e})) & := & [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \\
\pre(m_C) & := & \ \text{the static-contract pre-condition of} \ m_C \\
\post(z.m_C(\vec{e})) & := &  [ z/\code{this}, \ \vec{e/\code{old}(x)} ] \post(m_C) \\
\post(m_C) & := & \ \text{the static-contract post-condition of} \ m_C \\
\body(\alpha_C) & := & \ \text{the body formula of} \ \alpha_C \\
\body(\alpha_C(\vec{e})) & := & \ [ \vec{e/x} ] \body(\alpha_C)
%
\end{mathdefinition} \end{align*}
\end{spacing}
%
% footprint
%
\noindent
The footprint function, $\required(\cdot)$, generates a formula containing all the permissions necessary to frame its argument. With efficient implementations of a wrapped $\land$, this can result in the smallest such formula.
\begin{spacing}{1.5}
\begin{align*} \begin{mathdefinition}
\required(e) & :=
  & \ \text{match} \ e \ \text{with} \\ &
  & \ \begin{mathmatchwith}
        e.f &\mt&
          \required(e\p) \ \land \
          % TODO: not sure if this is necessary, since requiring acc(e.f) implies this...
          e\p \ \code{!=} \ \code{null} \ \land \
          \cacc(e\p.f) \\
        e_1 \oplus e_2 &\mt&
          \required(e_1) \ \land \ \required(e_2) \\
        e_1 \odot e_2 &\mt&
          \required(e_1) \ \land \ \required(e_2) \\
        e &\mt&
          \code{true}
    \end{mathmatchwith}
\\
\required(\vec{e}) & :=
  & \ \bigwedge \required(e)
\\
\required(\phi) & :=
  & \ \bigwedge\set{ \required(e) :
                     e \ \text{appears in} \ \phi }
  \ \land \\ &
  & \ \bigwedge\set{ \alpha_C(\vec{e}) :
                     \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p \ \text{appears in} \ \phi }
\end{mathdefinition} \end{align*}
\end{spacing}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------

\newpage
\subsection{Gradual Weakest Liberal Precondition (WLP) Rules}

\input{weakestprecondition/wlp-rules-gradual}

\noindent
Note the following syntactical conventions:
\begin{itemize}
  \item
    $\ast$ binds tighter than $\land$.

  \item
    Since $\imprecise$ is syntactical sugar, $(\phi_1 \ \imprecise) \ \circast \ (\phi_2 \ \imprecise) := \phi_1 \ \circast \ \phi_2 \ \imprecise$, preserving $\imprecise$ at the top level of the formula. This is because $\imprecise$ cannot and should not nest. Due to this, it would make more sense to write $\land \ ?$ actually.

  \item
    The meta-function $\impr{\tphi}$ is defined as follows:
    \begin{align*}
      \phi\p \ \circast \ \impr{\tphi} &:=
        \begin{cases}
          \phi\p \ \circast \ \tphi & \text{if $\tphi$ is imprecise} \\
          \phi\p                    & \text{if $\tphi$ is concrete}
        \end{cases}
    \end{align*}
\end{itemize}


%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsubsection{Handling Gradual Method Calls}

% TODO: how do tainted references interact with imprecision?

This handler builds upon the structure of the handler defined in section~\ref{sec:handling method calls}. However it also handle's certain cases of imprecision specially. Overall, $\GhandleMethodCall(z.m_C(\vec{e}), \tphi)$ satisfies the following, where $\phi_\pre := \pre(z.m_C(\vec{e}))$ and $\phi_\post := \post(z.m_C(\vec{e}))$.
\begin{itemize}

\item
  If each of $\tphi_\pre, \tphi_\post, \tphi$ are concrete, then $\GWLP$ is exactly $\WLP$.

\item
  The imprecision of $\tphi_\pre, \tphi_\post, \tphi$ are propogated through to the result of $\GWLP$. In other words, if at least one of them are imprecise, then the result of $\GWLP$ is imprecise.

\item
  $\tsf{assume} \ \conc{\tphi_\post}$. Only the concrete part is assumed because the imprecise cases are handled by the points below.

\item
  $\required(\tphi_\pre)$ is included in the result of $\GWLP$. Note that, via the definitions in the next section, this only considers the concrete part of $\tphi_\pre$.

\item
  For each permission required by $\tphi$ and granted by $\tphi_\pre$ and required by $\tphi$, the permission must also be granted by $\tphi_\post$. This is the same concept behind $\tsf{assert}$ in concrete \tsf{handleMethodCall}, but its interactions with imprecision are special in the following cases:
  \begin{itemize}
    \item
      If $\tphi_\pre$ is concrete and $\tphi_\post$ is imprecise, then $\required(\tphi) \setminus \granted(\tphi_\pre)$ is included in the result of $\GWLP$. This is because even though $\tphi_\post$ is imprecise, it is impossible for it to grant permissions not granted by $\tphi_\pre$.

    \item
      If $\tphi_\pre$ is imprecise and $\tphi_\post$ is concrete, then $\tsf{assume} \ \tphi_\post$ and nothing from $\tphi$ is propogated to the result of $\GWLP$. This is because the method call ```consumes'' an unknown set of permissions that may not be given back via $\tphi_\post$. This is reflected by the imprecision in the result of $\GWLP$ propogated to it by the imprecision of $\tphi_\pre$.

    \item
      If both of $\tphi_\pre, \tphi_\post$ are imprecise, then nothing from $\tphi$ is propogated to the result of $\GWLP$. This is because the method call could, since it potentially has permission to access anything in its imprecise pre-condition, imply anything ranging from none of $\tphi$ to all of $\tphi$. This unknown is reflected by the imprecision of the resulting $\GWLP$ by propogating to it the imprecision of $\tphi_\pre$ and $\tphi_\post$.
  \end{itemize}

\end{itemize}

\begin{spacing}{1.5}
\begin{align*} \begin{mathleftalign}
\GhandleMethodCall(z.m_C(\vec{e}), \tphi) := \\
\hspace{2em} \tsf{assume}(\conc{\tphi_\post}); \\
\hspace{2em} \impr{\tphi_\pre, \tphi_\post, \tphi} \ \ast \
             \required(\vec{e}) \ \land \ z \ \code{!=} \ \code{null} \ \land \ \required(\tphi_\pre) \ \ast \
\\
\hspace{2em} \text{match} \ \tphi_\pre, \ \tphi_\post \ \text{with}
\\ \hspace{2em} \begin{array}{|llcl}
%
\phi_\pre, & \phi_\post &\mt&
  \tsf{handleMethodCall}(z.m_C(\vec{e}), \tphi)
\\
\phi_\pre, & \phi_\post \ \imprecise &\mt&
  \tsf{required}(\tphi) \setminus \tsf{granted}(\phi_\pre)
\\
\phi_\pre \ \imprecise, & \phi_\post &\mt&
  \tsf{assume} \ \phi_\post; \ \code{true}
\\
\phi_\pre \ \imprecise, & \phi_\post \ \imprecise &\mt&
  \code{true}
%
\end{array}
\end{mathleftalign} \end{align*}
\end{spacing}

%-----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Handling Gradual While Loops}

\begin{spacing}{1.5}
\begin{align*} \begin{mathleftalign}
\GhandleWhileLoop(\tphi_\text{inv}, s_\text{bod}, \tphi) := \\
\hspace{2em} \text{match} \ \tphi_\text{inv} \ \text{with} \\
\hspace{2em} \begin{mathmatchwith}
%
\phi_\text{inv} &\mt&
  \tsf{handleWhileLoop}(\phi_\text{inv}, \ s_\text{bod}, \ \conc{\tphi}) \ \ast \ \impr{\tphi}
\\
\phi_\text{inv} \ \imprecise &\mt&
  \tsf{required}(e) \ \land \
  \phi_\text{inv} \ \ast \
  \GWLP(\code{if} \ (e) \ \{ s_\text{bod} \} \ \code{else} \ \{ \code{skip} \}, \ \phi_\text{inv} \ \imprecise) \
  \imprecise
%
\end{mathmatchwith}
\end{mathleftalign} \end{align*}
\end{spacing}



%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Gradual Utility Functions}

$\granted(\tphi)$ preserves the imprecision of $\tphi$ in order to reflect the fact that imprecision grants \tit{at least} the permissions of $\conc{\tphi}$, and additionally may grant other permissions as well if the $\tphi$ is imprecise. $\required(\tphi)$, on the other hand, only considers $\conc{\tphi}$ because permissions required by sub-formulas introduced via imprecision will be checked for framing at the time they are introduced.
\begin{align*}\begin{mathdefinition}
  \required(\tphi) &:=& \required(\conc{\tphi})
  \\
  \granted(\tphi) &:=& \granted(\conc{\tphi}) \ \ast \ \impr{\tphi}
\end{mathdefinition}\end{align*}
Gradual substitution introduces instances not found in the given imprecise formula into the resulting imprecise formula.
\begin{align*}\begin{mathdefinition}
  [y/x] (\phi \ \imprecise) &:=&
    \begin{cases}
      ([y/x] \phi) \ \imprecise &\text{if $x$ appears in $\phi$} \\
      \phi \ \land \ y \ \imprecise &\text{otherwise}
    \end{cases}
\end{mathdefinition}\end{align*}
