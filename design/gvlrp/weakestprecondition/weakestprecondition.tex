\section{Weakest Predonditions}

\subsection{Concrete Weakest Liberal Precondition Rules}

\newcommand{\WLP}{\tsf{WLP}}
\newcommand{\weakest}{\max\limits_{\implies}}

\begin{spacing}{1.5}
\begin{align*}
\begin{array}{l}
\WLP : \ \tsc{Statement} \times \tsc{SatFormula} \rightarrow \tsc{SatFormula} \\
\WLP(s, \phi) := \ \tsf{match} \ s \ \tsf{with} \\
\begin{array}{|lcl}
%
\code{skip} &\mapsto&
  \phi
\\
s_1 \code{;} \ s_2 &\mapsto&
  \WLP(s_1, \ \WLP(s_2, \phi))
\\
T \ x &\mapsto&
  % TODO: perhaps check that x is not in the freeVariables of \phi
  \phi
\\
x \ \code{:=} \ e &\mapsto&
  \tsf{footprint}(e) \ \land \
  [ e / x ] \phi
\\
x \ \code{:=} \ \code{new} \ C &\mapsto&
  [ \tsf{newInstance}(C) / x ] \phi
\\
x.f \ \code{:=} \ y &\mapsto&
  \tsf{footprint}(x.f) \ \land \
  [ y / x.f ] \phi
\\
y \ \code{:=} \ z.m_C(\overline{e}) &\mapsto&
  \tsf{footprint}(\overline{e}) \ \land \
  (z \ \code{!=} \ \code{null}) \ \land \\ &&
  [ z/\code{this}, \overline{e/x} ] \tsf{pre}(m_C) \ \land \\ &&
  \phi - [ z/\code{this}, \overline{e/\code{old}(x)} ] \tsf{post}(m_C)
\\
\code{if} \ (e) \ \{ s_\text{th} \} \ \code{else} \ \{ s_\text{el} \} &\mapsto&
  \tsf{footprint}(e) \ \land \\ &&
  \code{if} \ (e) \
  \code{then} \ (e \land \WLP(s_\text{th}, \phi) \
  \code{else} \ (\pnot e \land \WLP(s_\text{el}, \phi))
\\
\code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \} &\mapsto&
  \tsf{footprint}(e) \ \land \
  \phi_\text{inv} \ \land \\ &&
  \WLP(s_\text{bod}, \
    (\pnot e \ \land \ \phi) \ \lor \ \\ && \hspace{5.3em}
    \WLP(\code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \}, \ \phi)
  )
\\
\code{assert} \ \phi_\text{ass} &\mapsto&
  \tsf{footprint}(\phi_\text{ass}) \ \land \
  \phi_\text{ass} \ \land \
  \phi
\\
\code{hold} \ \phi_\text{hol} \ \{ s_\text{bod} \} &\mapsto&
  \text{unimplemented} % TODO
\\
\code{release} \ \phi_\text{rel} &\mapsto&
  \text{unimplemented} % TODO
\\
\code{unfold} \ \alpha_C(\overline{e}) &\mapsto&
  \tsf{footprint}(\overline{e}) \ \land \
  [ \tsf{unfolded}(\alpha_C(\overline{e})) / \alpha_C(\overline{e}) ] \phi \ \land \\ &&
  [ \phi\p / \code{unfolding} \ \alpha_C(\overline{e}) \ \code{in} \ \phi\p ]
\\
\code{fold} \ \alpha_C(\overline{e}) &\mapsto&
  \tsf{footprint}(\overline{e}) \ \land \
  [ \alpha_C(\overline{e}) / \tsf{unfolded}(\alpha_C(\overline{e})) ] \phi
%   \tsf{unfolded}(\alpha_C(\overline{e})) \ \land \
%   \phi
%
\end{array}
\end{array}
\end{align*}
\end{spacing}

\newpage
\noindent
Some utility functions are defined as follows. Note that the implementations of these functions can be made much more efficient than the naive definition here in mathematical notation. For example, calculating the \tsf{footprint} of expressions and formulas can avoid redundancy by not generating permissions that are already satisfied. This can be implemented as implicit in $\land$ operations.

\begin{spacing}{1.5}
\begin{align*}
\tsf{footprint}(e) :=
  & \ \tsf{match} \ e \ \tsf{with} \\
  & \begin{array}{|lcl}
      e.f &\mt&
        \tsf{footprint}(e\p) \ \land \
        (e\p \ \code{!=} \ \code{null}) \ \land \
        \code{acc}(e\p.f) \\
      e_1 \oplus e_2 &\mt&
        \tsf{footprint}(e_1) \ \land \ \tsf{footprint}(e_2) \\
      e_1 \otimes e_2 &\mt&
        \tsf{footprint}(e_1) \ \land \ \tsf{footprint}(e_2) \\
    \end{array} \\
\tsf{footprint}(\overline{e}) :=
  & \ \bigwedge \tsf{footprint}(e) \\
\tsf{footprint}(\alpha_C(\overline{e})) :=
  & \ \alpha_C(\overline{e}) \ \land \ \tsf{footprint}(\overline{e}) \\
\tsf{footprint}(\phi) :=
  & \ \bigwedge\set{ \tsf{footprint}(e) : e \ \text{appears in} \ \phi } \ \land \\
  & \ \bigwedge\set{ \tsf{footprint}(\alpha_C(\overline{e})) : \code{unfolding} \ \alpha_C(\overline{e}) \ \code{in} \ \phi\p \ \text{appears in} \ \phi } \\
\\
\tsf{newInstance}(C) :=
  & \ \text{an object that is a new instance of class $C$} \\
  & \ \text{where all fields are assigned to their default values} \\
\\
\tsf{unfolded}(\alpha_C(\overline{e})) :=
  & \ [ \overline{e/x} ] \tsf{body}(\alpha_C) \\
\\
\left(\bigwedge \phi_i\right) - \left(\bigwedge \psi_j\right) :=
  & \ \bigwedge\set{ \phi_i : \nexists \psi \subset \set{ \psi_j }, \psi \implies \phi_i } \\
\\
\tsf{pre}(m_C ) := & \ \text{the pre-condition of the static contract for} \ m_C \\
\tsf{post}(m_C) := & \ \text{the post-condition of the static contract for} \ m_C \\
\\
\tsf{body}(\alpha_C) := & \ \text{the body of predicate} \ \alpha_C \\
\end{align*}
\end{spacing}
