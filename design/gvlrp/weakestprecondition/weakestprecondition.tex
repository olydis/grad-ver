\section{Weakest Predonditions}

\subsection{Concrete Weakest Liberal Precondition Rules}

\newcommand{\WLP}{\tsf{WLP}}
\newcommand{\weakest}{\max\limits_{\implies}}

\begin{spacing}{1.5}
\begin{align*}
\begin{array}{l}
\WLP : \ \tsc{Statement} \times \tsc{SatFormula} \rightarrow \tsc{SatFormula} \\
\WLP(s, \phi) := \ \tsf{match} \ s \ \tsf{with} \\
\begin{array}{|lcl}
%
\code{skip} &\mapsto&
  \phi
\\
s_1 \code{;} \ s_2 &\mapsto&
  \WLP(s_1, \WLP(s_2, \phi))
\\
T \ x &\mapsto&
  \phi
\\
x \ \code{:=} \ e &\mapsto&
  \weakest\set{ \phi\p : \phi\p \implies [e/x] \phi } \land \tsf{hasAccess}(e)
\\
x.f \ \code{:=} \ y &\mapsto&
  \weakest\set{ \phi\p : \phi\p \land (x.f = y) \implies \phi }
\\
x \ \code{:=} \ \code{new} \ C &\mapsto&
  \weakest\set{ \phi\p : \phi\p \land (x = \tsf{newInstance}(C)) \implies \phi }
\\
y \ \code{:=} \ z.m_C(\overline{e}) &\mapsto&
  % \WLP\left(\begin{array}{l}
  %   \code{assert} \ [ z/\code{this}, \overline{e/x} ] \tsf{pre}(z.m_C) \code{;} \\
  %   \text{[} z/\code{this}, \overline{e/x} \text{]} \tsf{body}(z.m_C) \\
  %   \code{assert} \ [ z/\code{this}, y/\code{result}, \overline{e/\code{old}(x)} ] \tsf{post}(z.m_C) \code{;}
  % \end{array},
  % \phi \right)
  \WLP(
    \code{assert} \ [ z/\code{this}, \overline{e/x} ] \tsf{pre}(z.m_C) \code{;} \\ && \hspace{2.5em}
    \text{[} z/\code{this}, \overline{e/x} \text{]} \tsf{body}(z.m_C) \\ && \hspace{2.5em}
    \code{assert} \ [ z/\code{this}, y/\code{result}, \overline{e/\code{old}(x)} ] \tsf{post}(z.m_C) \code{;}, \\ &&
  \bigwedge \tsf{hasAccess}(e) \land \phi )
\\
\code{if} \ (e) \ \{ s_1 \} \ \code{else} \ \{ s_2 \} &\mapsto&
  % \weakest\set{ \phi\p : \phi\p \implies \tsf{if} \ e \ \tsf{then} \ \WLP(s_1, \phi) \ \tsf{else} \ \WLP(s_2, \phi) }
  (\phi\p \land e \implies \WLP(s_1, \phi)) \ \land \
  (\phi\p \land \pnot e \implies \WLP(s_2, \phi))
\\
\code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s \} &\mapsto&
  (\phi\p \implies \phi_\text{inv}) \ \land \
  (\phi\p \land (e = \code{false}) \implies \phi)
\\
\code{assert} \ \phi_\text{ass} &\mapsto&
  \weakest\set{ \phi\p : \phi\p \implies \phi \land \phi_\text{ass} }
\\
\code{hold} \ \phi_\text{hol} &\mapsto&
  TODO
\\
\code{release} \ \phi_\text{rel} &\mapsto&
  TODO
\\
\code{fold} \ \alpha_C(\overline{e}) &\mapsto&
  \bigwedge \tsf{hasAccess}(e) \ \land \
  \weakest\set{ \phi\p : (\phi\p \land \alpha_C(\overline{e}) \implies \phi) }
  \ \land \
  [ \overline{e/x} ] \tsf{body}(\alpha_C)
\\
\code{unfold} \ \alpha_C(\overline{e}) &\mapsto&
  \bigwedge \tsf{hasAccess}(e) \ \land \
  \weakest\{ \phi\p : \phi\p \land  [ \overline{e/x} ] \tsf{body}(\alpha_C) \implies \phi \}
  \ \land \
  \alpha_C(\overline{e})
%
\end{array}
\end{array}
\end{align*}
\end{spacing}

\newpage
\noindent
where the following helper functions are defined as:

\begin{align*}
\tsf{haveAccess}(e) := & \begin{cases}
  % TODO: should the \land in the expression below instead be a \sep?
  \tsf{hasAccess}(e\p) \land \code{acc}(e\p.f) & \text{if} \ e = e\p.f \\
  \code{true} & \text{otherwise}
\end{cases}
\\
\tsf{newInstance}(C) :=
  & \ \text{an object that is a new instance of class $C$} \\
  & \ \text{where all fields are assigned to their default values.}
\\
\end{align*}
