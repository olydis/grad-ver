\section{Weakest Predonditions}

\subsection{Concrete Weakest Liberal Precondition (WLP) Rules}


\begin{spacing}{1.5} \begin{align*} \begin{mathleftalign}
\WLP : \ \tsc{Statement} \times \tsc{FrmSatFormula} \rightarrow \tsc{FrmSatFormula} \\
\WLP(s, \phi) := \
\text{math} \ s \ \text{with} \\
\begin{mathmatchwith}
  %
  \code{skip} &\mapsto&
    \phi
  \\
  s_1 \code{;} \ s_2 &\mapsto&
    \WLP(s_1, \ \WLP(s_2, \phi))
  \\
  T \ x &\mapsto&
    % TODO: implicit check that x is not in the freeVariables of \phi
    \phi \
    \textit{(assert that $x$ does not appear in $\phi$)}
  \\
  x \ \code{:=} \ e &\mapsto&
    \footprint{e} \ \land \
    [ e / x ] \phi
  \\
  x \ \code{:=} \ \code{new} \ C &\mapsto&
    [ \new(C) / x ] \phi
  \\
  x.f \ \code{:=} \ y &\mapsto&
    \footprint{x.f} \ \land \
    [ y / x.f ] \phi
  \\
  % method call
  y \ \code{:=} \ z.m_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    z \ \code{!=} \ \code{null} \ \land \\ &&
    [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \ \ast \\ &&
    \tsf{handleMethodPermissions}(m_C, \phi)
  \\
  \code{if} \ (e) \ \{ s_\text{the} \} \ \code{else} \ \{ s_\text{els} \} &\mapsto&
    \code{if} \ (e) \
    \code{then} \ \WLP(s_\text{the}, \phi) \
    \code{else} \ \WLP(s_\text{els}, \phi)
  \\
  \code{while} \ (e) \ \code{invariant} \ \phi_\text{inv} \ \{ s_\text{bod} \} &\mapsto&
    \footprint{e} \ \land \
    \phi_\text{inv} \ \land \\ &&
    \code{if} \ (e) \
      \code{then} \ \WLP(s_\text{bod}, \phi_\text{inv}) \
      \code{else} \ \phi
  \\
  \code{assert} \ \phi_\text{ass} &\mapsto&
    \footprint{\phi_\text{ass}} \ \land \
    \phi_\text{ass} \ \land \
    \phi
  \\
  \code{hold} \ \phi_\text{hol} \ \{ s_\text{bod} \} &\mapsto&
    \text{(unimplemented)} % UNIMPL
  \\
  \code{release} \ \phi_\text{rel} &\mapsto&
    \text{(unimplemented)} % UNIMPL
  \\
  \code{unfold} \ \alpha_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    [ \unfolded(\alpha_C(\vec{e})) / \alpha_C(\vec{e}), \\ && \
      \phi\p / \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p ]
    \phi
  \\
  \code{fold} \ \alpha_C(\vec{e}) &\mapsto&
    \footprint{\vec{e}} \ \land \
    [ \alpha_C(\vec{e}) / \unfolded(\alpha_C(\vec{e})) ] \phi
  %
  \end{mathmatchwith}
\end{mathleftalign} \end{align*} \end{spacing}

\noindent
Since \tsf{WLP} takes a framed, satisfiable formula and yields a framed, satisfiable formula, there is an implicit check that asserts these properties before and after \tsf{WLP} is computed.

%
%

\newpage
\subsubsection{Utility Functions}

\noindent
The implementations of the functions in this section can be made much more efficient than the naive definition here in mathematical notation. For example, calculating the footprint of expressions and formulas can avoid redundancy by not generating permission-subformulas that are already satisfied. This can be implemented as implicit in $\land$ by a wrapper $\land_\text{wrap}$ operation in some way similar to this:
\begin{align*}
  \phi \ \land_\text{wrap} \ \phi\p := \begin{cases}
    \phi & \text{if} \ \phi \implies \phi\p \\
    \phi \land \phi\p & \text{otherwise}
  \end{cases}
\end{align*}

%
% abbreviations
%
\noindent
The following functions are useful abbreviations for common constructs.
\begin{align*} \begin{mathdefinition}
\new(C) & :=
  & \ \text{an object that is a new instance of class $C$,} \\ &
  & \ \text{where all fields are assigned to their default values}
\\
\unfolded(\alpha_C(\vec{e})) & :=
  & \ [ \vec{e/x} ] \tsf{body}(\alpha_C)
\\
\pre(z.m_C(\vec{e})) & := & [ z/\code{this}, \ \vec{e/x} ] \pre(m_C) \\
\pre(m_C) & := & \ \text{the static-contract pre-condition of} \ m_C \\
\post(z.m_C(\vec{e})) & := &  [ z/\code{this}, \ \vec{e/\code{old}(x)} ] \post(m_C) \\
\post(m_C) & := & \ \text{the static-contract post-condition of} \ m_C \\
\tsf{body}(\alpha_C) & := & \ \text{the body formula of} \ \alpha_C \\
%
\end{mathdefinition} \end{align*}
%
% footprint
%
\noindent
The footprint function, $\footprint{\cdot}$, generates a formula containing all the permissions necessary to frame its argument. With efficient implementations of a wrapped $\land$, this can result in the smallest such formula.
\begin{align*} \begin{mathdefinition}
\footprint{e} & :=
  & \ \text{match} \ e \ \text{with} \\ &
  & \ \begin{mathmatchwith}
        e.f &\mt&
          \footprint{e\p} \ \land \
          e\p \ \code{!=} \ \code{null} \ \land \
          \cacc(e\p.f) \\
        e_1 \oplus e_2 &\mt&
          \footprint{e_1} \ \land \ \footprint{e_2} \\
        e_1 \odot e_2 &\mt&
          \footprint{e_1} \ \land \ \footprint{e_2} \\
        e &\mt&
          \code{true}
    \end{mathmatchwith}
\\
\footprint{\vec{e}} & :=
  & \ \bigwedge \footprint{e}
\\
\footprint{\phi} & :=
  & \ \bigwedge\set{ \footprint{e} : e \ \text{appears in} \ \phi } \ \land \\ &
  & \ \bigwedge\set{ \alpha_C(\vec{e}) : \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p \
                                              \text{appears in} \ \phi }
\end{mathdefinition} \end{align*}
%
% handleMethodPermissions
%
\noindent
The \tsf{handleMethodPermissions} helper function assists in generating the \WLP\ for a method call.
It yields a formula that asserts the following:
\begin{itemize}
  \item[(a)] For all $\cacc(e.f)$ that appear in $\footprint{\phi}$, $\cacc(e.f)$ does not appear in $\pre(z.m_C(\vec{e})) \setminus \post(z.m_C(\vec{e}))$. This asserts that $\phi$ does not use access to a part of the heap whose access was required to call $z.m_C(\vec{e})$ and then not ensured after the call.

  \item[(b)] For all $e.f$ that appear in $\phi$ (not including than those appearing in $\cacc(e.f)$), $\cacc(e.f)$ does not appear in $\pre(z.m_C(\vec{e})) \land \post(z.m_C(\vec{e}))$. This asserts that $\phi$ does not rely on the value of a part of the heap that was accessed by $z.m_C(\vec{e})$.

  \item[(c)] For all $\cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p$ that appear in $\phi$, $\alpha_C(\vec{e})$ does not appear in $\pre(z.m_C(\vec{e})) \land \post(z.m_C(\vec{e}))$. This asserst that $\phi$ does not rely on the truth of any predicates that were used in $z.m_C(\vec{e})$, as predicates may contain heap accesses.
\end{itemize}
%
\begin{align*} \begin{mathleftalign}
\tsf{handleMethodPermissions}(z.m_C(\vec{e}), \phi) := \\ \hspace{6em}
% (a)
\bigwedge\set{ (\pre(z.m_C(\vec{e})) \setminus \post(z.m_C(\vec{e}))) \ast \cacc(e.f) :
                 \footprint{\phi} \implies \cacc(e.f) } \ \land \\ \hspace{6em}
% (b)
\bigwedge\set{ (\pre(z.m_C(\vec{e})) \land \post(z.m_C(\vec{e}))) \ast \cacc(e.f) :
                 e.f \ \text{appears in} \ \phi } \ \land \\ \hspace{6em}
% (c)
\bigwedge\set{ (\pre(z.m_C(\vec{e})) \land \post(z.m_C(\vec{e}))) \ast \alpha_C(\vec{e}) :
                  \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \text{appears in} \ \phi }
\end{mathleftalign} \end{align*}

\noindent
TODO: define without function, $\phi \setminus e$.

%
% \pnot e :=
%   & \ e \ \code{=} \ \code{false}
% \\
% \phi \without e :=
%   & \ \text{match} \ \phi \ \text{with} \\
%   & \ \begin{mathmatchwith}
%         e\p &\mt&
%           \text{match} \ e\p \ \text{with} \\ &&
%           \begin{mathmatchwith}
%             e_1 \oplus e_2 &\mt& TODO \\
%             e_1 \odot  e_2 &\mt& TODO \\
%             e\p &\mt& e\p
%           \end{array}
%         \\
%         A &\mt&
%           TODO
%         \\
%         \cacc(e_\text{ba}.f) &\mt&
%           TODO
%         \\
%         \phi_1 \circast \phi_2 &\mt&
%           TODO
%         \\
%         \code{if} \ e\p \ \code{then} \ \phi_\text{the} \ \code{else} \ \phi_\text{els} &\mt&
%           TODO
%         \\
%         \cunfolding \ A \ \cin \ \phi_\text{un} &\mt&
%           TODO
%         %
%       \end{array}
% \end{align*}
