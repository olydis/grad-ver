\newpage
\section{Framing}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Definitions}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

For framing, a formula is considered inside a \tbf{permission context}, a set of permissions, where a \tbf{permission} $\pi$ is to do one of the following:
\begin{itemize}
  \item to reference $e.f$, written $\accessed(e.f)$.
  \item to assume $\alpha_C(\vec{e})$, written $\assumed(\alpha_C(\vec{e}))$. This allows the a single unrolling of $\alpha_C(\vec{e})$. Explicitly, an instance of $\assumed(\alpha_C(\vec{e}))$ in a set of permissions $\Pi$ may be expanded into $\Pi \cup \granted( \dots )$ where $\dots$ is replaced with a single unrolling of the body of $\alpha_C(\vec{e})$ with the arguments substituted appropriately\footnote{As demonstrated by this description, $\assumed$ predicates are really just a useful shorthand and not a fundamentally new type of permission. The only kind fundamental kind of permission is $\accessed$.}.
\end{itemize}
%
Let $\phi$ be a formula.
$\phi$ may \tbf{require} a permission $\pi$. For example, the formula $e.f = 1$ requires $\accessed(e.f)$, because it references $e.f$. The set of all permissions that $\phi$ requires is called the \tbf{requirements} of $\phi$. $\phi$ may also \tbf{grant} a permission $\pi$. For example, the formula $\cacc(e.f)$ grants the permission $\accessed(e.f)$.

Altogether, $\phi$ is \tbf{framed} by a set of permissions $\Pi$ if all permissions required by $\phi$ are either in $\Pi$ or granted by $\phi$. The proposition that $\Pi$ frames $\phi$ is written
$$
  \Pi \frames \phi
$$
Of course, $\phi$ may grant some of the permissions it requires but not all. The set of permissions that $\phi$ requires but does not grant is called the \tbf{footprint} of $\phi$. The footprint of $\phi$ is written
$$
  \footprint{\phi}
$$
Finally, a $\phi$ is called \tbf{self-framing} if and only if for any set of permissions $\Pi$, $\Pi \frames \phi$. The proposition that $\phi$ is self-framing is written
$$
  \selfframing \phi
$$
Note that $\selfframing \phi \iff \empty \frames \phi$, in other words $\phi$ is self-framing if and only if it grants all of the permissions it requires. Or in other words still, $\footprint{\phi} = \empty$.

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection{Deciding Framing}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

Deciding $\Pi \frames \phi$ must take into account the requirements, granteds, and aliases contained in $\Pi$ and the sub-formulas of $\phi$.
The following recursive algorithm decides $\Pi \frames \phi_{root}$, where $\A$ is implicitly assumed to be the top-level aliasing context (where the top-level in this context is the level that $\phi_{root}$ exists at in the program).

\begin{spacing}{1.5} \begin{align*} \begin{mathleftalign}
\Pi \frames \phi \iff \text{match} \ \phi \ \text{with} \\
\begin{mathmatchwith}
  v &\mt&
    \top
  \\
  x &\mt&
    \top
  \\
  e_1 \oplus e_2 &\mt&
    \Pi \frames e_1, e_2
  \\
  e_1 \odot e_2 &\mt&
    \Pi \frames e_1, e_2
  \\
  e.f &\mt&
    (\Pi \frames e) \ \land \ (\Pi \entails \accessed_\phi(e.f))
  \\
  \cacc(e.f) &\mt&
    (\Pi \frames e)
  \\
  \phi_1 \circledast \phi_2 &\mt&
    (\Pi \cup \granted(\phi_2) \frames \phi_1) \ \land \
    (\Pi \cup \granted(\phi_1) \frames \phi_2)
  \\
  \alpha_C(e_1, \dots, e_k) &\mt&
    \Pi \frames e_1, \dots, e_2
  \\
  \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
    \Pi \frames e, \phi_1, \phi_2
  \\
  \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p &\mt&
    (\Pi \frames \alpha_C(\vec{e})) \ \land \
    (\Pi \entails \assumed_\phi(\alpha_C(\vec{e}))) \ \land \
    (\Pi \frames \phi\p)
  %
\end{mathmatchwith}
\\[4em]\\
\granted(\phi) := \tsf{match} \ \phi \ \tsf{with} \\
\begin{mathmatchwith}
  e &\mt&
    \empty
  \\
  \cacc(e.f) &\mt&
    \set{ \accessed(e.f) }
  \\
  \phi_1 \circast \phi_2 &\mt&
    \granted(\phi_1) \cup \granted(\phi_2)
  \\
  \alpha_C(\vec{e}) &\mt&
    \set{ \assumed(\alpha_C(\vec{e})) }
  \\
  \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
    \granted(\phi_1) \cap \granted(\phi_2)
  \\
  \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p &\mt&
    \granted(\phi\p)
\end{mathmatchwith}
\end{mathleftalign} \end{align*} \end{spacing}

\noindent
Where $\accessed_\phi$ and $\assumed_\phi$ indicate the respective propositions considered within the total alias context (including inherited aliasing contexts). More explicitly,
\begin{align*}
\Pi \entails \accessed_\phi(o.f)
\iff &
  \exists \accessed(o\p.f) \in \Pi :
  \A(\phi) \entails \aliased\set{o, o\p}
\\
\Pi \entails \assumed_\phi(\alpha_C(e_1, \dots, e_k))
\iff &
  \exists \assumed(\alpha_C(e\p_1, \dots, e\p_k)) \in \Pi :
  \forall i : \A(\phi) \entails \aliased\set{e_i, e\p_i}
  % (\forall i :
  %   (e_i = e\p_i) \ \lor \\ & \hspace{2em}
  %   (\exists o, o\p :
  %     ((o, o\p) = (e_i, e\p_i)) \land
  %     \A(\phi) \entails \aliased\set{o, o\p})
  % )
  % \\ & \ \land \
  % (\assumed(\alpha_C(e\p_1, \dots, e\p_k)) \in \Pi)
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection{Examples}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

In the following examples, assume that the considered formulas are well-formed.

% ----------------------------------------------------------------------------------------------------------------------------
\subsubsection*{Example 1}

Define
\begin{align*}
\phiroot := & \ x = y \ast \cacc(x.f) \ast \cacc(y.f).
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \ \context{ \set{\aliased\set{x,y}} }{ \empty }.
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
\empty \frames x = y \ast \cacc(x.f) \ast \cacc(y.f)
\\ \iff & \
( \granted(\cacc(x.f) \ast \cacc(y.f)) \frames x = y ) \ \land \\ & \
( \granted(x = y \ast \cacc(y.f)) \frames \cacc(x.f) ) \ \land \\ & \
( \granted(x = y \ast \cacc(x.f)) \frames \cacc(y.f) )
\\ \iff & \
\top \ \land \\ & \
( \granted(x = y \ast \cacc(y.f)) \frames x ) \ \land \\ & \
( \granted(x = y \ast \cacc(x.f)) \frames y )
\\ \iff & \
\top \ \land \ \top \ \land \ \top
\\ \iff & \
\top
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsubsection*{Example 2}

Define
\begin{align*}
\phiroot := & \
\cacc(x.f) \ \ast \ (\cif \ x.f = 1 \ \cthen \ true \ \celse \ \cacc(x.f))
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \
\context{\empty}{\set{ x.f = 1 : \context{\empty}{\empty} ,\ x.f \neq 1: \context{\empty}{\empty} }} \\
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
\empty \frames \cacc(x.f) \ \ast \ (\cif \ x.f = 1 \ \cthen \ true \ \celse \ \cacc(x.f))
\\ \iff & \
( \granted(\cif \ x.f = 1 \ \cthen \ \ctrue \ \celse \ \cacc(x.f)) \frames \cacc(x.f) ) \ \land \\ & \
( \granted(\cacc(x.f)) \frames \cif \ x.f = 1 \ \cthen \ \ctrue \ \celse \ \cacc(x.f) )
\\ \iff & \
( \granted(\cif \ x.f = 1 \ \cthen \ \ctrue \ \celse \ \cacc(x.f)) \frames x ) \ \land \\ & \
( \granted(\cacc(x.f)) \frames \cif \ x.f = 1 \ \cthen \ \ctrue \ \celse \ \cacc(x.f) )
\\ \iff & \
\top \ \land \ ( \granted(\cacc(x.f)) \frames \cif \ x.f = 1 \ \cthen \ \ctrue \ \celse \ \cacc(x.f) )
\\ \iff & \
\top \ \land \ ( \set{ \accessed(x.f) } \frames \cif \ x.f = 1 \ \cthen \ \ctrue \ \celse \ \cacc(x.f) )
\\ \iff & \
\top \ \land \
( \set{ \accessed(x.f) } \frames x.f = 1 ) \ \land \
( \set{ \accessed(x.f) } \frames \ctrue ) \ \land \\ & \
( \set{ \accessed(x.f) } \frames \cacc(x.f)
\\ \iff & \
\top \ \land \
( \set{ \accessed(x.f) } \entails \accessed_{\phiroot}(x.f) ) \ \land \\ & \
\top \ \land \
( \set{ \accessed(x.f) } \frames x )
\\ \iff & \
\top \ \land \
\top \ \land \
\top \ \land \
\top
\\ \iff & \
\top
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection*{Example 3}

Define
\begin{align*}
\phiroot := & \ \cacc(x.f) \ \ast \ x = y \ \ast \ y.f = 1
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \ \context{ \set{ \aliased\set{x,y}} } \empty
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
\empty \frames \cacc(x.f) \ \ast \ x = y \ \ast \ y.f = 1
\\ \iff & \
( \granted(x = y \ast y.f = 1) \frames \cacc(x.f) ) \ \land \\ & \
( \granted(\cacc(x.f) \ast y.f = 1) \frames x = y ) \ \land \\ & \
( \granted(\cacc(x.f) \ast x = y) \frames y.f = 1 )
\\ \iff & \
( \granted(x = y \ast y.f = 1) \frames x ) \ \land \\ & \
( \granted(\cacc(x.f) \ast y.f = 1) \frames x, y ) \ \land \\ & \
( \granted(\cacc(x.f) \ast x = y) \frames y.f )
\\ \iff & \
\top \ \land \ \top \land \ ( \set{ \accessed(x.f) } \entails \accessed_{\phiroot}(y.f) )
\\ \iff & \
\top \ \land \ \top \land \ \top
\\ \iff & \
\top
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection*{Example 4}

Define
\begin{align*}
&\hspace{0em} \ttt{class} \ \List \ \{ \\
&\hspace{2em}   \int \ \vhead \ttt{;} \\
&\hspace{2em}   \List \ \vtail \ttt{;} \\
&\hspace{2em}   \ttt{predicate} \ \List(l) = \\
&\hspace{4em}     l \neq \cnull \ \ast \ \cacc(l.\vhead) \ \ast \ \cacc(l.\vtail) \ \ast \\
&\hspace{4em}     \cif \ l.\vtail = \cnull \ \cthen \ \ctrue \ \celse \ \List(l.\vtail) \ttt{;} \\
&\hspace{0em} \ \}
\end{align*}
%
\begin{align*}
\phiroot := & \
\List(l) \ \ast \ \cunfolding \ \List(l) \ \cin \ l.\vhead = 1
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \
\langle
  \empty ,\
  \{
    \cunfolding(\List(l)) : \\ & \hspace{4em}
    \{
      \langle
        \empty ,\
        \{
          t.\vtail = \cnull : \context{ \set{\aliased\set{t.\vtail, \cnull}} }{\empty} ,\
          t.\vtail \neq \cnull : \context{\empty}{\empty}
        \}
      \rangle
    \}
  \}
\rangle
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
\empty \frames
\List(l) \ \ast \ \cunfolding \ \List(l) \ \cin \ l.\vhead = 1
\\ \iff & \
( \granted(\cunfolding \ \List(l) \ \cin \ l.\vhead = 1) \frames \List(l) ) \ \land \\ & \
( \granted(\List(l)) \frames \cunfolding \ \List(l) \ \cin \ l.\vhead = 1 )
\\ \iff & \
\top \ \land \ ( \set{ \assumed(\List(l)) } \frames \cunfolding \ \List(l) \ \cin \ l.\vhead = 1 )
\\ \iff & \
\top \ \land \
( \granted(
    l \neq \cnull \ \ast \ \cacc(l.\vhead) \ \ast \ \cacc(l.\vtail) \ \ast \\ & \hspace{2em}
    \cif \ l.\vtail = \cnull \ \cthen \ \ctrue \ \celse \ \List(l.\vtail) )
    \frames
    \tag{expansion of $\assumed(\List(l))$} \\ & \
  l.\vhead = 1 )
\\ \iff & \
\top \ \land \ ( \set{ \accessed(l.\vhead), \accessed(l,\vtail) } ) \frames l.\vhead = 1 )
\\ \iff & \
\top \ \land \ ( \set{ \accessed(l.\vhead), \accessed(l,\vtail) } ) \entails \accessed_{\phiroot}(l.\vhead) )
\\ \iff & \
\top \ \land \ \top
\\ \iff & \
\top
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection*{Example 5}

Define
\begin{align*}
\phiroot := & \
\cif \ x = \cnull \ \cthen \ \ctrue \ \celse \ (\cacc(x.f) \ast x.f = 1)
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \
\context{\empty}{\set{
  x = \cnull: \context{\set{ \aliased\set{x, \cnull} }}{\empty},
  x \neq \cnull: \context{\empty}{\empty}
}}
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
  \empty
  \frames
  \cif \ x = \cnull \ \cthen \ \ctrue \ \celse \ (\cacc(x.f) \ast x.f = 1)
\\ \iff & \
  (\empty \frames x = \cnull) \ \land \
  (\empty \frames \ctrue) \ \land \
  (\empty \frames \cacc(x.f) \ast x.f = 1)
\\ \iff & \
  \top \ \land \ \top \ \land
  ( \granted(x.f = 1) \frames \cacc(x.f) ) \ \land
  ( \granted(\cacc(x.f)) \frames x.f = 1 )
\\ \iff & \
  \top \ \land \ \top \ \land
  ( \empty \frames \cacc(x.f) ) \ \land
  ( \set{ \accessed(x.f) } \frames x.f = 1 )
\\ \iff & \
  \top \ \land \ \top \ \land
  ( \empty \frames x ) \ \land \\ & \
  ( \set{ \accessed(x.f) } \entails \accessed_{x.f}(x.f) ) \ \land
  ( \set{ \accessed(x.f) } \frames 1 )
\\ \iff & \
  \top \ \land \ \top \ \land \
  \top \ \land \ \top \ \land \
  \top
\\ \iff & \
  \top
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection*{Example 6}

Use the definition of \List \ from example 4. Define
\begin{align*}
% (if l == null then true else acc(l.head) acc(l.tail) List(l)) * if l == null then true else l.head == 5
\phiroot := & \ \cacc(x.f) \ \ast \ \phi_1 \ \ast \phi_2
\\
\phi_1 := & \ \cif \ x.f = 1 \ \cthen \ x = y   \ \celse \ \ctrue
\\
\phi_2 := & \ \cif \ x.f = 1 \ \cthen \ y.f = 1 \ \celse \ \ctrue
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \
\context
  { \empty }
  { \set{
    x.f = 1    : \context{\set{\aliased\set{x,y}}}{\empty} ,\
    x.f \neq 1 : \context{\empty}{\empty}
  } }
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames
\cacc(x.f) \ \ast \ \phi_1 \ \ast \phi_2
\\ \iff & \
( \granted(\phi_1 \ast \phi_2) \frames \cacc(x.f) ) \ \land \
( \granted(\cacc(x.f) \ast \phi_2) \frames \phi_1 ) \ \land \\ & \
( \granted(\cacc(x.f) \ast \phi_1) \frames \phi_2 )
\\ \iff & \
( \granted(\phi_1 \ast \phi_2) \frames x ) \ \land \\ & \
( \set{\accessed(x.f)} \frames \cif \ x.f = 1 \ \cthen \ x = y   \ \celse \ \ctrue ) \ \land \\ & \
( \set{\accessed(x.f)} \frames \cif \ x.f = 1 \ \cthen \ y.f = 1 \ \celse \ \ctrue )
\\ \iff & \
\top \ \land \
( \set{\accessed(x.f)} \frames (x.f = 1), (x = y), (\ctrue) ) \ \land \\ & \
( \set{\accessed(x.f)} \frames (x.f = 1), (y.f = 1), (\ctrue) )
\\ \iff & \
\top \ \land \
( \set{\accessed(x.f)} \frames x.f ) \ \land \
( \set{\accessed(x.f)} \frames x.f ) \ \land \\ & \
( \set{\accessed(x.f)} \frames y.f )
\\ \iff & \
\top \ \land \
( \set{\accessed(x.f)} \entails \accessed_\phiroot(x.f) ) \ \land \\ & \
( \set{\accessed(x.f)} \entails \accessed_{y.f = 1}(y.f) )
\\ \iff & \
\top \ \land \ \top \ \land \ \top \tag{$\star$}
\\ \iff & \
\top
\end{align*}
$(\star)$: $\set{\accessed(x.f)} \entails \accessed_{y.f = 1}(y.f) \iff \top$ since $\A(y.f = 1) \entails \aliased\set{x,y}$ because $\A(y.f = 1)$ and $\A(x = y)$ are combined into a single branch of $\A(\phiroot)$, as they have the same conditions.

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection*{Example 7}

Define
\begin{align*}
\phiroot := & \
\cif \ x = y \ \cthen \ \cacc(x.f) \ \celse \ x.f = 2
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \
\context
  {\empty}
  {\set{
    x = y : \context{\set{ \aliased\set{x,y} }}{\empty} ,\
    x \neq y : \context{\empty}{\empty}
  }}
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
\empty \frames \cif \ x = y \ \cthen \ \cacc(x.f) \ \celse \ x.f = 2
\\ \iff & \
\empty \frames (x = y), (\cacc(x.f)), (x.f = 2)
\\ \iff & \
\top \ \land \ (\empty \frames x) \ \land \ (\empty \frames x.f)
\\ \iff & \
\top \ \land \ \top \ \land \ (\empty \entails \accessed_{x.f = 2}(x.f))
\\ \iff & \
\top \ \land \ \top \ \land \ \bot
\\ \iff & \
\bot
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection*{Example 8}

\newcommand{\aliasChoice}{\tsf{aliasChoice}}

Define
%
% predicate
\begin{align*}
\ttt{predicate} \ \aliasChoice(x, y, z) := \
x = y \bor x = z
\end{align*}
%
% forumal
\begin{align*}
\phiroot := & \
\cacc(x.f) \ \ast \ \aliasChoice(x,y,z) \ \ast \
\cunfolding(\aliasChoice(x,y,z)) \ \cin \ \phi_1
\\
\phi_1 := & \
y.f = 1 \bor z.f = 1
\end{align*}
%
% aliasing context
Then
\begin{align*}
\A(\phiroot) =
& \hspace{0.0em} \ \langle \empty ,\ \{ \cunfolding(\aliasChoice(x,y,z)) : \\
& \hspace{4.0em} \    \{ x = y : \context{\set{ \aliased\set{x,y} }}{\empty} , \\
& \hspace{4.1em} \    \  x \neq y   : \context{\set{ \aliased\set{x,z} }}{\empty} , \\
& \hspace{4.1em} \    \  y.f = 1    : \context{\empty}{\empty} , \\
& \hspace{4.1em} \    \  y.f \neq 1 : \context{\empty}{\empty} \} \rangle \}
\end{align*}
Note that the $x = y \bor x = z$ in the body of $\aliasChoice$ is translated to $\cif \ x = y \ \cthen \ \ctrue \ \celse \ x = z$ when construction $\A(\phi_1)$.
And so,
\begin{align*}
\selfframing \phiroot
\iff & \
\empty \frames \phiroot
\\ \iff & \
\empty \frames
\cacc(x.f) \ \ast \ \aliasChoice(x,y,z) \ \ast \ \cunfolding(\aliasChoice(x,y,z)) \ \cin \ \phi_1
\\ \iff & \
( \granted(\aliasChoice(x,y,z) \ \ast \ \cunfolding(\aliasChoice(x,y,z)) \ \cin \ \phi_1) \frames \cacc(x.f) ) \ \land \\ & \
( \granted(\cacc(x.f) \ \ast \  \cunfolding(\aliasChoice(x,y,z)) \ \cin \ \phi_1) \frames \aliasChoice(x,y,z) ) \ \land \\ & \
( \granted(\cacc(x.f) \ \ast \ \aliasChoice(x,y,z)) \frames \cunfolding(\aliasChoice(x,y,z)) \ \cin \ \phi_1 )
\\ \iff & \
\top \ \land \
( \set{ \accessed(x.f) } \frames \aliasChoice(x,y,z) ) \ \land \\ & \
( \set{ \accessed(x.f), \assumed(\aliasChoice(x,y,z)) } \frames \cunfolding(\aliasChoice(x,y,z)) \ \cin \ \phi_1 )
\\ \iff & \
\top \ \land \ \top \ \land \ ( \set{ \accessed(x.f) } \frames y.f = 1 \bor z.f = 1 )
\\ \iff & \
\top \ \land \ \top \ \land \
( \set{ \accessed(x.f) } \frames y.f ) \ \land \
( \set{ \accessed(x.f) } \frames z.f )
\\ \iff & \
\top \ \land \ \top \ \land \
( \set{ \accessed(x.f) } \entails \accessed_{y.f = 1}(y.f) ) \ \land \
( \set{ \accessed(x.f) } \entails \accessed_{z.f = 1}(z.f) )
\tag{$\star$}
\\ \iff & \
\top \ \land \ \top \ \land \
\bot \ \land \
\bot
\\ \iff & \
\bot
\end{align*}
$(\star)$: The acccessed to $y.f, z.f$ are not framed because it is statically undetermined which branch of $x = y \bor x = z$ will be taken. The case could arise that $x = z$ and then when checking the condition $y.f = 1$ there is not access to $y.f$. The idea of the original formula can be correctly captured in one of the following revisions:
\begin{align*}
\phi\p_\tsf{root} := & \
\cacc(x.f) \ \ast \
(x = y \bor x = z) \ \ast \
\cif \ x = y \
  \cthen \ y.f = 1 \
  \celse \ z.f = 1
\\
\phi\p_\tsf{root} := & \
\cacc(x.f) \ \ast \
\cif \ x = y \
  \cthen \ y.f = 1 \
  \celse \
    (\cif \ x = z \
      \cthen \ z.f = 1 \
      \celse \ \cfalse)
\end{align*}
For example. the $z.f = 1$ will be framed because the aliasing context of the $x \neq y$ branch of $(x = y \bor x = z)$ will be combined with the aliasing context of the $x \neq y$ branch of $(\cif \ x = y \ \cthen \ y.f = 1 \ \celse \ z.f = 1)$, yielding $\aliased\set{x,z}$ in $z.f = 1$. The similar case holds for the $x = y$ branches combining to allow the aliasing to frame $y.f = 1$.


% % ----------------------------------------------------------------------------------------------------------------------------
% \newpage
% \subsection*{Example X}
%
% Define
% \begin{align*}
% \phiroot := & \ %
% \end{align*}
% Then
% \begin{align*}
% \A(\phiroot) = & \ %
% \end{align*}
% And so,
% \begin{align*}
% \selfframing \phiroot
% \iff & \
% \empty \frames \phiroot \\
% & %
% \end{align*}
