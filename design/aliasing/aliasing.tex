\section{Aliasing}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Definitions}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

An \tbf{object variable} is one of the following:
\begin{itemize}
  \item a class instance variable i.e. a variable $v$ such that $v : C$ for some class $C$.
  \item a class instance field reference i.e. a field reference $e.f$ where $e.f : C$ for some class $C$.
\end{itemize}
Let $\O$ be a set of object variables.
An $O \subset \O$ \tbf{aliases} if and only if
each $o \in O$ refers to the same memory in the heap as each other,
written propositionally as
$$
  \forall o, o\p \in O : o = o\p \iff \aliases(O)
$$
% TODO: not needed
% An $O \subset \O$ \tbf{non-aliases} if and only if
% each $o \in O$ refers to separate memory in the heap as each other,
% written propositionally as
% $$
%   \forall o, \tilde o : o \neq \tilde o \iff \nonaliases(O)
% $$

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Aliasing Context}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

Let $\phi$ be a formula.
The \tbf{aliasing context} $\A$ of $\phi$ is a tree of set of aliasing proposition about aliasing of object variables that appear in $\phi$.
$\A$ needs to be a tree because the conditional sub-formulas that may appear in $\phi$ allow for branching aliasing contexts not expressible flatly at the top level.
Each node in the tree corresponds to a set of aliasing propositions, and each branch refers to a branch of a unique conditional in $\phi$.
The parts of the tree are labeled in such a way that modularly allows a specified sub-formula of $\phi$ to be matched to the unique aliasing sub-context that corresponds to it.
\\
For example, consider the following formula:
\begin{align*}
  \phi
  :=
  \  & \hspace{0em} (o_1 = o_2) \ \ast
  \\ & \hspace{0em} (\cif \ (b_1)
  \\ & \hspace{1em}    \cthen \ (
  \\ & \hspace{2em}      (o_1 \neq o_3) \ \ast \
  \\ & \hspace{2em}      (\cif \ (b_2)
  \\ & \hspace{3em}        \ \cthen \ (o_1 = o_4) \
  \\ & \hspace{3em}        \ \celse \ (b_3)))
  \\ & \hspace{1em}    \ \celse \ (o_1 = o_3)) \ \ast
  \\ & \hspace{0em} (o_1 = o_4)
\end{align*}
$\phi$ has a formula-structure represented by the tree in figure~\ref{fig:aliasing-context-formula-example}.
The formula-structure tree for $\phi$ corresponds node-for-node and edge-for-edge to the aliasing context tree in figure~\ref{fig:aliasing-context-example}.
\\
%
\begin{figure}[h!]
  \label{fig:aliasing-context-formula-example}
  \caption{Formula structure tree for $\phi$.}
  \vspace{1em}
  \input{aliasing/aliasing-context-formula-example.tex}
\end{figure}
%
\begin{figure}[h!]
  \label{fig:aliasing-context-example}
  \caption{$\A(\phi)$, the aliasing context tree for $\phi$.}
  \vspace{1em}
  \input{aliasing/aliasing-context-example.tex}
\end{figure}
%
More generally, for $\phi$ a formula and $\phi\p$ a sub-formula of $\phi$, write $\A_\phi(\phi\p)$ as the \tbf{total aliasing context} of $\phi\p$ which includes aliasing propositions inherited from its ancestors in the aliasing context tree of $\phi$.
So for example, the total aliasing context at the sub-formula $(o_1 = o_4)$ of $\phi$ is:
\begin{align*}
  \A_\phi(o_1 = o_4) := &
  \{
    \aliased\set{o_1, o_2, o_4}, \\ & \
    \pnot \aliased\set{o_1, o_3},
    \pnot \aliased\set{o_2, o_3},
    \pnot \aliased\set{o_3, o_4}
  \}
\end{align*}
along with the fact that it has no child branches.
Usually $\A_\phiroot(\phi\p)$ is abbreviated to $\A(\phi\p)$ when the top level formula $\phi$ is implicit and $\phi\p$ is a sub-formula of $\phiroot$.

An aliasing context $\A$ may entail a proposition $P$ about aliasing. This judgement is written
$$
\A \entails P.
$$
For a set of object variables $O$, such propositions to consider come in two forms
\begin{align*}
P \ ::= \ \aliases(O) \ \mid \ \pnot \aliases(O).
\end{align*}
Since $\A$ is efficiently represented as a set of propositions about sets, it may be the case that $P \not\in \A$ yet still $A \entails P$.
So, the general aliasing judgments are decided in the following ways for each case:
\begin{align*}
\A \entails \aliases(O)
&\iff
\exists O\p \subset \O : (O \subset O\p) \ \land \ (\aliases(O\p) \in \A)
\\
\A \entails \pnot \aliases(O)
&\iff
\exists O\p \subset \O : (O \subset O\p) \land \ (\pnot \aliases(O\p) \in \A)
\end{align*}
The notation $P \in \A$ is a little misleading because $\A$ is in fact a tree and not just a set. $P \in \A$ explicitly is the proposition that $P$ is a member of the set \tit{at} the level of $\A$, ignoring its children. The structure of $\A$ is detailed formally in the next section.

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Constructing an Aliasing Context}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

\newcommand{\context}[2]{\langle #1, #2 \rangle}

An aliasing context of a formula $\phi$ is a tree, where nodes represent local aliasing contexts and branches represent the branches of conditional sub-formulas nested in $\phi$. So, an aliasing context is defined structurally as
\begin{align*}
  \A \ ::= \context{A}{\set{A_\alpha}}
\end{align*}
where $A$ is a set of propositions about aliasing and the $A_\alpha$ are the nesting aliasing contexts that correspond to the \tsf{then} and \tsf{else} branches of conditionals directly nested in $\phi$. For the purposes of look-up, each $\A$ is labeled by the sub-formula it corresponds to.

Given a root formula $\phi_\tsf{root}$, the aliasing context of $\phi_\tsf{root}$ is written $\A(\phi_\tsf{root})$. With the root invariant, the following recursive algorithm constructs $\A(\phi)$ for any sub-formula of $\phi_\tsf{root}$ (including $\A(\phi_\tsf{root}$)).
%
\begin{align*}
\begin{array}{rclcl}
\A(\phi) &:=& \tsf{match} \ \phi \ \tsf{with} \\
&& v &\mt&
  \context{\empty}{\empty}
\\
&& x &\mt&
  \context{\empty}{\empty}
\\
&& e_1 \band e_2 &\mt&
  \A(e_1) \contextunion \A(e_2)
\\
&& e_1 \bor e_2 &\mt&
  \A(e_1) \contextintersection \A(e_2)
\\
&& e_1 \oplus e_2 &\mt&
  \context{\empty}{\empty}
\\
&& o_1 = o_2 &\mt&
  \context{\set{\aliases\set{o_1, o_2}}}{\empty} % TODO:
\\
&& o_1 \neq o_2 &\mt&
  \context{\set{\pnot \aliases\set{o_1, o_2}}}{\empty}
\\
&& e_1 \odot e_2 &\mt&
  \context{\empty}{\empty}
\\
&& e.f &\mt&
  \context{\empty}{\empty}
\\
&& \cacc(e.f) &\mt&
  \context{\empty}{\empty}
\\
&& \phi_1 \ast \phi_2 &\mt&
  \A(\phi_1) \contextunion \A(\phi_2)
\\
&& \phi_1 \land \phi_2 &\mt&
  \A(\phi_1) \contextunion \A(\phi_2)
\\
&& \alpha_C(e_1, \dots, e_k) &\mt&
  \context{\empty}{\empty}
\\
&& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
  \context{\empty}{\set{ \A(e) \contextunion \A(\phi_1), (\pnot \A(e)) \contextunion \A(\phi_2) }}
\\
&& \cunfolding \ \alpha_C(e_1, \dots, e_k) \ \cin \ \phi\p &\mt&
  \A(\phi\p)
\end{array}
\end{align*}
%
where context union, $\contextunion$, and context intersection, $\contextintersection$, are operations that combine aliasing contexts, as defined below.
%
% TODO: merge if-then-else branches that have the same condition
\begin{align*}
\context{A_1}{\set{\A_{1\alpha}}} \contextunion \context{A_2}{\set{\A_{2\alpha}}} =& \
\langle
  \set{
    \aliased\set{ o\p \mid A_1 \cup A_2 \entails \aliased\set{o,o\p} }
    \mid
    o \in \O
  } \ \cup \\ & \ \
  \{
    \pnot \aliased\set{o\p, \tilde o}
    \mid
    (A_1 \cup A_2 \entails \aliased\set{o, o\p}) \land \\ & \hspace{2em}
    (A_1 \cup A_2 \entails \pnot \aliased\set{o, \tilde o})
  \}
, \\ & \ \
  \bigcup \set{ \A_{1\alpha} \contextunion \A_{2\alpha} \mid
  \A_{1\alpha}, \A_{2\alpha} \ \text{have equivelant conditions} }
\rangle
%
\\[1em]
%
\context{A_1}{\set{\A_{1\alpha}}} \contextintersection \context{A_2}{\set{\A_{2\alpha}}} =& \
\langle
  \set{
    \aliased\set{ o\p \mid A_1 \cap A_2 \entails \aliased\set{o,o\p} }
    \mid
    o \in \O
  } \ \cup \\ & \ \
  \{
    \pnot \aliased\set{o\p, \tilde o}
    \mid
    (A_1 \cap A_2 \entails \aliased\set{o, o\p}) \land \\ & \hspace{2em}
    (A_1 \cap A_2 \entails \pnot \aliased\set{o, \tilde o})
  \}
, \\ &  \ \
\bigcup \set{ \A_{1\alpha} \contextintersection \A_{2\alpha} \mid
\A_{1\alpha}, \A_{2\alpha} \ \text{have equivelant conditions} }
\rangle
\\
\end{align*}
As defined, it is possible for inconsistent aliasing contexts to arise. As a simple example, the formula $\phi := x = y \ \band \ x \neq y$ would yield the aliasing context
\begin{align*}
  \A(\phi) = & \
  \A(x = y) \contextunion \A(x \neq y \\ = & \
  \context{\set{ \aliased\set{x,y} }} \empty \ \contextunion \
  \context{\set{ \pnot \aliased\set{x,y} }} \empty \\ = & \
  \context{\set{ \aliased\set{x,y}, \pnot \aliased\set{x,y} }} \empty.
\end{align*}
An inconsistent aliasing context is unsatisfiable, so if such an aliasing context arises then the root formula is considered not well-formed, and an \tsf{Inconsistent aliasing context} exception is raised. This causes an error rather than just treats the formula as unsatisfiable because well-formedness is required before checking satisfiability.
%TODO: explain this desicion
