\section{Aliasing}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Definitions}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

An \tbf{object variable} is one of the following:
\begin{itemize}
  \item a class instance variable i.e. a variable $v$ such that $v : C$ for some class $C$.
  \item a class instance field reference i.e. a field reference $e.f$ where $e.f : C$ for some class $C$.
\end{itemize}
Let $\O$ be a set of object variables.
An $O \subset \O$ \tbf{aliases} if and only if
each $o \in O$ refers to the same memory in the heap as each other,
written propositionally as
$$
  \forall o, o\p \in O : o = o\p \iff \aliases(O)
$$
An $O \subset \O$ \tbf{non-aliases} if and only if
each $o \in O$ refers to separate memory in the heap as each other,
written propositionally as
$$
  \forall o, \tilde o : o \neq \tilde o \iff \nonaliases(O)
$$

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Aliasing Context}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

Let $\phi$ be a formula.
The \tbf{aliasing context} $\A$ of $\phi$ is a tree of set of aliasing proposition about aliasing of object variables that appear in $\phi$.
$\A$ needs to be a tree because the conditional sub-formulas that may appear in $\phi$ allow for branching aliasing contexts not expressible flatly at the top level.
Each node in the tree corresponds to a set of aliasing propositions, and each branch refers to a branch of a unique conditional in $\phi$.
The parts of the tree are labeled in such a way that modularly allows a specified sub-formula of $\phi$ to be matched to the unique aliasing sub-context that corresponds to it.
\\
For example, consider the following formula:
\begin{align*}
  \phi
  :=
  \  & \hspace{0em} (o_1 = o_2) \ \ast
  \\ & \hspace{0em} (\cif \ (b_1)
  \\ & \hspace{1em}    \cthen \ (
  \\ & \hspace{2em}      (o_1 \neq o_3) \ \ast \
  \\ & \hspace{2em}      (\cif \ (b_2)
  \\ & \hspace{3em}        \ \cthen \ (o_1 = o_4) \
  \\ & \hspace{3em}        \ \celse \ (b_3)))
  \\ & \hspace{1em}    \ \celse \ (o_1 = o_3)) \ \ast
  \\ & \hspace{0em} (o_1 = o_4)
\end{align*}
$\phi$ has a formula-structure represented by the tree in figure~\ref{fig:aliasing-context-formula-example}.
The formula-structure tree for $\phi$ corresponds node-for-node and edge-for-edge to the aliasing context tree in figure~\ref{fig:aliasing-context-example}.
\\
%
\begin{figure}[h!]
  \label{fig:aliasing-context-formula-example}
  \caption{Formula structure tree for $\phi$.}
  \vspace{1em}
  \input{aliasing/aliasing-context-formula-example.tex}
\end{figure}
%
\begin{figure}[h!]
  \label{fig:aliasing-context-example}
  \caption{$\A(\phi)$, the aliasing context tree for $\phi$.}
  \vspace{1em}
  \input{aliasing/aliasing-context-example.tex}
\end{figure}
%
where a node inherits all the aliasing assertions of its parents.
So for example, the aliasing context for the sub-formula $(o_1 = o_4)$ of $\phi$ is:
$$
  \A_\phi(o_1 = o_4) :=
  \set{
    \aliased\set{o_1, o_2, o_4},
    \pnot \aliased\set{o_1, o_3},
    \pnot \aliased\set{o_2, o_3},
    \pnot \aliased\set{o_3, o_4}
  }
$$
More generally, for $\phi$ a formula and $\phi\p$ a sub-formula of $\phi$, write $\A_\phi(\phi\p)$ as the \tbf{total aliasing context} of $\phi\p$ which including aliasing propositions inherited from its ancestors in the aliasing context tree of $\phi$. Usually $\A_\phi(\phi\p)$ is abbreviated to $\A(\phi\p)$ when the top level formula $\phi$ is implicit.

An aliasing context $\A$ may entail a proposition $P$ about aliasing. This judgement is written
$$
\A \entails P.
$$
For a set of object variables $O$, such propositions to consider come in two forms
\begin{align*}
P \ ::= \ \aliases(O) \ \mid \ \pnot \aliases(O).
\end{align*}
Since $\A$ is efficiently represented as a set of propositions about sets, it may be the case that $P \not\in \A$ yet still $A \entails P$.
So, the general aliasing judgments are decided in the following ways for each case:
\begin{align*}
\A \entails \aliases(O)
&\iff
\exists O\p \subset \O : (O \subset O\p) \ \land \ (\aliases(O\p) \in \A)
\\
\A \entails \pnot \aliases(O)
&\iff
\exists O\p \subset \O : (O \subset O\p) \land \ (\pnot \aliases(O\p) \in \A)
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Constructing an Aliasing Context}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

An aliasing context of a formula $\phi$ is a tree, where nodes represent local aliasing contexts and branches represent the branches of conditional sub-formulas nested in $\phi$. So, an alias context is defined structurally as
\begin{align*}
  \A \ ::=
  & \ \tsf{Leaf}(S) \ | \
  \tsf{Branch}(S, \set{ A_\alpha })
\end{align*}
where $S$ is a set of propositions about aliasing and the $A_\alpha$ are the nesting alliasing contexts that correspond to the \tsf{then} and \tsf{else} branches of conditionals directly nested in $\phi$. For the purposes of look-up, these branches are labelled as necessary.

Given a root formula $\phi_\tsf{root}$, the alias context of $\phi_\tsf{root}$ is written $\A(\phi_\tsf{root})$. With the root invariant, the following recursive algorithm constructs $\A(\phi)$ for any sub-formula of $\phi_\tsf{root}$ (including $\A(\phi_\tsf{root}$)).

\begin{align*}
\begin{array}{rclcl}
A(\phi) &:=& \tsf{match} \ \phi \ \tsf{with} &
\end{array}
\end{align*}
