\documentclass {llncs}

%\usepackage[letterpaper]{geometry}
\usepackage{makeidx}  % allows for indexgeneration

% OUR PACKAGES
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stix}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{textcomp}
%\usepackage{framed}
\usepackage{hyperref}
%\usepackage{latexsym}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{newunicodechar}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{placeins} % for \FloatBarrier, we only use it in the appendix
\usepackage{cleveref}[2012/02/15]
\crefformat{footnote}{#2\footnotemark[#1]#3}
\usepackage{plstx, listproc}

\input{definitions}

\newcommand{\citet}{\cite} % TODO

\begin{document}

\title{Implicit Dynamic Frames with Recursive Predicates}
\author{Jenna Wise,
	Johannes~Bader,
    Jonathan~Aldrich,
    {\'E}ric~Tanter,
    Joshua Sunshine}
\date{\today}

\maketitle

\nocite{summers2013formal}
%\section{Recursive Abstract Predicates}
%
%Introduced to solve the problem of a specification needing to access a ``statically-unbounded" number of heap locations when describing the manipulation of a recursively-defined data structure \cite{summers2013formal}.
%
%There are two different treatments of recursive abstract predicates: equi-recursive and iso-recursive as described in Sections \ref{sec:equi-preds} and \ref{sec:iso-preds}.
%
%\subsection{Equi-recursive predicates} \label{sec:equi-preds}
%
%\todo{Brief explanation of equi-recursive predicates}
%
%\subsubsection{Why Equi-recursive semantics for dynamic verification in the gradual setting?} \label{sec:why-equi}
%
%\todo{this section}
%
%\subsection{Iso-recursive predicates} \label{sec:iso-preds}
% \todo{Brief explanation of iso-recursive predicates}
% 
%We choose an isorecursive semantics (similar to the one by Summers and Drossopoulou \cite{summers2013formal}) that treats predicates symbolically and relies on statements \ttt{fold} and \ttt{unfold} to convert between a predicate name and its body. Reasons why we choose an isorecursive semantics are documented in Section \ref{sec:why-iso}.
%
%\subsubsection{Why Iso-recursive predicates for static verification in the gradual setting?} \label{sec:why-iso}
%
%\begin{itemize}
%\item For better modularity we intend that predicate definitions are only visible/observable within the scope of their definition (same class).
%Note that an equirecursive semantics of predicates would expose the internals of a predicate, \eg by probing whether an implication $\phiImplies{\ttt{List(l)}}{\phiCons{\phiCons{\phiAcc{l}{head}}{\phiAcc{l}{head}}}{\ttt{List(l.tail)}}}$ is accepted by the verifier.
%	\begin{itemize}
%	\item Is this a problem if we rely on equirecursive semantics for runtime verification?
%	\end{itemize}
%\item An isorecursive semantics simplifies the treatment of imprecision; for example, in an equirecursive setting a syntactically precise formula referencing a predicate with imprecise body could not be considered precise in the sense that relations like “$\phiImplies{}{}$” cannot deal with them.
%Concretizing a formula would have the obligation to concretize any referenced predicates as well in order to formally establish a bridge with the static semantics of \svlrp.
%\item Lends itself to implementation in static verifiers, since at verification time it is impossible to know when to stop unrolling a recursive definition. Equirecursive semantics provides the undesirable possibility of potentially infinitely applying recursive definitions, in a \textit{matching loop}.
%	\begin{itemize}
%	\item To get implication to go through?
%	\end{itemize}
%\end{itemize}

\section{Examples}

\subsubsection{Fold \& Unfold Specification Problem Example}
\begin{example}\label{ex:fold-unfold-problem}
\hspace{0.5cm}

\begin{lstlisting}[numbers=left,stepnumber=1]
class List {
    int head;
    List tail;

    predicate List(List s) = 
    	    if s == null then true else
    	        acc(s.head) * acc(s.tail) * List(s.tail)

    List insertList(List l, int val)
        requires List(l)
        ensures  List(result)
    {
        
        if (l == null) {
            l = new List;
            l.head = val;
            l.tail = null;
            fold List(l.tail);
            fold List(l);
        } else {
            l = insertListHelper(l, val);
        } 
   
        return l;
    }
    
    List insertListHelper(List l, int val)
        requires List(l) * l != null
        ensures  ? * result != null
    {
        unfold List(l);
        List y = l.tail;
        while (y != null) 
            invariant List(y)
        {
            unfold List(y);
            y = y.tail;
        }
        y = new List;
        y.head = val;
        y.tail = null;
        fold List(y.tail);
        // fold List(l); ?
        
        return l;
    }
\end{lstlisting}
\end{example}

\todo{Show how an equi-recursive dynamic semantics operates on this example} 

%\begin{example}\label{ex:mot}
%    \begin{lstlisting}
%
%// in class Stack
%predicate Stack(Stack s) = if s == null then true else acc(s.head) *
%	acc(s.tail) * Stack(s.tail)
%predicate sorted(Stack s) = if s == null then true else 
%	unfolding Stack(s) in sortedHelper(s.tail, s.head)
%predicate sortedHelper(Stack s, int previous) = 
%	if s == null then true else
%		unfolding Stack(s) in (s.head >= previous) *
%		sortedHelper(s.tail, s.head)
%
%
%predicate sorted(Stack s) = if s == null then true else
%	acc(s.head) * acc(s.tail) * sortedHelper(s.tail, s.head)
%predicate sortedHelper(Stack s, int previous) = 
%	if s == null then true else acc(s.head) * acc(s.tail) *
%		(s.head >= previous) * sortedHelper(s.tail, s.head)
%
%predicate length(Stack s, int length) = if s == null then (length == 0) else
%	acc(s.tail) * length(s.tail, length-1)
%// not very useful without existentials!
%
%// in class List
%    predicate List(List s) = if s == null then true else
%    		acc(s.head) * acc(s.tail) * List(s.tail)
%
%    predicate cyclic(List s) requires List(s) = cyclicHelper(s, s)
%    predicate cyclicHelper(List s, List head) requires List(s) =
%    		unfold List(s) in 
%    			(if s.tail == head then
%    				true else cyclicHelper(s.tail, head))
%
%    predicate sorted(List s) requires List(s) = 
%    		if s == null then true else
%    			unfolding List(s) in sortedHelper(s.tail, s.head)
%    predicate sortedHelper(List s, int previous) requires List(s) =
%    		if s == null then true else
%    			unfolding List(s) in (s.head >= previous) *
%    			sortedHelper(s.tail, s.head)
%
%    predicate sorted(List s) = if s == null then true else
%    		acc(s.head) * acc(s.tail) * sortedHelper(s.tail, s.head)
%    predicate sortedHelper(List s, int previous) = 
%    		if s == null then true else acc(s.head) * acc(s.tail) *
%    			(s.head >= previous) * sortedHelper(s.tail, s.head)
%
%predicate upperBound(List s, int bound) = 
%	if s == null then true else (acc(s.head) * acc(s.tail) *
%		(s.head <= bound) * upperBound(s.tail, bound))
%predicate contains(List s, int element) = 
%	acc(s.head) * (if s.head == element then true else 
%		(acc(s.tail) * contains(s.tail, element)))
%predicate maximum(List s, int max) = upperBound(s, max) /\ contains(s, max)
%// needs regular conjunction
%
%class List {
%	int head;
%	List tail;
%
%    List reverseNegate(List x)
%        requires sorted(x)
%        ensures  sorted(result)
%    {
%        // sorted(x)
%        // { sorted([x]) }
%        List y = null;
%        fold sorted(y);
%        // sorted(x) * sorted(y) * (y == null)
%        // { sorted([x]), sorted([y]) }
%
%        while (x != null) invariant 
%        		sorted(x) * sorted(y) *
%        		(unfolding sorted(x) in unfolding sorted(y) in
%        			(if x == null then true else 
%        				(if y == null then true else
%        					x.head >= -y.head)))
%        {
%            unfold sorted(x);
%            // acc(x.head) * acc(x.tail) *
%            //	sortedHelper(x.tail, x.head) * sorted(y)
%            // { [x].head, [x].tail,
%            // 	sortedHelper([x].tail, [x].head), sorted([y]) }
%            unfold sorted(y);
%            // acc(x.head) * acc(x.tail) *
%            //	sortedHelper(x.tail, x.head) * (if y == null
%            //		then true else acc(y.head) * acc(y.tail) *
%            //			sortedHelper(y.tail, y.head))
%            // { [x].head, [x].tail,
%            //	sortedHelper([x].tail, [x].head), [y] && [y].head,
%            //		[y] && [y].tail, sortedHelper([y].tail, [y].head) }
%            List z := new List; // unfold List(z);
%            // acc(x.head) * acc(x.tail) *
%            //	sortedHelper(x.tail, x.head) * (if y == null
%            //		then true else acc(y.head) * acc(y.tail) *
%            //			sortedHelper(y.tail, y.head)) *
%            //			acc(z.head) * acc(z.tail)
%            // { [z].head, [z].tail, [x].head, [x].tail,
%            //	sortedHelper([x].tail, [x].head), [y] && [y].head, [y] && [y].tail,
%            //		sortedHelper([y].tail, [y].head) }
%            z.head := -x.head;
%            // acc(x.head) * acc(x.tail) * sortedHelper(x.tail, x.head) *
%            // 	(if y == null then true else acc(y.head) * acc(y.tail) *
%            //		sortedHelper(y.tail, y.head)) * acc(z.head) *
%            //		acc(z.tail) * (z.head == -x.head)
%            // { [z].head, [z].tail, [x].head, [x].tail,
%            //	sortedHelper([x].tail, [x].head), [y] && [y].head, [y] &&
%            //	[y].tail, sortedHelper([y].tail, [y].head) }
%            z.tail := y;
%            // acc(x.head) * acc(x.tail) * sortedHelper(x.tail, x.head) *
%            //	(if y == null then true else acc(y.head) * acc(y.tail) *
%            //		sortedHelper(y.tail, y.head)) * acc(z.head) *
%            //		acc(z.tail) * (z.head == -x.head) * (z.tail == y)
%            // { [z].head, [z].tail, [x].head, [x].tail, sortedHelper([x].tail, [x].head), [y] && [y].head, [y] && [y].tail, sortedHelper([y].tail, [y].head) }
%            fold sortedHelper(z.tail, z.head); // if z.tail == null then true else acc(z.tail.head) * acc(z.tail.tail) * (z.tail.head >= z.head) * sortedHelper(z.tail.tail, z.tail.head)
%            // acc(x.head) * acc(x.tail) * sortedHelper(x.tail, x.head) * acc(z.head) * acc(z.tail) * (z.head == -x.head) * (z.tail == y) * sortedHelper(z.tail, z.head)
%            // { [z].head, [z].tail, [x].head, [x].tail, sortedHelper([x].tail, [x].head), sortedHelper([z].tail, [z].head) }
%            y := z;
%            // acc(x.head) * acc(x.tail) * sortedHelper(x.tail, x.head) * acc(y.head) * acc(y.tail) * (y.head == -x.head) * sortedHelper(y.tail, y.head)
%            // { [y].head, [y].tail, [x].head, [x].tail, sortedHelper([x].tail, [x].head), sortedHelper([y].tail, [y].head) }
%            fold sorted(y);
%            // acc(x.head) * acc(x.tail) * sortedHelper(x.tail, x.head) * sorted(y) * unfolding sorted(y) in (y.head == -x.head)
%            // { [x].head, [x].tail, sortedHelper([x].tail, [x].head), sorted([y]) }
%            unfold sortedHelper(x.tail, x.head);
%            // acc(x.head) * acc(x.tail) * (if x.tail == null then true else acc(x.tail.head) * acc(x.tail.tail) * (x.tail.head >= x.head) * sortedHelper(x.tail.tail, x.tail.head)) * sorted(y) * unfolding sorted(y) in (y.head == -x.head)
%            // { [x].head, [x].tail, [x.tail].head, [x.tail].tail, sortedHelper([x.tail].tail, [x.tail].head), sorted([y]) }
%            x := x.tail;
%            // (if x == null then true else acc(x.head) * acc(x.tail) * sortedHelper(x.tail, x.head) * unfolding sorted(y) in (y.head >= -x.head)) * sorted(y)
%            // { [x].head, [x].tail, sortedHelper([x].tail, [x].head), sorted([y]) }
%            fold sorted(x);
%            // sorted(x) * sorted(y) * (if x == null then true else unfolding sorted(y) in unfolding sorted(x) in (y.head >= -x.head))
%            // { sorted([x]), sorted([y]) }
%        }
%
%        return y;
%    }
%
%
%    List reverseNegate(List x)
%        requires sorted(x)
%        ensures  sorted(result)
%    {
%        List y = null;
%        fold sorted(y);
%        while (x != null) invariant sorted(x) * sorted(y) * (unfolding sorted(x) in unfolding sorted(y) in (if x == null then true else (if y == null then true else x.head >= -y.head)))
%        {
%            unfold sorted(x);
%            unfold sorted(y);
%            List z := new List; // unfold List(z);
%            z.head := -x.head;
%            z.tail := y;
%            fold sortedHelper(z.tail, z.head);
%            y := z;
%            fold sorted(y);
%            unfold sortedHelper(x.tail, x.head);
%            x := x.tail;
%            fold sorted(x);
%        }
%
%        return y;
%    }
%}
%
%predicate fullAccess(Stack s) = if s == null then true else acc(s.top) * acc(s.tail) * fullAccess(s.tail)
%
%class Stack {
%    int top;
%    Stack tail;
%
%    void removeAll(int x)
%        require fullAccess(this)
%        ensures fullAccess(this)
%    {
%    }
%
%    Stack push(int x)
%        require fullAccess(this)
%        ensures fullAccess(result) * (result.top = x) * (result.tail = this)
%    {
%        Stack result = new Stack;
%        result.top = x;
%        result.tail = this;
%        return result;
%    }
%}
%    \end{lstlisting}
%    %class Account {
%%    int balance;
%%    void withdraw(int amount)
%%            requires $\ttacc$(this.balance) * (this.balance $\ge$ amount)
%%            ensures  $\ttacc$(this.balance) * (this.balance $\ge$ 0) {
%%        int newBalance $≔$ this.balance - amount;
%%        this.balance $≔$ newBalance;
%%    }
%%}
%%a $≔$ new Account(); a.balance $≔$ 100; a.withdraw(30); a.withdraw(40);
%    % this.balance -= amount;
%\end{example}

\section{\svlrp}
\subsection{Abstract Syntax} \label{svlrp-syntax}
%\subsection{Syntax}
%\begin{figure}
%    \begin{center}
%        \input{figures/svlidf-syntax}
%    \end{center}
%    \caption{\svlidf: Syntax (“...” indicates parts of the syntax that coincide with \svl)}
%    \label{fig:svlidf-syntax}
%\end{figure}
%

\begin{plstx}
*(variables): x,y,z [\in] \mathit{VAR} \\
*(values): v [\in] \mathit{VAL} \\
*(expressions): e [\in] \mathit{EXPR} \\
*(statements): s [\in] \mathit{STMT} \\
*(object Ids): o [\in] \mathit{LOC} \\
*(field names): f [\in] \mathit{FIELDNAME} \\
*(method names): m [\in] \mathit{METHODNAME} \\
*(class names): C [\in] \mathit{CLASSNAME} \\
*(predicate names): p [\in] \mathit{PREDNAME} \\
\end{plstx}

\begin{plstx}
: \mathtt{P} ::= \mathtt{\overline{cls} \ s} \\
: \mathtt{cls} ::= \class{C}{\overline{field}}{\overline{pred}}{ \overline{method}} \\
: \mathtt{field} ::= \mathtt{T ~~ f;} \\
: \mathtt{pred} ::= \ttt{predicate }\pred{p}{\overline{T \ x}}{\sphi} \\
: \mathtt{T} ::= \Tint | C | \top \\
: \mathtt{method} ::= \mathtt{T \ m(\overline{T \ x}) \ contract \ \{s\}} \\
: \mathtt{contract} ::= \contract{\sphi}{\sphi} \\
: \oplus ::= + | - | \ast | \backslash \\
: \odot ::= \neq | = | < | > | \leq | \geq \\
: s ::= \sSkip | \sSeq{s_1}{s_2} | \sDeclare{T}{x} | \sVarAssign{x}{e} | \sIf{e}{s_1}{s_2} | \sWhile{e}{\sphi}{s} | \sFieldAssign{x}{f}{y} | \sAlloc{x}{C} | \sCall{y}{z}{m}{\overline{x}} | \sAssert{\phi} | \sFold{p(\overline{e})} | \sUnfold{p(\overline{e})} \\
: e ::= v | x | e \oplus e | e \odot e | e.f \\
: x ::= \eresult | id | \phiOld{id} | \ethis \\
: v ::= n | o | \enull | \phiTrue | \phiFalse \\
: \phi ::= e | p(\overline{e}) | acc(e.f) | \phi \wedge \phi | \phi \ast \phi | \phiCond{e}{\phi}{\phi} | \unfolding{p(\overline{e})}{\phi}\\
\end{plstx}

\noindent Notes:
\begin{itemize}
\item $\unfolding{p(\overline{e})}{\phi}$ has the same value as $\phi$
	\begin{itemize}
	\item Notice, we include constructs in \svlrp for abstract recursive predicates in iso-recursive style: fold and unfold statements and the unfolding assertion. These are necessary for static verification, but not for proving soundness or dynamic verification. In fact, we employ an equi-recursive style semantics for proving soundness and later for dynamic verification in \gvlrp, because it offers an elegant solution to dropping fold and unfold statements in the gradual setting. Section \ref{sec:svlrp-dynamics} discusses this further.
	%, including the reduction of \svlrp iso-recursive styled assertions and expressions to the equi-recursive setting
	\end{itemize}
\item $\sphi$ is a self-framed formula, in an iso-recursive semantics (cannot determine self-framedness statically using an equi-recursive semantics)
\item We purposely choose to use if conditionals in formulas over logical or to improve both static and dynamic checking with respect to performance
	\begin{itemize}
	\item Logical or on average requires checking at runtime significantly more heap layouts than would be required when using an if conditional in the same fashion, because if conditionals allow us to determine and check the only possible heap layout due to aliasing. Ie. $\left( \phiAcc{y}{f} \ast x = y \vee \phiAcc{x}{f} \ast \phiAcc{y}{f} \right)$ vs. \\ $\phiCond{x=y}{\phiAcc{y}{f}}{\phiAcc{x}{f} \ast \phiAcc{y}{f}}$
	\item Static checking performance with respect to satisfiability can also be similarly improved, because of the if conditional's branches being tied to the boolean expression's truth
	\end{itemize}
\item We also introduce a non-separating conjunction $\wedge$, in particular, to simplify $\WP$ calculations
	\begin{itemize}
	\item This has the benefits of improving the performance of static checking, not reducing the performance of dynamic checking as logical or does, and reducing the intellectual complexity of $\WP$ calculations
	\item Verifiers may choose to hide the non-separating conjunction from users by only using it in $\WP$ calculations and taking steps to hide it in dynamic checking, such as by translating the formula with non-separating conjunctions to a formula without non-separating conjunctions before performing dynamic checking
	\end{itemize}
\end{itemize}

\jw{Should we also allow pure recursive functions in assertions to increase expressiveness of the language?}

\subsection{Static Semantics}
As the focus of this work is not on typing, we assume that any program is well-typed, \eg:

\begin{itemize}
\item arithmetic operators are only used on numeric expressions
\item only boolean expressions appear in formulas (such as in if conditionals in formulas) \& conditional statements, such as the if statement or while statement conditional statements
\item for the sake of modularity, well-formed programs shall only allow folding/unfolding predicates within the scope of their definition.
\item no default value assumed when declaring a variable, or when creating a new object the fields are not assigned a value by default
\end{itemize}

\todo{add other notes about wellformedness as written by Johannes and me previously}
\todo{information about old(id)}
%The method in example \ref{ex:mot} has return type $\Tvoid$ and calls to it do not involve a variable assignment.
%We treat those statements as syntactic sugar for calls with an assignment (to some fresh, unused local variable) while the method returns some arbitrary $\Tint$ value.
%For conciseness, we focus on the simpler call statement $\sCallV{y}{m}{z}$ in this work.\et{which one? where is the full treatment?}\jb{what do you mean with “where is the full treatment”? you mean reference the appendix part about it?}\jb{maybe we should exclusively deal with return-less functions... then there is no syntactic sugar, only one call statement to rule them all}
%\et{if you have the treatment of functions with return values in appendix, then leave it and refer to the appendix for that full treatment. If you don't, then argue that the simplification is "without loss of generality" -- it's a simple transformation "pass a mutable box as argument to each function, and grab its content back on return"---so yes, I'm inclined to get rid of return values altogether...}
%\et{(then, also need to mention that generalizing to multiple arguments is trivial)}
%Similarly, the operation \ttt{x.f -= y} is syntactic sugar for assigning the corresponding subtraction \ttt{x.f - y} to a fresh variable and subsequently storing the result back to \ttt{x.f}.\et{needed?}
%\jb{do you mean is this detailed explanation needed? can we assume the statement is obvious without explanation?}
%\et{if it's only used in the first code snippet, then the simplest I believe is to not use it at all}

\subsection{Dynamic Semantics} \label{sec:svlrp-dynamics}
%We present both an equirecursive dynamic semantics and an isorecursive dynamice semantics, because we intend to use the isorecursive semantics for static verification in \svlrp and \gvlrp, and equirecursive semantics for the dynamic semantics of \svlrp and \gvlrp and for proving soundness of \svlrp and \gvlrp. The presentation of the isorecursive semantics is as much is necessary for supporting and clarifying static verification in Section \ref{sec:svlrp-staticv}.

%\cite{summers2013formal}

%We use an equirecursive semantics for predicates \cite{summers2013formal}.
%Since our gradual semantics relies on potentially evaluating formulas (and hence predicates) at runtime, we require that recursive predicates terminate.
%We assume that the static checker ensures this with some appropriate strategy, \eg by demanding that any recursive predicate must contain at least one (unconditional) accessibility predicate.
%This strategy would ensure that even in presence of an infinite/cyclic data structures, any permission mask must eventually be consumed entirely and thereafter cause the recursion to stop.

%\subsection{Equirecursive Dynamic Semantics} \label{sec:svlrp-equi-dynamics}

\subsubsection{Program States} \label{sec:svlrp-equi-progstates}
Program states consist of a heap and a stack, \ie $\setProgramState = \setHeap \times \setStack$.
A heap $H$ is a partial function from heap locations to a value mapping of object fields, \ie $\setHeap = \setLoc \rightharpoonup (\setFieldName \rightharpoonup \setVal)$.
Stack frames are extended to also track a dynamic footprint,

$\pi \in \setDFootprintEqui = \mathcal{P}(\setLoc \times \setFieldName)$:
\begin{small}
\begin{mathpar}
    S \in \setStack       ::= E \cdot S ~|~ \nil

    \text{where}

    E \in \setStackEntry  = \setVarEnv \times \setDFootprintEqui \times \setStmt
\end{mathpar}
\end{small}
%During execution of an \svl program, expressions and statements operated on and mutated the topmost variable environment $\rho$.
%Now, programs may additionally access the heap as long as the topmost dynamic footprint contains the corresponding fields.
%Thus,
The memory accessible at any point of execution can be viewed as a tuple 

$\setMem = \setHeap \times \setVarEnv \times \setDFootprintEqui$.
%We will need to adjust some definitions from \svl to operate on $\setMem$ instead of $\setVarEnv$
%
%The runtime semantics of \svlidf always consults the footprint before accessing the heap, making sure that only accessible fields are touched.%
%\footnote{In separation logic \cite{reynolds2002separation} one unifies $\setHeap$ and $\setDFootprint$ by actually augmenting and splitting the heap itself instead of tracking permissions and passing around the full heap. We follow the implicit dynamic frames approach here.}

\subsubsection{Evaluation} \label{sec:svlrp-equi-eval}

An expression $e$ is evaluated according to a big-step evaluation relation $\evale{e}{v}$, yielding value $v$ using heap $H$ and local variable environment $\rho$. Variables are looked up in $\rho$, fields are looked up in $H$.

Predicate $\evalphiGen{E}{\cdot}{\cdot} \subseteq \setMem \times \setFormula$ describes the rules for evaluating a formula.

\begin{figure}[ht!]
    \begin{scenter}
        \input{figures/svlrp-sem-dyn-eval-expr}
    \end{scenter}
    \caption{\svlrp: Expression dynamic semantics}
    \label{fig:svlrp-evalexpr}
\end{figure}
\clearpage
\begin{figure}
    \begin{scenter}
        \input{figures/svlrp-sem-dyn-eval-equiform}
    \end{scenter}
    \caption{\svlrp: Formula dynamic semantics}
    \label{fig:svlrp-equi-evalphi}
\end{figure}

\subsubsection{Footprints and framing} \label{sec:svlrp-equi-frm}
\hspace{5cm}

\todo{discuss \setDFootprintIso minimally}

Footprints and framing are defined using the more easily implementable (statically) iso-recursive styled formula evaluation semantics. This differs significantly from the \svlrp's equi-recursive styled formula dynamic semantics on the following rule:

\begin{figure}
        \begin{mathpar}
        \inferrule* [right=EvPred]
		{
			\evalex {H} {\rho} {e_1} {v_1} \\
			...\\
			\evalex {H} {\rho} {e_n} {v_n} \\
			{\langle p, v_1, ..., v_n \rangle} \in {\perm}
		}
		{\evalphiGen {I} {\langle H, \rho, \perm \rangle} { \ttt{$p$($e_1$,$...$,$e_n$)} }}
        \end{mathpar}
    \caption{\svlrp: Iso-recursive styled formula dynamic semantics (select rules)}
    \label{fig:svlrp-equi-evalphi-iso}
\end{figure}

Otherwise, the two evaluation semantics are defined similarly replacing $\pi$ with $\perm$.


The \emph{footprint} of a formula $\phi$, denoted $\dynamicFP{H}{\rho}{\phi}$, is the minimum permission mask $\perm$ required to satisfy $\phi$ given a heap $H$ and variable environment:
\begin{small}
    \begin{mathpar}
        \dynamicFP{H}{\rho}{\phi} = \min ~\{~ \perm \in \setDFootprintIso ~|~ \evalphiGen{I}{\langle H, \rho, \perm \rangle}{\phi} ~\}
    \end{mathpar}
\end{small}

The footprint is defined (\ie there exists a unique minimal set of permission \perm) for formulas satisfiable under $H$ and $\rho$.
It can be implemented by simply evaluating $\phi$ using $H$ and $\rho$, granting and recording precisely the permissions required.

% \jb{might need the Summers definition ([later me]: indeed, and I did)... the above figure does not work well if formula is false under H and rho; we'll say it's not framed, Summers would say it is - don't think either behavior is meaningful, but reiterate; nothing depends on the implementation details of this, so no problem now; note that “being framed” actually means different things depending on whether \perm is augmented on the fly or not}
A formula is said to be \emph{framed} by permissions \perm if it only mentions fields and unfolds predicates in \perm (Fig.~\ref{fig:svlrp-iso-frm}).
%Note how the \tset{FSepOp} rule augments the permissions used to check the right sub-formula, using the footprint of the left sub-formula.
%This means that (accessibility) predicates within a formula are able to frame expressions in the same formula, if mentioned in the right order.
Formula $\phi$ is called \emph{self-framed} (we write $\sfrmphi \phi$) if $\evalphiGen{I}{\langle H, \rho, \perm \rangle}{\phi}$ implies $\sfrmphihrp{I}{\perm} \phi$ (for all $H$, $\rho$, \perm).
We define the set of self-framed formulas $\setFormulaB \defeq \{~ \phi \in \setFormula ~|~ \sfrmphi \phi ~\}$.
For example, ${\phiEq{x.f}{1}}$ is not self-framed while $\phiCons{\phiAcc{x}{f}}{\phiEq{x.f}{1}}$ is.
We write $\sphi$ to denote self-framed formulas.
We require method contracts, loop invariants as well as predicates to use self-framed formulas, as indicated in Section \ref{svlrp-syntax}.

% TODO: we rely on a construct $\unfolding{\ttt{$p$($\overline{e}$)}}{\phi}$ to frame $\phi$ % TODO: ref Summers/Drosso

\begin{figure}[!ht]
    \begin{scenter}
        \input{figures/svlrp-sem-stat-isofrmphi}
    \end{scenter}
    \caption{\svlrp: Framing}
    \label{fig:svlrp-iso-frm}
\end{figure}

%% \et{framing is not our contribution, so we shouldn't spend so much space on it -- try to shorten what follows and remove the "formal example" status it now has (ie. don't use the example environment)}
%\begin{comment}
%The following example illustrates the importance of formulas being self-framed:
%\begin{example}[Self-Framing]\label{sfrm-necessary}
%Consider a verifier that is supposed to verify an assignment $\sFieldAssign{y}{f}{4}$.
%The verifier may be guaranteed that $\phiCons{\phiAcc{y}{f}}{\phiEq{x.f}{1}}$ holds prior to the assignment.
%The assignment may be executed due to the exclusive access to $\ttt{y.f}$, however the verifier may not conclude $\phiCons{\phiAcc{y}{f}}{\phiCons{\phiEq{y.f}{4}}{\phiEq{x.f}{1}}}$.
%This is due to the fact that there is no way of knowing whether \ttt{x} and \ttt{y} alias, i.e. another possible outcome would be $\phiCons{\phiAcc{y}{f}}{\phiCons{\phiEq{y.f}{4}}{\phiEq{x.f}{4}}}$.
%In a concurrent language, neither of both formulas may reflect the truth as another context may own exclusive access to \ttt{x.f} and may thus have modified the value arbitrarily.
%As a consequence, unframed formulas may result in unsound reasoning.
%Intuitively, self-framed formulas are forced to be explicit about potential aliasing of mentioned fields.
%Either \ttt{x} and \ttt{y} alias, expressible as $\phiCons{\phiCons{\phiEq{x}{y}}{\phiAcc{y}{f}}}{\phiEq{y.f}{1}}$ or they do not alias, expressible as $\phiCons{\phiCons{\phiAcc{x}{f}}{\phiAcc{y}{f}}}{\phiEq{x.f}{1}}$.
%\end{example}
%\end{comment}
%
%Formula satisfiability and implication as defined in \svl are lifted from $\setVarEnv$ to $\setMem$ accordingly.
%

\subsection{Reduction Rules}
Figure~\ref{fig:svlrp-dyn-sem} shows the reduction relation of \svlrp.

%We do not restate trivial rules like \tset{SsSeq} or \tset{SsSeqSkip} since they are virtually identical to the ones in \svl, \ie the heap and footprint are irrelevant.
%%The same goes for \tset{SsAssert}, which merely uses the updated formula evaluation predicate.
%
%The field assignment rule \tset{SsFAssign} updates the heap accordingly, provided that the assigned field is accessible.
%A similar check happens when assigning a variable, if the right-hand side expression contains a fields.
%(We use $\accFor{e}$ as syntactic sugar for \ttt{\textbf{acc}($e$)} in case $e$ is a field access and $\phiTrue$ otherwise.)
%Note how \tset{SsCall} now splits footprint \perm into disjoint sets according to the precondition (this is the implicitness about IDF).
%\tset{SsCallFinish} recombines the footprints.

\begin{figure}[!ht]
    \begin{scenter}
    \input{figures/svlrp-sem-dyn-ssequi}
    \end{scenter}
    \caption{\svlrp: Small-step semantics}
    \label{fig:svlrp-dyn-sem}
\end{figure}
\clearpage
%\begin{figure}[!ht]
%    \begin{scenter}
%    \input{figures/svlrp-sem-dyn-ssiso}
%    \end{scenter}
%    \caption{\svlrp: Small-step semantics}
%    \label{fig:svlrp-dyn-sem-iso}
%\end{figure}


\subsubsection{Erasure.} \label{sec:svlrp-erasure}
%We now describe the relationship isorecursive semantics has to the presented equirecursive semantics that allows us to prove soundness of static verification relying on isorecursive definitions using equirecursive semantics.

%\noindent $\erasureForm{\cdot}: \setFormula_I \rightarrow \setFormula_E$
%
%  \begin{scenter}
%        \begin{alignat*}{2}
%        	    & \erasureForm{e}
%            &&= e \\
%            & \erasureForm{\phiAcc{e}{f}}
%            &&= \phiAcc{e}{f}\\
%            & \erasureForm{\phi_1 \wedge \phi_2}
%            &&= \erasureForm{\phi_1} \wedge \erasureForm{\phi_2} \\
%            & \erasureForm{\phi_1 \ast \phi_2}
%            &&= \erasureForm{\phi_1} \ast \erasureForm{\phi_2}\\
%            & \erasureForm{p(e_1,...,e_n)}
%            &&=  p(e_1,...,e_n) \\
%            & \erasureForm{\phiCond{e}{\phi_1}{\phi_2}}
%            &&= \phiCond{e}{\erasureForm{\phi_1}}{\erasureForm{\phi_2}} \\
%            & \erasureForm{\unfolding{p(e_1,..., e_n)}{\phi}}
%            &&=  \erasureForm{\phi} \\
%        \end{alignat*}
%    \end{scenter}

\noindent $\erasurePerm{\cdot}: \setDFootprintIso \times \setHeap \rightharpoonup \setDFootprintEqui$

  \begin{scenter}
        \begin{alignat*}{2}
        	    & \erasurePerm{\perm}
            &&= \{ \langle{o}, {f}\rangle ~\vert~ \langle{o}, {f}\rangle \in \perm \} \cup \erasurePerm{\perm'} \\
            &&& \mathtt{where~} \perm' = \cup_{\langle p, v_1, ... , v_n \rangle \in \perm} \dynamicFP {H} {[]} {\body{p}(v_1, ..., v_n)} \\
        \end{alignat*}
    \end{scenter}

Note, $\erasurePerm{\perm}$ is a partial function, as it may not be well-defined if a predicate instance held in $\perm$ has an infinite unfolding.

%\label{ssec:svlidf-dyn-sem}

%In addition to \svl the semantics is stuck whenever a statement accesses a field that the current context does not have access to.
%For this purpose, the reference runtime tracks the set of accessible fields, called “permission mask”.
%This set is expanded when new objects are created, and is split into disjoint caller- and callee-specific sets when methods are called.
%
%Due to the isorecursive predicate semantics of \svlidf, predicates can encapsulate permissions and must be treated symbolically unless explicitly unfolded.
%Hence, the reference runtime also tracks a set of predicates that are known to hold in the same way it tracks accessible fields.
%The set is expanded when a predicate is folded (assuming that the predicates body was satisfied), reduced when a predicate is unfolded and split for a call depending on the predicates required by the callee's precondition.
%
%We track this information in a single \emph{permission mask} $\perm \in \setDFootprint = \PP((\setLoc \times \setFieldName) \cup (\setPredName \times \setVal^*)) $.
%Note that this combined set is justified since one can even think of $\phiAcc{e}{f}$ as a ghost predicate \ttt{acc(e, \textquotesingle f\textquotesingle)} that cannot be unfolded (and that is a precondition of the field access, thought of as a function).
%\jb{make any connection to ghost state? collapse $\setDFootprint$ to $\PP((\setPredName \cup \{\ttt{acc}\}) \times \setVal^*)$?}
%
%%It is an invariant of \svlidf that the footprints of all stack frames are disjoint, making sure that only one context
%Soundness implies that valid \svlidf programs do not get stuck so \svlidf can be executed by a runtime system that does \emph{not} track \perm.

%\subsubsection{Program States} \label{sec:svlrp-iso-progstates}
%Program states consist of a heap and a stack, \ie $\setProgramState = \setHeap \times \setStack$.
%A heap $H$ is a partial function from heap locations to a value mapping of object fields, \ie $\setHeap = \setLoc \rightharpoonup (\setFieldName \rightharpoonup \setVal)$.
%Stack frames are extended to also track a dynamic footprint,
%
%$\perm \in \setDFootprintIso = \mathcal{P}((\setLoc \times \setFieldName) \cup (\setPredName \times \setVal^*))$:
%\begin{small}
%\begin{mathpar}
%    S \in \setStack       ::= E \cdot S ~|~ \nil
%
%    \text{where}
%
%    E \in \setStackEntry  = \setVarEnv \times \setDFootprintIso \times \setStmt
%\end{mathpar}
%\end{small}
%During execution of an \svl program, expressions and statements operated on and mutated the topmost variable environment $\rho$.
%Now, programs may additionally access the heap as long as the topmost dynamic footprint contains the corresponding fields.
%Thus, 
%The memory accessible at any point of execution can be viewed as a tuple 
%
%$\setMem = \setHeap \times \setVarEnv \times \setDFootprintIso$.
%We will need to adjust some definitions from \svl to operate on $\setMem$ instead of $\setVarEnv$
%
%The runtime semantics of \svlidf always consults the footprint before accessing the heap, making sure that only accessible fields are touched.%
%\footnote{In separation logic \cite{reynolds2002separation} one unifies $\setHeap$ and $\setDFootprint$ by actually augmenting and splitting the heap itself instead of tracking permissions and passing around the full heap. We follow the implicit dynamic frames approach here.}

%\subsubsection{Evaluation} \label{sec:svlrp-iso-eval}
%An expression $e$ is evaluated according to a big-step evaluation relation $\evale{e}{v}$, yielding value $v$ using heap $H$ and local variable environment $\rho$.
%Variables are looked up in $\rho$, fields are looked up in $H$.
%
%Predicate $\evalphiGen{\cdot}{\cdot} \subseteq \setMem \times \setFormula$ describes the rules for evaluating a formula.
%
%\begin{figure}[ht!]
%    \begin{scenter}
%        \input{figures/svlrp-sem-dyn-eval-expr}
%    \end{scenter}
%    \caption{\svlrp: Expression dynamic semantics}
%    \label{fig:svlrp-evalexpr}
%\end{figure}
%
%\begin{figure}[ht!]
%    \begin{scenter}
%        \input{figures/svlrp-sem-dyn-eval-isoform}
%    \end{scenter}
%    \caption{\svlrp: Formula dynamic semantics in isorecursive form}
%    \label{fig:svlrp-iso-evalphi}
%\end{figure}

%\tset{EvAcc} checks whether access demanded by a formula is provided by the dynamic footprint.
%\tset{EvSepOp} implements the separating conjunction, making sure that access to the same field is not granted twice; for instance this ensures that $\phiCons{\phiAcc{x}{f}}{\phiAcc{y}{f}}$ references two distinct fields.
%\tset{EvPred} unfolds a given predicate by resorting to a function $\bodyBare : \setPredName \rightarrow \setExpr^* \rightarrow \setFormulaB$ that looks the predicate up and performs parameter substitution for convenience.
%We assume that $\bodyBare$ is implemented in terms of the ambient program that many relations we defined are implicitly parameterized over.


%\subsubsection{Footprints and framing} \label{sec:svl-iso-frm}
%
%The \emph{footprint} of a formula $\phi$, denoted $\dynamicFP{H}{\rho}{\phi}$, is the minimum permission mask $A$ required to satisfy $\phi$ given a heap $H$ and variable environment:
%\begin{small}
%    \begin{mathpar}
%        \dynamicFP{H}{\rho}{\phi} = \min ~\{~ \perm \in \setDFootprint ~|~ \evalphiGen{\langle H, \rho, \perm \rangle}{\phi} ~\}
%    \end{mathpar}
%\end{small}
%
%The footprint is defined (\ie there exists a unique minimal set of permission \perm) for formulas satisfiable under $H$ and $\rho$.
%It can be implemented by simply evaluating $\phi$ using $H$ and $\rho$, granting and recording precisely the permissions required.
%
%% \jb{might need the Summers definition ([later me]: indeed, and I did)... the above figure does not work well if formula is false under H and rho; we'll say it's not framed, Summers would say it is - don't think either behavior is meaningful, but reiterate; nothing depends on the implementation details of this, so no problem now; note that “being framed” actually means different things depending on whether \perm is augmented on the fly or not}
%A formula is said to be \emph{framed} by permissions \perm if all it only mentions fields and unfolds predicates in \perm (Fig.~\ref{fig:svlidf-frm}).
%%Note how the \tset{FSepOp} rule augments the permissions used to check the right sub-formula, using the footprint of the left sub-formula.
%%This means that (accessibility) predicates within a formula are able to frame expressions in the same formula, if mentioned in the right order.
%%Formulas that are framed by an empty footprint for all $H$ and $\rho$ are called \emph{self-framed}, we simply write $\sfrmphi \phi$.
%Formula $\phi$ is called \emph{self-framed} (we write $\sfrmphi \phi$) if $\evalphiGen{\langle H, \rho, \perm \rangle}{\phi}$ implies $\sfrmphihrp{\perm} \phi$ (for all $H$, $\rho$, \perm).
%We define the set of self-framed formulas $\setFormulaB \defeq \{~ \phi \in \setFormula ~|~ \sfrmphi \phi ~\}$.
%For example, ${\phiEq{x.f}{1}}$ is not self-framed while $\phiCons{\phiAcc{x}{f}}{\phiEq{x.f}{1}}$ is.
%We write $\sphi$ to denote self-framed formulas.
%We require method contracts, loop invariants as well as predicates to use self-framed formulas, as indicated in Figure \ref{fig:svlidf-syntax}.
%
%% TODO: we rely on a construct $\unfolding{\ttt{$p$($\overline{e}$)}}{\phi}$ to frame $\phi$ % TODO: ref Summers/Drosso

%\begin{figure}[!ht]
%    \begin{scenter}
%        \input{figures/svlrp-sem-stat-isofrmphi}
%    \end{scenter}
%    \caption{\svlrp: Framing in isorecursive form}
%    \label{fig:svlrp-iso-frm}
%\end{figure}

%% \et{framing is not our contribution, so we shouldn't spend so much space on it -- try to shorten what follows and remove the "formal example" status it now has (ie. don't use the example environment)}
%\begin{comment}
%The following example illustrates the importance of formulas being self-framed:
%\begin{example}[Self-Framing]\label{sfrm-necessary}
%Consider a verifier that is supposed to verify an assignment $\sFieldAssign{y}{f}{4}$.
%The verifier may be guaranteed that $\phiCons{\phiAcc{y}{f}}{\phiEq{x.f}{1}}$ holds prior to the assignment.
%The assignment may be executed due to the exclusive access to $\ttt{y.f}$, however the verifier may not conclude $\phiCons{\phiAcc{y}{f}}{\phiCons{\phiEq{y.f}{4}}{\phiEq{x.f}{1}}}$.
%This is due to the fact that there is no way of knowing whether \ttt{x} and \ttt{y} alias, i.e. another possible outcome would be $\phiCons{\phiAcc{y}{f}}{\phiCons{\phiEq{y.f}{4}}{\phiEq{x.f}{4}}}$.
%In a concurrent language, neither of both formulas may reflect the truth as another context may own exclusive access to \ttt{x.f} and may thus have modified the value arbitrarily.
%As a consequence, unframed formulas may result in unsound reasoning.
%Intuitively, self-framed formulas are forced to be explicit about potential aliasing of mentioned fields.
%Either \ttt{x} and \ttt{y} alias, expressible as $\phiCons{\phiCons{\phiEq{x}{y}}{\phiAcc{y}{f}}}{\phiEq{y.f}{1}}$ or they do not alias, expressible as $\phiCons{\phiCons{\phiAcc{x}{f}}{\phiAcc{y}{f}}}{\phiEq{x.f}{1}}$.
%\end{example}
%\end{comment}
%
%Formula satisfiability and implication as defined in \svl are lifted from $\setVarEnv$ to $\setMem$ accordingly.
%

\subsection{Static Verification} \label{sec:svlrp-staticv}

\begin{definition}[Denotational Formula Semantics]\label{def:denot-form-sem}~\\
	Let $\envs{\cdot} : \setFormula \rightarrow \PP(\setHeap \times \setVarEnv \times \setDFootprintIso)$ be defined as
	
	$\envs{\phi} \defeq \{~ \langle H, \rho, \perm \rangle \in \setHeap \times \setVarEnv \times \setDFootprintIso ~|~ \evalphiGen{I}{\langle H, \rho, \perm \rangle}{\phi} ~\}$
\end{definition}
\begin{definition}[Formula Satisfiability]\label{def:form-sat}
	A formula $\phi$ is satisfiable if and only if $\envs{\phi} \neq \emptyset$.
	Let $\setFormulaA \subset \setFormula$ be the set of satisfiable formulas.
\end{definition}
\begin{definition}[Formula Implication]\label{def:form-implication}
	$\phiImplies{\phi_1}{\phi_2}$ if and only if $\envs{\phi_1} \subseteq \envs{\phi_2}$
\end{definition}

Definitions \ref{def:denot-form-sem}, \ref{def:form-sat}, and \ref{def:form-implication} all rely on an iso-recursive style formula evaluation semantics, because formula satisfiability and implication must be statically implementable.

\subsubsection{WLP Calculus} \hspace{0.3cm}

\begin{figure}[ht!]
    \begin{scenter}
        \begin{alignat*}{2}
            &\WP(\sVarAssign{x}{e}, \sphi)
            &&= \maximp~ \{~ \sphi' ~|~ \phiImplies{\sphi'}{\sphi[e/x]} ~~~~\wedge~~~~ \phiImplies{\sphi'}{\accFor{e}} ~\}\\
            &\WP(\sWhile{e}{\sphi_i}{s}, \sphi)
            &&= \maximp~ \{~ \sphi' ~|~
            \
            \phiImplies{\sphi'}{\sphi_i}~~~\wedge~~~\phiImplies{\phiCons{\sphi'}{\phiEq{$e$}{\phiFalse}}}{\sphi} ~\}\\
            &\WP(\sFieldAssign{x}{f}{y}, \sphi)
            &&= \phiCons{\phiAcc{x}{f}}{}
            \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\phiCons{\phiAcc{x}{f}}{\phiEq{\edot{x}{f}}{$y$}}}}{\sphi} ~~~~\wedge\\
            &&& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\,\,\,\, \phiCons{\sphi'}{\phiAcc{x}{f}} \in \setFormulaA ~\}\\
            &\WP(\sAlloc{x}{C}, \sphi)
            &&= \maximp~ \{~ \sphi' ~|~  x \not \in\FV(\sphi') ~~~~\wedge\\
            &&& \phiImplies{\sphi'\ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \ast \overline{x.f_i = \defaultValue{$T_i$}} }{\sphi} ~\} \\
            &&& \ttt{where fields(C)} = \overline{T_i \ f_i} \ttt{ and } x \neq e_i \ttt{ is  a conjunctive term in } \sphi\\
            &\WP(\sCall{y}{z}{m}{\overline{x}}, \sphi)
            &&= \maximp~ \{~ \sphi' ~|~
            \
            y \not \in \FV(\sphi')~~~~\wedge\\
            &&&
            \phiImplies{\sphi'}{\phiCons{\phiNeq{$z$}{\enull}}{\mpre{m}[z/\ethis,\overline{x/\mparam{m}}]}}~~~~\wedge\\
            &&&
            \phiImplies{\phiCons{\sphi'}{\mpost{m}[z/\ethis,\overline{x/\phiOld{\mparam{m}}},y/\eresult]}}{\sphi} ~\}\\
            	&\WP(\sAssert{\phi_a}, \sphi)
            &&= \maximp~ \{~ \sphi' ~|~ \phiImplies{\sphi'}{\sphi} ~~~~\wedge~~~~ \phiImplies{\sphi'}{\phi_a} ~\}\\
            &\WP(\sFold {\ttt{$p$($e_1$,$...$,$e_n$)}}, \sphi)
            &&= \phiCons{\body{p}(e_1,...,e_n)}{}
            \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\ttt{$p$($e_1$,$...$,$e_n$)}}}{\sphi} ~~~~\wedge\\
            &&& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\,\,\,\, \phiCons{\sphi'}{\ttt{$p$($e_1$,$...$,$e_n$)}} \in \setFormulaA ~\}\\
            &\WP(\sUnfold {\ttt{$p$($e_1$,$...$,$e_n$)}}, \sphi)
            &&= \phiCons{\ttt{$p$($e_1$,$...$,$e_n$)}}{}
            \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\body{p}(e_1,...,e_n)}}{\sphi} ~~~~\wedge\\
            &&& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\,\,\,\, \phiCons{\sphi'}{\body{p}(e_1,...,e_n)} \in \setFormulaA ~\}\\
        \end{alignat*}
    \end{scenter}
    \caption{\svlrp: Weakest liberal precondition calculus (selected rules), see Fig. \ref{fig:svlrp-wlp-algo} for missing rules}
    \label{fig:svlrp-wlp-selected}
\end{figure}

$\accFor{e} : \setExpr \rightarrow \setFormula$ and is defined in the following way:
 
  \begin{scenter}
        \begin{alignat*}{2}
        	    & \accFor{v}
            &&= \phiTrue \\
            & \accFor{x}
            &&= \phiTrue \\
            & \accFor{e_1 \odot e_2}
            &&= \accFor{e_1} \wedge \accFor{e_2} \\
            & \accFor{e_1 \oplus e_2}
            &&= \accFor{e_1} \wedge \accFor{e_2} \\
            & \accFor{e.f}
            &&= \phiAcc{e}{f}
        \end{alignat*}
    \end{scenter}
\clearpage
\subsubsection{WLP Implementable Calculus} \hspace{0.3cm}

\todo{in progress...}

\begin{figure}[ht!]
  \begin{scenter}
        \begin{alignat*}{2}
        	    &\WP(\sSkip, \sphi)
            &&= \sphi \\
            &\WP(\sSeq{s_1}{s_2}, \sphi)
            &&= \WP(s_1,\WP(s_2,\sphi)) \\
            &\WP(\sDeclare{T}{x}, \sphi)
            &&= \begin{cases}
				\sphi & \texttt{if } x \not\in \texttt{FV}(\sphi) \\
				\texttt{undefined} & \texttt{otherwise} \\		
            		\end{cases}
            		\\
            &\WP(\sVarAssign{x}{e}, \sphi)
            &&= \overline{\phiAcc{e_i}{f_i} ~\wedge}~ \sphi[e/x]\\
            &&& \mathtt{for~ \langle e_i, f_i \rangle \in InferFieldAcc(e)} \\
            &\WP(\sIf{e}{s_1}{s_2}, \sphi)
            &&= \phiCond{e}{\WP(s_1,\sphi)}{\WP(s_2,\sphi)}\\
            &\WP(\sWhile{e}{\sphi_i}{s}, \sphi)
            &&= \sphi_i\\
            &\WP(\sFieldAssign{x}{f}{y}, \sphi)
            &&= \phiAcc{x}{f} \wedge \sphi[y/x.f] \\
            &\WP(\sAlloc{x}{C}, \sphi)
            &&= 
			\begin{cases}
	 		\mathtt{MinusVar(\sphi,x)} & \mathtt{if \ MinusVar(\sphi,x) \ast x \neq null} \\
	 		& \mathtt{~~~~~\ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \implies \sphi } \\
	 		\mathtt{undefined} & \mathtt{otherwise}
			\end{cases}
			\\
			&&& \mathtt{where~ fields(C) = \overline{T_i \ f_i} ~and~ x \neq e_i ~is ~ a ~ conjunctive ~ term ~ in~ \sphi} \\
            &\WP(\sCall{y}{z}{m}{\overline{x}}, \sphi)
            &&= \\ 
            &\WP(\sAssert{\phi_a}, \sphi)
            &&= \sphi \wedge \overline{\phiAcc{e_i}{f_i} ~\wedge}~ \\
            &&& ~~~~~~~~\overline{\phiCond{e_j}{\overline{\phiAcc{e_k}{f_k} ~\wedge}~}{\overline{\phiAcc{e_l}{f_l} ~\wedge}~} ~\wedge}~ \phi_a \\
            &&& \mathtt{for~ \langle e_i, f_i \rangle \in InferFieldAcc(\phi_a),} \\
            &&& \mathtt{\langle e_j, \{\overline{\langle e, f \rangle}\}_{1_j}, \{\overline{\langle e, f \rangle}\}_{2_j} \rangle \in InferFieldAcc(\phi_a),}  \\ 
            &&& \mathtt{\langle e_k, f_k \rangle \in \{\overline{\langle e, f \rangle}\}_{1_j}, ~and~ \langle e_l, f_l \rangle \in \{\overline{\langle e, f \rangle}\}_{2_j}} \\ 
            &\WP(\sFold {\ttt{$p$($e_1$,$...$,$e_n$)}}, \sphi)
            &&= \\
            &\WP(\sUnfold {\ttt{$p$($e_1$,$...$,$e_n$)}}, \sphi)
            &&=\\
        \end{alignat*}
    \end{scenter}
	\caption{\svlrp: Weakest liberal precondition calculus}
	\label{fig:svlrp-wlp-algo}
\end{figure}

Notes:
\begin{itemize}
\item accessibility predicates should be ordered properly when removing them from InferFieldAcc computation
\end{itemize}

\clearpage 

\subsubsection{Helper Defs for WLP Implementable Calculus} \hspace{0.3cm}

\noindent $\texttt{InferFieldAcc}: \setFormula \rightarrow \mathcal{P}((\setExpr \times \setFieldName) \cup (\setExpr \times \mathcal{P}(\setExpr \times \setFieldName) \times \mathcal{P}(\setExpr \times \setFieldName)))$

  \begin{scenter}
        \begin{alignat*}{2}
        	    & \inferFieldAcc{v}
            &&= \emptyset \\
            & \inferFieldAcc{x}
            &&= \emptyset \\
            & \inferFieldAcc{e_1 \odot e_2}
            &&= \inferFieldAcc{e_1} \cup \inferFieldAcc{e_2} \\
            & \inferFieldAcc{e_1 \oplus e_2}
            &&= \inferFieldAcc{e_1} \cup \inferFieldAcc{e_2} \\
            & \inferFieldAcc{e.f}
            &&= \inferFieldAcc{e} \cup \mathtt{\left\{ \langle e,f \rangle \right\}} \\
            & \inferFieldAcc{\phiAcc{e}{f}}
            &&= \inferFieldAcc{e} \\
            & \inferFieldAcc{\phi_1 \wedge \phi_2}
            &&= \inferFieldAcc{\phi_1} \cup \inferFieldAcc{\phi_2} \\
            & \inferFieldAcc{\phi_1 \ast \phi_2}
            &&= \inferFieldAcc{\phi_1} \cup \inferFieldAcc{\phi_2} \\
            & \inferFieldAcc{p(e_1,...,e_n)}
            &&= \inferFieldAcc{e_1} \cup ... \cup \inferFieldAcc{e_n} \\
            & \inferFieldAcc{\phiCond{e}{\phi_1}{\phi_2}}
            &&= \inferFieldAcc{e} ~\cup \\
            &&& ~~~~~~~~\mathtt{\left\{ \langle e,\inferFieldAcc{\phi_1},\inferFieldAcc{\phi_2} \rangle \right\}} \\
            & \inferFieldAcc{\unfolding{p(e_1,..., e_n)}{\phi}}
            &&= \inferFieldAcc{e_1} \cup ... \cup \inferFieldAcc{e_n} ~\cup \\
            &&& ~~~~~~~~\inferFieldAcc{\phi} \\
        \end{alignat*}
    \end{scenter}


\noindent $\texttt{MinusVar}: \setFormula \times \setVar \rightarrow \setFormula$

\begin{scenter}
        \begin{alignat*}{2}
            & \minusVar{e}{x}
            &&= \begin{cases}
            		\phiTrue & \mathtt{if~ x \in \FV(e)} \\
            		\mathtt{e} & \mathtt{otherwise}
            		\end{cases} \\
            & \minusVar{\phiAcc{e}{f}}{x}
            &&= \begin{cases}
            		\phiTrue & \mathtt{if~ x \in \FV(e)} \\
            		\phiAcc{e}{f} & \mathtt{otherwise}
            		\end{cases} \\
            & \minusVar{\phi_1 \wedge \phi_2}{x}
            &&= \minusVar{\phi_1}{x} \wedge \minusVar{\phi_2}{x} \\
            & \minusVar{\phi_1 \ast \phi_2}{x}
            &&=  \minusVar{\phi_1}{x} \ast \minusVar{\phi_2}{x} \\
            & \minusVar{p(e_1,...,e_n)}{x}
            &&=  \begin{cases}
            		\phiTrue & \mathtt{if~ x \in \FV(e_1) \vee ... \vee x \in \FV(e_n)} \\
            		\mathtt{p(e_1,...,e_n)} & \mathtt{otherwise}
            		\end{cases} \\
            & \minusVar{\phiCond{e}{\phi_1}{\phi_2}}{x}
            &&=  \\
            &&& \hspace{-4.5cm}\begin{cases}
            		\phiTrue & \mathtt{if~ x \in FV(e)} \\
            		\phiCond{e}{\minusVar{\phi_1}{x}}{\minusVar{\phi_2}{x}} & \mathtt{otherwise}
            		\end{cases} \\
            & \minusVar{\unfolding{p(e_1,...,e_n)}{\phi}}{x}
            &&= \\
            &&& \hspace{-4.5cm}\begin{cases}
            		\minusVar{\phi}{x} & \mathtt{if~ x \in \FV(e_1) \vee ... \vee x \in \FV(e_n)} \\
            		\unfolding{\mathtt{p(e_1,...,e_n)}}{\minusVar{\phi}{x}} & \mathtt{otherwise}
            		\end{cases} \\
        \end{alignat*}
    \end{scenter}

[TO WRITE:]
\begin{itemize}
\item FV function to compute the set of free variables in a formula
\item Should define substitution on a formula
\end{itemize}

\begin{definition}[Valid method]\label{def:svlrp-valid-method}
   A method with contract $\contract{\sphi_p}{\sphi_q}$, parameters $\overline{x}$, and body $s$ is considered valid if $\phiImplies{\sphi_p}{\WP(s,\sphi_q)[\overline{x/\phiOld{x}}]}$ holds.
\end{definition}

\begin{definition}[Valid program]\label{def:svlrp-valid-prog}
   A program with entry point statement $s$ is considered valid if $\phiImplies{\phiTrue}{\WP(s,\phiTrue)}$ holds and all methods are valid.
\end{definition}

\subsection{Soundness}
%In addition to not getting stuck, the static semantics of \svlidf also prevent null pointer exceptions.
%This is a result of ensuring that fields are accessible before accessing them and the way we interpret an accessibility predicate at runtime (see the premises of \tset{EvAcc} in Figure~\ref{fig:svlidf-evalphi}).
%
%Progress and preservation are defined just as in \svl.
%The notion of valid program states is adjusted to consider heap and dynamic footprint:

\begin{definition}[Valid state]\label{def:svlrp-valid-conf-equi}
    We call the state $\langle H, \langle \rho_n, \pi_n, s_n \rangle \cdot ... \cdot \langle \rho_1, \pi_1, s_1 \rangle \cdot \nil \rangle \in \setProgramState$ {\em valid} if $\evalphiGen{E}{\langle H, \rho_i, \pi_i \rangle}{\sWP_i(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}$ for all $1 \leq i \leq n$.
\end{definition}

\begin{proposition}[\svlrp Progress]\label{prop:svlrp-progress-equi}
    If $\psi \in \setProgramState$ is a valid state and 
    
\noindent $\psi \not \in \{\langle H, \langle \rho, \pi, skip \rangle \cdot nil \rangle ~\vert~ H \in \setHeap, \rho \in \setVarEnv, \pi \in \setDFootprintEqui\}$ 

\noindent then $\psi \sstepArrow \psi'$ for some $\psi' \in \setProgramState$. 
\end{proposition}

\begin{proposition}[\svlrp Preservation]\label{prop:svlrp-preservation-equi}
    If $\psi$ is a valid state and $\psi \sstepArrow \psi'$ for some $\psi' \in \setProgramState$ then $\psi'$ is a valid state.
\end{proposition}

%\begin{definition}[Valid state]\label{def:svlrp-valid-conf-iso}
%    We call the state $\langle H, \langle \rho_n, \perm_n, s_n \rangle \cdot ... \cdot \langle \rho_1, \perm_1, s_1 \rangle \cdot \nil \rangle \in \setProgramState$ {\em valid} if $\evalphiGen{I}{\langle H, \rho_i, \perm_i \rangle}{\sWP_i(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}$ for all $1 \leq i \leq n$.
%\end{definition}
%
%\begin{proposition}[\svlrp Progress]\label{prop:svlrp-progress-iso}
%    If $\psi \in \setProgramState$ is a valid state and 
%    
%\noindent $\psi \not \in \{\langle H, \langle \rho, \perm, skip \rangle \cdot nil \rangle ~\vert~ H \in \setHeap, \rho \in \setVarEnv, \perm \in \setDFootprintIso\}$ 
%
%\noindent then $\psi \sstepArrow \psi'$ for some $\psi' \in \setProgramState$. 
%\end{proposition}
%
%\begin{proposition}[\svlrp Preservation]\label{prop:svlrp-preservation-iso}
%    If $\psi$ is a valid state and $\psi \sstepArrow \psi'$ for some $\psi' \in \setProgramState$ then $\psi'$ is a valid state.
%\end{proposition}

%Note that heap $H$ is used to check the precondition of all stack frames, \ie there is no more strict isolation between stack frames.

%As a result, defining $\sWP$ analogous to \svl leads to problems:
%Imagine a program state with a lower stack frame $i$ having a $\WP$ of $\phiCons{\phiAcc{x}{f}}{\phiEq{x.f}{3}}$.
%Assume that access to \ttt{x.f} was passed up the call stack (\ie it was demanded by the preconditions of called functions), so currently executing statements can {\em change} the value of \ttt{x.f}.
%As a result, $\evalphiGen{E}{\langle H, \rho_i, \pi_i \rangle}{\sWP_i(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}$ is violated.
%We solve this problem by making sure that the stack frame does {\em not} have a $\WP$ of $\phiCons{\phiAcc{x}{f}}{\phiEq{x.f}{3}}$ if it is currently buried under other stack frames that own \ttt{x.f}.
We define $\sWP$ for \svlrp in a similar fashion as in \svl, but with the addition of framing rules as shown in Fig.~\ref{fig:svlrp-wlp-multi}. $\sWP^m$ is equivalent to $\sWP$, except that it weakens the top most formula just enough such that the heap locations it mentions are {\em disjoint} from those acquired by $m$.
Effectively, $\sphi_f$ represents the implicit frame of the executing function, so ownership of all fields mentioned in $\sphi_f$ is withdrawn from the call site.

\begin{figure}
    \begin{scenter}
        \begin{alignat*}{2}
            &\sWP(s \cdot \nil, \sphi)
            = \WP(s, \sphi) \cdot \nil\\
            &\sWP(s \cdot (\sSeq{\sCall{y}{z}{m}{\overline{x}}}{s'}) \cdot \overline{s}, \sphi)
            = \WP(s, \mpost{m}) \cdot \sWP^{\mpre{m}[z/\ethis,\overline{x/\mparam{m}}]}((\sSeq{\sCall{y}{z}{m}{\overline{x}}}{s'}) \cdot \overline{s}, \sphi) \\
            &\sWP(s \cdot (\sSeq{\sWhile{e}{\sphi_i}{r}}{s'}) \cdot \overline{s}, \sphi)
            = \WP(s, \sphi_i) \cdot \sWP^{\sphi_i}((\sSeq{\sWhile{e}{\sphi_i}{r}}{s'}) \cdot \overline{s}, \sphi) \\
            % \quad \text{if $\sWP((\sSeq{\sCall{y}{z}{m}{x}}{s'}) \cdot \overline{s}, \sphi)$ defined}  \\
            % think about stronger thing... could guarantee that method was ever allowed to enter, but don't we need that anyways
            &\text{where}&&\\
            &\sWP^{\sphi_f}(\overline{s}, \sphi)
            = \minimp \{~ \sphi'_n ~|~ \phiImplies{\sphi_n}{\phiCons{\sphi_f}{\sphi'_n}} ~\} \cdot \sphi_{n-1} \cdot ... \cdot \sphi_1 \cdot \nil\\
            &\text{\quad where\quad } \sphi_{n} \cdot \sphi_{n-1} \cdot ... \cdot \sphi_1 \cdot \nil = \sWP(\overline{s}, \sphi)
        \end{alignat*}
    \end{scenter}
    \caption{Heap aware weakest precondition across call boundaries}
    \label{fig:svlrp-wlp-multi}
\end{figure}

\section{\gvlrp}

\subsection{Abstract Syntax}
%\subsection{Syntax}
%\begin{figure}
%    \begin{center}
%        \input{figures/svlidf-syntax}
%    \end{center}
%    \caption{\svlidf: Syntax (“...” indicates parts of the syntax that coincide with \svl)}
%    \label{fig:svlidf-syntax}
%\end{figure}
%

\begin{plstx}
*(variables): x,y,z [\in] \mathit{VAR} \\
*(values): v [\in] \mathit{VAL} \\
*(expressions): e [\in] \mathit{EXPR} \\
*(statements): s [\in] \mathit{STMT} \\
*(object Ids): o [\in] \mathit{LOC} \\
*(field names): f [\in] \mathit{FIELDNAME} \\
*(method names): m [\in] \mathit{METHODNAME} \\
*(class names): C [\in] \mathit{CLASSNAME} \\
*(predicate names): p [\in] \mathit{PREDNAME} \\
\end{plstx}

\begin{plstx}
: \mathtt{P} ::= \mathtt{\overline{cls} \ s} \\
: \mathtt{cls} ::= \class{C}{\overline{field}}{\overline{pred}}{ \overline{method}} \\
: \mathtt{field} ::= \mathtt{T ~~ f;} \\
: \mathtt{pred} ::= \ttt{predicate }\pred{p}{\overline{T \ x}}{\gphi} \\
: \mathtt{T} ::= \Tint | C | \top \\
: \mathtt{method} ::= \mathtt{T \ m(\overline{T \ x}) \ contract \ \{s\}} \\
: \mathtt{contract} ::= \contract{\gphi}{\gphi} \\
: \oplus ::= + | - | \ast | \backslash \\
: \odot ::= \neq | = | < | > | \leq | \geq \\
: s ::= \sSkip | \sSeq{s_1}{s_2} | \sDeclare{T}{x} | \sVarAssign{x}{e} | \sIf{e}{s_1}{s_2} | \sWhile{e}{\gphi}{s} | \sFieldAssign{x}{f}{y} | \sAlloc{x}{C} | \sCall{y}{z}{m}{\overline{x}} | \sAssert{\phi} | \sFold{p(\overline{e})} | \sUnfold{p(\overline{e})} \\
: e ::= v | x | e \oplus e | e \odot e | e.f \\
: x ::= \eresult | id | \phiOld{id} | \ethis \\
: v ::= n | o | \enull | \phiTrue | \phiFalse \\
: \phi ::= e | p(\overline{e}) | acc(e.f) | \phi \wedge \phi | \phi \ast \phi | \phiCond{e}{\phi}{\phi} | \unfolding{p(\overline{e})}{\phi}\\
: \gphi ::= \phi | ? \ast \phi \\
\end{plstx}

\noindent Note:
\begin{itemize}
\item Contracts, predicates, and loop invariants are defined with gradual formulas
\item We do not allow conditionals to contain gradual formulas to simplify the formalisms
\item It does not make sense to allow imprecise formulas in the \textit{in} part of $\unfolding{p(\overline{e})}{\phi}$, because it addresses framing of $\phi$ by ... [FINISH]
\end{itemize}

\jw{$? \ast \phi$ or $? \wedge \phi$ ? Meaning shouldn't change between them.}

\section{\gvlrp: Static Semantics}
\label{sec:gvlrp}
\label{sec:gvlrp-statics}

% \et{insist: the syntax is the same as \gvl, but the meaning is different, because of the desire to support framing with ?. -- you may move that to 6.1, and in your header just give a brief overview of what's coming in this section}
% \jb{is the syntax the same? I mean accessibility is new, self-framing vs. not self-framing (the hat vs no hat is important!), regular vs. separating conjunction, position of the “?”, ... - not sure I understand. Will try to reorg this with a fresh mind, same goes for 6.2, can't figure out the right way to say what I wanna say there :-(}
% \et{right!}

%We define:
%%\begin{align*}
%%    \gphi     & ::= \sphi ~|~ \withqm{\phi_{sat}} \quad\quad\text{where $\phi_{sat} \in \setFormulaA$ and with syntactic sugar } \qm \defeq \withqm{\phiTrue}
%%\end{align*}
%\begin{align*}
%\gphi     & ::= \sphi \\
%		  & ~~~|~~ \withqm{\phi} \quad\quad\text{where $\phi \in \setFormulaA$} \\
%		  & ~~~|~~ \withqmpost{\sphi} \\
%\text{and syntactic sugar } \qm \defeq \withqm{\phiTrue}
%\end{align*}
%
%\jb{consider: another type of ? for ONLY accessibility (nice to encode C0) => may wanna just qualify ?s with an index: a(cc) vs p(ure) vs nothing (full imprecision) and not care about position within formula anymore; also, what about ? in conditionals?}
%
%For maximum expressiveness, we want to enable $\qm$ to {\em provide} framing for a formula that is otherwise not self-framed, \ie $\qm$ may represent accessibility predicates as well.
%For this purpose we introduce the imprecise formula $\withqm{\phi}$ (“\imprA” \jb{???}), writing the $\qm$ first to emphasize that the later part can be framed by it.
%However, it can also be helpful to be imprecise only in the “classical” part of a formula, while being precise about necessary permissions.
%For this purpose we introduce the imprecise formula $\withqmpost{\sphi}$ (“\imprB” \jb{???}).
%This form of imprecision can also enable stronger static reasoning and hence less runtime overhead for keeping track of permissions.
%
%It is worth noting that \imprA is necessary in order to enable gradually decreasing the precision of a program, all the way to having only $\qm$ as annotations:
%If $\qm$ was not able to introduce accessibility predicates, it could not plausibly represent the fully precise annotations of the original program.
%
%Imprecise formulas will be allowed in contracts, loop invariants and predicate definitions. \jb{figure?}
%
%
%\begin{figure}
%
%\newcommand{\tempFrmA}{ e
%    ~|~ p(\overline{\ttt{$e$}})}
%
%\begin{minipage}{.5\linewidth}
%    \small\noindent
%    \begin{align*}
%    pred     & ::= \pred{p}{\overline{\ttt{$T$~$x$}}}{\gphi}                         \\
%    contract & ::= \contract{\gphi}{\gphi}                               \\
%    \phi     & ::= \tempFrmA
%    \end{align*}
%\end{minipage}%
%\begin{minipage}{.5\linewidth}
%    \small\noindent
%    \begin{align*}
%    s        & ::= ... ~|~ \sWhile{e}{\gphi}{s} \\
%    \end{align*}
%    \quad\;\; and $p \in \setPredName$ are predicate names
%
%    \quad\;\; and $\sphi \in \setFormulaB$ are self-framed formulas, as formalized later
%\end{minipage}%
%
%\caption{Syntax adjustments.}
%\label{fig:gvlidf-syntax}
%\end{figure}

\subsection{Interpretation of Gradual Formulas}\label{sec:idf-interpret-grad-frm}

We adjust concretization as defined for \svl to consider self-framed formulas as defined in Section \ref{sec:gvlrp-dyn-fpfrm}:

\begin{definition}[Concretization of gradual formulas]\label{def:idf-concretization}
    $\gamma : \setGFormula \rightharpoonup \PP^{\setFormula}$ is defined as:
    \begin{small}
    \begin{align*}
        & \gamma(\sphi) = \{~ \sphi ~\}                                                                           \\
        & \gamma(\withqm{\phi}) = \{~ \sphi' \in \setFormulaA ~|~ \phiImplies{\sphi'}{\phi} ~\} \text{~~~~if $\phi \in \setFormulaA$}\\
        & \gamma(\withqm{\phi}) \quad \text{undefined otherwise}
    \end{align*}
    \end{small}
\end{definition}

% & \gamma(\withqmpost{\sphi}) = \{~ \sphi' \in \gamma(\withqm{\sphi}) ~|~ \forall H, \rho, \perm.~ \evalphiGen{\langle H, \rho, \perm \rangle}{\sphi'} \implies \dynamicFP{H}{\rho}{\sphi} = \dynamicFP{H}{\rho}{\sphi'}  ~\}

%Similarly, sound reasoning with implicit dynamic frames requires self-framed formulas.
Note, however, that we do not require the static part of $\withqm{\phi}$ to be self-framed.
This is because we want the unknown part of a gradual formula to be able to provide the necessary framing, hence allowing gradual verification regarding heap permissions.
 This allows programmers to resort to gradual formulas when being uncertain or indifferent about the concrete framing of a heap-dependent formula.
% \begin{example}[Imprecise Framing]
%Allowing $\qm$ to provide framing enables the programmer to express $\phiEq{a.name}{b.name}$ irrespective of whether \ttt{a} and \ttt{b} alias or not. The gradual formula $\withqm{\phiEq{a.name}{b.name}}$ captures both scenarios, since the unknown part can either denote the non-aliasing case $\phiCons{\phiAcc{a}{name}}{\phiAcc{b}{name}}$ or the aliasing case $\phiCons{\phiEq{a}{b}}{\phiAcc{b}{name}}$.
%The same would be enabled by introducing a regular conjunction (and writing $\phiAnd{\phiAcc{a}{name}}{\phiAcc{b}{name}}$), but this is a simple example of how imprecision can fill in for missing expressiveness of a logic.
%\end{example}

%\begin{comment}
\subsubsection{Imprecise predicate bodies.}\label{subsec:locality}
While definition \ref{def:idf-concretization} concretizes to syntactically precise formulas, those formulas may still hide imprecision by referencing predicates with imprecise bodies.
We have to extend the concept of concretization to also cover predicates in order for $\gamma$ to be a full bridge between gradual and static verification language.

The fundamental difficulty of \svlrp compared to \svl is the fact that formulas are no longer “\local”, \ie in order to fully interpret them, one requires some additional context $\bodyBare$ (looking up predicates from the ambient program, see \tset{EvPred} in Figure \ref{fig:svlrp-equi-evalphi}).
For concretizing a formula $\phi$ referencing some predicates, it is necessary to \emph{change} this context (\eg replace imprecise predicate bodies with some precise one).
While so far, $\bodyBare$ was the implicit context of all formulas, we will now work with “\local~formulas” $\langle \phi, \bodyBareAny \rangle \in \setFormula \times (\setPredName \rightarrow \setExpr^* \rightarrow \setFormulaB)$ that explicitly drag along their context.
Formulas drawn from the program source (loop invariants, contracts, predicate bodies) are paired with the $\bodyBare$ corresponding to the predicates as they are declared in the source.
Existing rules can easily be adjusted in order to deal with this parametricity, for example:

\begin{mathpar}
	\inferrule* [right=EvSepOp]
	{
		\evalphiGen{E} {\langle H, \rho, {\pi_1} \rangle} {\langle \phi_1, \bodyBareAny \rangle} \\
		\evalphiGen{E} {\langle H, \rho, {\pi_2} \rangle} {\langle \phi_2, \bodyBareAny \rangle}
	}
	{\evalphiGen{E} {\langle H, \rho, (\pi_1 \uplus \pi_2) \rangle} {\langle \phiCons {\phi_1} {\phi_2}, \bodyBareAny \rangle}}

	\inferrule* [right=EvPred]
	{
		\bodyBareAny(p)(e_1, ..., e_n) = \phi \\
		\evalphiGen{E} {\langle H, \rho, \pi \rangle} {\langle \phi, \bodyBareAny \rangle}
	}
	{\evalphiGen{E} {\langle H, \rho, \pi \rangle} { \langle \ttt{$p$($e_1$,$...$,$e_n$)}, \bodyBareAny \rangle }}
\end{mathpar}

As shown in both rules, the context $\bodyBareAny$ is always forwarded unmodified, simply making explicit what was previously assumed as constant and ambient.
\tset{EvPred} uses $\bodyBareAny$ to lookup predicates, rather than using the designated $\bodyBare$.
We can now express concretization that also handles predicates appropriately.

\begin{definition}[Concretization of gradual formulas (continued)]\label{def:idf-concretization-x}
	Concretization of a set of predicates $\gamma : (\setPredName \rightarrow \setExpr^* \rightarrow \setGFormula) \rightharpoonup \PP^{\setPredName \rightarrow \setExpr^* \rightarrow \setFormulaB}$ is defined as:
	\begin{small}
		\begin{align*}
		& \gamma(\grad{\bodyBareAny}) = \{~ \lambda p \in \dom{\grad{\bodyBareAny}}.~\lambda \overline{e} \in \setExpr^*.~\sphi_p[\overline{e}/\overline{\ttt{tmp}}] ~|~ \\
		& \hspace{15em} \langle \sphi_{p_1}, \sphi_{p_2} ... \rangle \in \gamma(\grad{\bodyBareAny}(p_1)(\overline{\ttt{tmp}_1})) \times \gamma(\grad{\bodyBareAny}(p_2)(\overline{\ttt{tmp}_2})) \times ... ~\} \\
		%& \gamma(\grad{\bodyBareAny}) = \{~ \lambda p \in \setPredName.~\lambda \overline{e} \in \setExpr^*.~\sphi_p[\overline{\ttt{tmp}}/\overline{e}] ~|~ \langle \sphi_{p_1}, \sphi_{p_2} ... \rangle \in \prod_{p \in \dom{\grad{\bodyBareAny}}} \gamma(\grad{\bodyBareAny}(p_1)(\overline{\ttt{tmp}})) \times \gamma(\grad{\bodyBareAny}(p_2)(\overline{\ttt{tmp}})) \times ... ~\} \\
		& \text{where } \dom{\grad{\bodyBareAny}} = \{~ p_1, p_2, ... ~\} \subseteq \setPredName
		\end{align*}
	\end{small}
	Given this function, we can concretize a formula and its context, yielding a set of truly (syntactically and semantically) precise formulas:
    \begin{small}
		\begin{align*}
		& \gamma(\langle \gphi, \grad{\bodyBareAny} \rangle) = \{~ \langle \sphi, \bodyBareAny \rangle ~|~ \sphi \in \gamma(\gphi), \bodyBareAny \in \gamma(\grad{\bodyBareAny}) ~\}
		\end{align*}
	\end{small}
\end{definition}

As before, the definition of concretization is a direct formalization of the \emph{plausibility interpretation} of gradual verification: A gradual judgment must hold if it is plausible that all involved imprecise formulas can be replaced by a concrete formula that renders the judgment true.
Since formulas may reference imprecise predicates, they must necessarily be treated by $\gamma$ as well.

%Dragging along $\bodyBareAny$ with each formula clutters presentation significantly, so we will omit it from figures where $\bodyBareAny$ plays no significant role (like \tset{EvPred}).
%One could also imagine $\bodyBareAny$ to be carried along within a formula, for instance in the form of anonymous predicates.
%For the sake of compact presentation, will hence assume that $\gamma(\gphi)$ yields fully precise formulas according to the above rules.

%\end{comment}

\begin{comment}
\subsubsection{Conservative approximation.}\label{subsec:approximation}
% imprecise predicates => approximation allowed
As pointed out in the derivation of \gvl (\jb{ref or something}), approximating certain predicates is allowed to some extent.
Given the complexity of the above definition, it is worth investigating  out that concretization not necessarily dictates the \emph{exact} behavior of lifted predicates/functions, but rather yields a lower bound that may be over-approximated.

For instance, concretization \emph{forces} any implementation of consistent implication to consider $\gphiImplies{\withqm{\phiEq{x}{3}}}{\phiCons{\phiEq{x}{3}}{\phiEq{y}{5}}}$ to be true.
A false negative would be a violation of the gradual guarantee since one could reduce the precision of a true judgment and reach the false negative.
However, a judgment that is implausible (according to $\gamma$) may be considered plausible by an implementation, \eg $\gphiImplies{\withqm{\phiCond{\phiEq{a}{b}}{\phiLeq{x}{3}}{\phiLeq{x}{4}}}}{\phiEq{x}{5}}$ is implausible despite the imprecision, but a very naive implementation may not see the contradiction.
A false positive means statically accepting an implausible program, which is not optimal but also not critical since implausible programs are guaranteed to trigger runtime checks (once hitting the implausible code path).
Over-approximation leads to loss of optimality, while under-approximation compromises the correctness of the system.

While it was rather straight forward to implement the reference semantics of \gvl (derived from \svl and $\gamma$), this is significantly harder in \gvlidf due to the semantics of imprecise gradual predicates as formalized in definition \ref{def:idf-concretization-x}.
Reasonable approximations could treat imprecise predicates ad-hoc rather than fully concretizing the program first. The following example explores this idea:
\begin{example}[Ad-hoc predicate concretization]~\\
	Let \ttt{predicate p(x) = ?} be a predicate.
    Assume that due to annotations throughout the program (method contracts, loop invariants, assertions) the static checker needs to check two implications $\gphiImplies{\ttt{p(x)}}{\phiEq{a}{3}}$ and $\gphiImplies{\ttt{p(x)}}{\phiEq{a}{4}}$.
    Note that the right-hand sides are incompatible, \ie there exists no concretization of \ttt{p} that would render both implications true simultaneously.
    However, an implementation of $\gphiImplies{~}{~}$ that is local (\ie not considering all judgments in the program at once) can never draw this connection.
    When looking at each implication, it would find a plausible instantiation of \ttt{p} for the purpose of proving only the judgment at hand.
    So the static verifier succeeds although there exists no concretization of \ttt{p} for which the entire program is valid.

    Since implications involving \emph{recursive} predicates could be challenging to implement, one could approximate $\gphiImplies{~}{~}$ even further by not considering unfolds while concretizing a predicate:
    Let \ttt{predicate r(l) = acc(l.head) * acc(l.tail) * p(l.head) * r(l.tail)} be another predicate.
    Then $\gphiImplies{\ttt{r(l)}}{\withqm{\phiCons{\phiEq{l.head}{5}}{\phiEq{l.tail.tail.tail.head}{1}}}}$ is implausible since no concretization of \ttt{p(x)} can imply both $\phiEq{x}{5}$ and $\phiEq{x}{1}$ at the same time, even though this is required for the implication to hold.
    An implementation of $\gphiImplies{~}{~}$ would have to track and combine assumptions made about \ttt{p} in order to detect inconsistencies.
    Similar to the earlier approximation, one could instead restrict the scope of the implementation to not coordinate concretizations across recursion steps.

    Ultimately, choosing the right degree of approximation is up to the implementation and represents a trade-off between simplicity and optimality.
\end{example}

% Both options are not expressible using the static formula syntax of \svlidf.
% Fortunately, $\qm$ can be used to frame the formula, covering both alternatives:
% \begin{flalign*}
% \phiCons{\phiCons{\phiAcc{a}{name}}{\phiAcc{b}{name}}}{\phiEq{a.name}{b.name}} &, \\
% \phiCons{\phiCons{\phiEq{a}{b}}{\phiAcc{b}{name}}}{\phiEq{b.name}{b.name}}     &  \\
% \in \gamma(\withqm{\phiEq{a.name}{b.name}}) &
% \end{flalign*}
% \end{example}

\end{comment}
\begin{comment}
The notion of footprints is naturally lifted to imprecise formulas by determining the minimum access every concretization has to provide due to being self-framed (see Fig.~\ref{fig:gvlidf-sem-stat-fp}).
\begin{figure}
\begin{scenter}
\input{figures/gvlidf-sem-stat-fp}
\end{scenter}
\caption{\gvlidf: Static Footprint}
\label{fig:gvlidf-sem-stat-fp}
\end{figure}
\end{comment}

\begin{comment}
\subsection{Imprecise Implicit Dynamic Frame}\label{ssec:impr-idf}

\et{this section is too hand-wavy -- what's the technical contribution here?}
\jb{actually, I think I say everything that's worth saying at the locations where I also refed this section... at most, we can steal stuff out of here if necessary}

IDF \cite{smans2009implicit} uses the precondition of a method to determine its frame (implicitly).
Accessibility predicates $\phiAcc{e}{f}$ of the precondition call out the fields for which ownership is transferred from caller to callee.

However, if the precondition is imprecise the frame of the invocation can no longer be derived precisely.
Determining such a precise frame precisely would require further annotations in the source code, either as part of the method declaration or at the call site.
This approach would have two drawbacks:
Apart from gradualizing the method contracts, the syntax of \gvlidf compared to \svlidf would be extended with a new kind of annotations that become necessary in the presence of imprecision.
\jb{violates the static gradual guarantee (reducing precision doesn't keep program verifiable)}
We do not want to rely on additional (explicit) annotations since \et{reformulate: } it would mean giving up a main selling point of IDF.
Furthermore, it would violate our design goal of supporting a smooth transition between \svlidf and \gvlidf.
The underlying syntax of both languages would no longer be compatible save for formulas.

Instead, we will propagate imprecision to dynamic frames.
In the following sections this will be reflected in appropriate conservative approximations regarding the semantics of \gvlidf.
Note that even in the presence of imprecision, we may not give up the guaranteed exclusiveness of access to fields.
\end{comment}

\subsection{Lifting Predicates}\label{ssec:idf-lift-pred}

\begin{lemma}[Consistent Formula Evaluation]\label{lemma:rp-ol-eval-equi}~\\
    Let $~~\evalgphiGen{\cdot}{\cdot}~ \subseteq \setMem \times \setGFormula$ be defined inductively as
    \begin{small}
    \begin{mathpar}
        \inferrule* [right=\gradT EvalGrad]
        {
			\bodyBareAny = \lambda p \in \dom{\grad{\bodyBareAny}}.~\lambda \overline{e} \in \setExpr^*.~\static{\grad{\bodyBareAny}(p)(\overline{e})} \\            
            \evalphiGen{E}{\langle H, \rho, \pi \rangle}{\langle \phi, \bodyBareAny \rangle}\\
            \sfrmphihrp{E}{\pi} \langle \phi, \bodyBareAny \rangle \\
        }
        {
            \evalgphiGen{\langle H, \rho, \pi \rangle}{\langle \withqm{\phi}, \grad{\bodyBareAny} \rangle}
        }
     
        \inferrule* [right=\gradT EvalStatic]
        {
\bodyBareAny = \lambda p \in \dom{\grad{\bodyBareAny}}.~\lambda \overline{e} \in \setExpr^*.~\static{\grad{\bodyBareAny}(p)(\overline{e})} \\            
            \evalphiGen{E}{\langle H, \rho, \pi \rangle}{\langle \sphi, \bodyBareAny \rangle} \\
            \sfrmphihrp{E}{\pi} \langle \sphi, \bodyBareAny \rangle
        }
        {
            \evalgphiGen{\langle H, \rho, \pi \rangle}{\langle \sphi, \grad{\bodyBareAny} \rangle}
        }
    \end{mathpar}
%     \inferrule* [right=\gradT EvalGrad2]
%        {
%            \evalphiGen{E}{m}{\!\!^*\, \sphi}
%        }
%        {
%            \evalgphiGen{m}{\withqmpost{\sphi}}
%        }
    \end{small}
    $~\evalgphiGen{\cdot}{\cdot}~$ is a consistent lifting of $~\evalphiGen{E}{\cdot}{\cdot}~$.
\end{lemma}
Note, since \svlrp's equi-recursive evaluation semantics treats predicate instances as their body, we must carrying around and modify the $\bodyBareAny$ context when performing equi-recursive evaluation in the gradual setting to evaluate imprecise predicate bodies appropriately. This is not necessary for a consistent lifting of an iso-recursive evaluation semantics.
\todo{Talk about why evalstatic requires framing even though formula self-framing}

Additionally, framing is defined equi-recursively. The equi-recursive style framing judgment is defined similarly (replacing \perm with $\pi$ and iso-recursive formula evaluation with equi-recursive formula evaluation) to its iso-recursive counterpart in \svlrp for all rules except \tset{FrmPred} and \tset{FrmUnfolding} (Fig. \ref{fig:gvlrp-equi-frm}).

\begin{figure}[!ht]
    \begin{scenter}
        \begin{mathpar}
        		\inferrule* [right=FrmPred]
    			{
    			\sfrmphihrp{E}{\pi} {e_1} \\
    			... \\
    			\sfrmphihrp{E}{\pi} {e_n} \\
    			\sfrmphihrp{E}{\pi} $\body{p}$(e_1,...,e_n)
    			}
    			{\sfrmphihrp{E}{\pi} p(e_1,...,e_n)}
    			
           \inferrule* [right=FrmUnfolding]
    			{
    			\sfrmphihrp{E}{\pi} {e_1} \\
    			... \\
    			\sfrmphihrp{E}{\pi} {e_n} \\
    			\sfrmphihrp{E}{\pi} \phi
    			}
    			{\sfrmphihrp{E}{\pi} \unfolding{p(e_1,...,e_n)}{\phi}}
        \end{mathpar}
    \end{scenter}
    \caption{\gvlrp: Equi-recursive Framing (selected rules)}
    \label{fig:gvlrp-equi-frm}
\end{figure}

We also adjust the equi-recursive framing judgment to pass around and use a $\bodyBareAny$ context, as described in Sec. \ref{sec:idf-interpret-grad-frm}.
%To demonstrate approximation in practice, we will present both an optimal and an approximated version of consistent formula evaluation.
%
%% In many cases, predicate imprecision actually plays no significant role (in contrast to concretization as in definition \ref{def:idf-concretization-x}).
% One example is consistent formula evaluation, where predicates can be handled \emph{on the fly} rather than requiring any form of upfront concretization.
%The semantics of \imprA require extra care when evaluating formulas:
%\begin{lemma}[Consistent Formula Evaluation]\label{lemma:idf-ol-eval}~\\
%    Let $~~\evalgphiGen{\cdot}{\cdot}~ \subseteq \setMem \times \setGFormula$ be defined inductively as
%    \begin{small}
%    \begin{mathpar}
%        \inferrule* [right=\gradT EvalGrad1]
%        {
%            \evalphiGen{\langle H, \rho, \perm \rangle}{\!\!^*\, \phi}\\
%            \sfrmphihrp{\perm} \phi\\
%        }
%        {
%            \evalgphiGen{\langle H, \rho, \perm \rangle}{\withqm{\phi}}
%        }
%
%
%        \inferrule* [right=\gradT EvalGrad2]
%        {
%            \evalphiGen{m}{\!\!^*\, \sphi}
%        }
%        {
%            \evalgphiGen{m}{\withqmpost{\sphi}}
%        }
%
%        \inferrule* [right=\gradT EvalStatic]
%        {
%            \evalphiGen{m}{\!\!^*\, \sphi}
%        }
%        {
%            \evalgphiGen{m}{\sphi}
%        }
%    \end{mathpar}
%    \end{small}
%    %To deal with imprecise predicates, we define $\evalphiGen{\,}{\!\!^*\,}$ identical to $\evalphiGen{\,}{\,}$ (see Figure \ref{fig:svlidf-evalphi}), only that rule \tset{EvPred} uses $~\evalgphiGen{~}{~}~$ instead of $~\evalphiGen{~}{~}~$ in the premise to evaluate the predicate body.
%
%    $~\evalgphiGen{\cdot}{\cdot}~$ is a consistent lifting of $~\evalphiGen{\cdot}{\cdot}~$.
%\end{lemma}
%The second premise of \tset{\gradT EvalGrad1} ensures that $\phi$ is framed by permissions \perm, which implies that there exists a self-framed concretization that also evaluates under \perm (a minimal such concretization would only add predicates to $\phi$ and thus make no assumptions about $H$ and $\rho$).

\begin{lemma}[Consistent Formula Implication]\label{lemma:gvlrp-imp-iso}~\\
    Let $~~\gphiImplies{\cdot}{\cdot}~ \subseteq \setGFormula \times \setGFormula$ be defined inductively as
    \begin{small}
    \begin{mathpar}
        \inferrule* [right=\gradT ImplStatic]
        {
			\phiImplies{\sphi_1}{\static{\gphi_2}}
        }
        {
            \gphiImplies{\sphi_1}{\gphi_2}
        }
     
        \inferrule* [right=\gradT ImplGrad]
        {
			\sphi \in \setFormulaA \\\\
			\phiImplies{\sphi}{\phi_1} \\
			\phiImplies{\sphi}{\static{\gphi_1}}
        }
        {
            \gphiImplies{\withqm{\phi_1}}{\gphi_2}
        }
    \end{mathpar}
    \end{small}
    $~\gphiImplies{\cdot}{\cdot}~$ is a consistent lifting of $~\phiImplies{\cdot}{\cdot}~$.
\end{lemma}
 In contrast to the definition of consistent formula evaluation (Lemma \ref{lemma:rp-ol-eval-equi}) and concretization in definition \ref{def:idf-concretization-x}, predicate imprecision actually plays no significant role. Instead, predicates are handled \emph{on the fly} rather than requiring any form of upfront concretization.

\subsection{Lifting Functions}

We must have corresponding abstraction functions for our concretization definitions to consistently lift (partial) functions.
\todo{fix definitions to handle argument sets, which contain unsatisfiable formulas - think about wlp def during this}

\begin{definition}[Precision of formulas]\label{def:precision}
    $\gphi_1$ is more precise than $\gphi_2$, written $\gphi_1 \sqsubseteq \gphi_2$ if and only if $\gamma(\gphi_1) \subseteq \gamma(\gphi_2)$
\end{definition}

\begin{definition}[Abstraction of formulas]\label{def:abstraction}
    Let $\alpha : \PP^{\setFormulaA} \rightharpoonup \setGFormula$ be defined as
    $\alpha(\overline{\phi}) = \min\limits_{\mpt}~\{~ \gphi \in \setGFormula ~|~ \overline{\phi} \subseteq \gamma(\gphi) ~\}$
\end{definition}

\begin{definition}[Precision of formulas (continued)]\label{def:precision-x}
    $\langle \gphi_1, \grad{\bodyBareAny_1} \rangle$ is more precise than $\langle \gphi_2, \grad{\bodyBareAny_2} \rangle$, written $\langle \gphi_1, \grad{\bodyBareAny_1} \rangle \sqsubseteq \langle \gphi_2, \grad{\bodyBareAny_2} \rangle$~ if and only if~ 
    
\noindent $\gamma(\langle \gphi_1, \grad{\bodyBareAny_1} \rangle) \subseteq \gamma(\langle \gphi_2, \grad{\bodyBareAny_2} \rangle)$
\end{definition}

\begin{definition}[Abstraction of formulas (continued)]\label{def:abstraction-x}
    Let 

\noindent   $\alpha : \PP^{\setFormulaA ~\times~ (\setPredName \rightarrow \setExpr^* \rightarrow \setFormulaB)} \rightharpoonup \setGFormula ~\times~ (\setPredName \rightarrow \setExpr^* \rightarrow \setGFormula)$ be defined as
    $\alpha(\overline{\langle \phi, \bodyBareAny \rangle}) = \min\limits_{\mpt}~\{~ \langle \gphi, \grad{\bodyBareAny} \rangle ~|~ \overline{\langle \phi, \bodyBareAny \rangle} \subseteq \gamma(\langle \gphi, \grad{\bodyBareAny} \rangle) ~\}$
\end{definition}

\todo{make the above fit \& flow better in this section}

Figure~\ref{fig:gvlrp-wlp} shows how $\WP$ is consistently lifted.
Method calls and while loops reference/contain further formulas to consider.
%Algorithmic definitions for $\gWP$ are significantly more complicated than those for \gvl due to the separating conjunction.
%Some implementation pointers can be found in the supplementary material, furthermore our prototype implementation implements a similar function.

%However, recall that this function is only required by the {\em static} checker and hence not the main focus of our performance efforts.
%The formal definition should allow SMT solvers to check validity of programs.
%Furthermore, it is valid to conservatively approximate $\gWP$ (erring towards imprecision) which may lead to more runtime checks to make up for the loss of precision.
%The worst possible approximation $\gWP(s, \gphi) = \withqm{\WP(s, \phiTrue)}$ (defined for statements $s$ not referencing/containing further imprecise formulas) would result in a fully dynamically verified language.
%Of course, pay-as-you-go overhead is no longer guaranteed with an approximated $\gWP$.

Recall how we adjusted $\sWP$ (Fig.~\ref{fig:svlrp-wlp-multi}) in order for it to be usable for formalizing small step soundness.
Figure~\ref{fig:gvlrp-wlp-multi} shows the corresponding definition for \gvlrp.
Note how \imprA (in a function precondition or loop invariant) makes it impossible to make assumptions about which access is retained at the call site or across the loop. %(see section~\ref{ssec:impr-idf}).
We conservatively approximate the frame by assuming that no permissions remain:
For $\sphi'_n$, an empty footprint is enforced, which due to self-framing of $\sphi'_n$ also prohibits the {\em use} of any fields.%, demonstrated in example \ref{ex:gidf-stackwp}.
\todo{note about footprint splitting and it mirroring the dynamic semantics fp splitting}

%\begin{example}[$\sgWP$ and shared mutable heap]\label{ex:gidf-stackwp}~\\
%	We redefine the precondition of \ttt{withdraw} used in example \ref{ex:idf-stackwp} to be $\withqm{\phiGeq{this.balance}{amount}}$.
%	For the same $\phi = \phiCons{\phiCons{\phiAcc{a}{id}}{\phiAcc{a}{balance}}}{\phiCons{\phiNeq{a.balance}{-1}}{\phiEq{n}{5}}}$ we calculate the following weakest preconditions:
%	\begin{small}
%		\begin{align*}
%			&(1)\quad\quad \sgWP \left (
%			\begin{array}{@{}c@{}}
%				\hspace*{5pt}\ttt{a.withdraw(n)}\hspace*{5pt}%\\
%				%\cdot\\
%				%\nil
%			\end{array}
%			, \phi \right ) =
%			\begin{array}{@{}c@{}}
%				\withqm{\phiCons{\phiGeq{a.balance}{n}}{\phiEq{n}{5}}}\\%\\
%				%\cdot\\
%				%\nil
%			\end{array}\\
%			&(2)\quad\quad \sgWP \left (
%			\begin{array}{@{}c@{}}
%				\mbody{\ttt{withdraw}}\\
%				\cdot\\
%				\ttt{a.withdraw(n)}%\\
%				%\cdot\\
%				%\nil
%			\end{array}
%			, \phi \right ) =
%			\begin{array}{@{}c@{}}
%				\phiCons{\phiAcc{this}{balance}}{\phiGeq{this.balance - amount}{0}}\\
%				\cdot\\
%				\withqm{\phiEq{n}{5}}%\\
%				%\cdot\\
%				%\nil
%			\end{array}\\
%			&(3)\quad\quad \sgWP \left (
%			\begin{array}{@{}c@{}}
%				\hspace*{24.5pt}\sSkip\hspace*{24.5pt}\\
%				\cdot\\
%				\ttt{a.withdraw(n)}%\\
%				%\cdot\\
%				%\nil
%			\end{array}
%			, \phi \right ) =
%			\begin{array}{@{}c@{}}
%				\phiCons{\phiAcc{this}{balance}}{\phiGeq{this.balance}{0}}\\
%				\cdot\\
%				\withqm{\phiEq{n}{5}}%\\
%				%\cdot\\
%				%\nil
%			\end{array}\\
%			&(4)\quad\quad \sgWP \left (
%			\begin{array}{@{}c@{}}
%				\hspace*{25pt}\sSkip\hspace*{25pt}%\\
%				%\cdot\\
%				%\nil
%			\end{array}
%			, \phi \right ) =
%			\begin{array}{@{}c@{}}
%				\phiCons{\phiCons{\phiAcc{a}{id}}{\phiAcc{a}{balance}}}{\phiCons{\phiNeq{a.balance}{-1}}{\phiEq{n}{5}}}%\\
%				%\cdot\\
%				%\nil
%			\end{array}
%		\end{align*}
%	\end{small}
%	During the call, the call site can no longer be certain about having access to $\ttt{a.id}$ since this field may be modified by the callee.
%	The only static knowledge is $\phiEq{n}{5}$, which does not depend on the heap.
%
%	A naive runtime semantics might perform two checks to ensure soundness:
%	First, when transitioning from $(1)$ to $(2)$, ensuring that $\phiCons{\phiAcc{this}{balance}}{\phiGeq{this.balance - amount}{0}}$ (the callee's internal precondition) holds.
%	Second, when transitioning from $(3)$ to $(4)$, ensuring that $\phiCons{\phiCons{\phiAcc{a}{id}}{\phiAcc{a}{balance}}}{\phiCons{\phiNeq{a.balance}{-1}}{\phiEq{n}{5}}}$ holds.
%	The second check should be reduced to $\phiAcc{a}{id}$ ($\phiEq{n}{5}$ is known, the remaining part implied by \ttt{withdraw}'s postcondition).
%	The first check can be skipped since \ttt{withdraw}'s precondition $\withqm{\phiGeq{this.balance}{amount}}$, despite being imprecise, guarantees that the above check succeeds:
%	{\em Every} concretization of the precondition (by definition self-framed, see Def. \ref{def:idf-concretization}) implies the check.
%	If \ttt{withdraw}'s precondition was changed to $\qm$, the check can no longer be dropped or even reduced.
%\end{example}

%We expect the checks predicted in \ref{ex:gidf-stackwp} to be realized in the following runtime semantics.

%\jb{discuss pot. improvements to the cons. approx regarding typing, reachability??? note that that also requires adjusting the “\perm” splitting method of the dyn. semantics}

\begin{figure}[h!]
    \begin{small}
        \begin{align*}
        		&\gWP(\sSeq{s_1}{s_2},\gphi)
            = \gWP(s_1, \gWP(s_2,\gphi)) \\
%
			&\gWP(\sIf{e}{s_1}{s_2},\gphi)
            = \alpha(\{~ \phiCond{e}{\sphi_1}{\sphi_2} \\
            &\hspace*{90pt} ~|~ \sphi_1 \in \gamma(\gWP(s_1,\gphi)), \sphi_2 \in \gamma(\gWP(s_2,\gphi)) ~\}) \\
%
            &\gWP(\sCall{y}{z}{m}{\overline{x}}, \gphi)
            = \alpha(\{~
            \maximp~ \{~ \sphi' ~|~
            y \not \in \FV(\sphi')~~~~\wedge\\
            &\hspace*{131pt}
            \phiImplies{\sphi'}{\phiCons{\phiNeq{$z$}{\enull}}{\sphi_p[z/\ethis,\overline{x/\mparam{m}}]}}~~~~\wedge\\
            &\hspace*{131pt}
            \phiImplies{\phiCons{\sphi'}{\sphi_q[z/\ethis,\overline{x/\phiOld{\mparam{m}}},y/\eresult]}}{\sphi} ~\} \\
            &\hspace*{90pt}~|~ \sphi \in \gamma(\gphi),~ \sphi_p \in \gamma(\mpre{m}),~ \sphi_q \in \gamma(\mpost{m}) ~\}) \\
%
            &\gWP(\sWhile{e}{\gphi_i}{s}, \gphi)
            = \alpha(\{~
            \maximp~ \{~ \sphi' ~|~
            \phiImplies{\sphi'}{\sphi_i}~~~\wedge~~~\phiImplies{\phiCons{\sphi'}{\phiEq{$e$}{\phiFalse}}}{\sphi} ~\} \\
            &\hspace*{90pt}~|~ \sphi \in \gamma(\gphi),~ \sphi_i \in \gamma(\gphi_i) ~\}) \\
%
            &\gWP(\sFold {\ttt{$p$($e_1$,$...$,$e_n$)}},\gphi)
            = \alpha(\{~ \phiCons{\sphi_b}{} \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\ttt{$p$($e_1$,$...$,$e_n$)}}}{\sphi} ~~~~\wedge \\
            &\hspace*{131pt} \phiCons{\sphi'}{\ttt{$p$($e_1$,$...$,$e_n$)}} \in \setFormulaA ~\}\\
            &\hspace*{90pt} ~|~ \sphi \in \gamma(\gphi),~ \sphi_b \in \gamma(\body{p}(e_1,...,e_n)) ~\}) \\
%
			&\gWP(\sUnfold {\ttt{$p$($e_1$,$...$,$e_n$)}},\gphi)
            = \alpha(\{~ \phiCons{\ttt{$p$($e_1$,$...$,$e_n$)}}{} \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\sphi_b}}{\sphi} ~~~~\wedge \\
            &\hspace*{131pt} \phiCons{\sphi'}{\sphi_b} \in \setFormulaA ~\}\\
            &\hspace*{90pt} ~|~ \sphi \in \gamma(\gphi),~ \sphi_b \in \gamma(\body{p}(e_1,...,e_n)) ~\}) \\
%
            &\gWP(s,\gphi)
            = \alpha(\{~ \WP(s,\sphi) ~|~ \sphi \in \gamma(\gphi) ~\}) \quad \text{otherwise}
        \end{align*}
    \end{small}
    \caption{\gvlidf: Weakest preconditions.}
    \label{fig:gvlrp-wlp}
\end{figure}
\clearpage
\begin{figure}[h!]
    \begin{small}
        \begin{alignat*}{2}
            &\sgWP(s \cdot \nil, \gphi)
            &&= \gWP(s, \gphi) \cdot \nil\\
            &\sgWP(s \cdot (\sSeq{\sCall{y}{z}{m}{\overline{x}}}{s'}) \cdot \overline{s}, \gphi)
            &&= \gWP(s, \mpost{m}) ~\cdot \\
            &&& \quad\quad \sgWP^{\mpre{m}[z/\ethis,\overline{x/\mparam{m}}]}((\sSeq{\sCall{y}{z}{m}{\overline{x}}}{s'}) \cdot \overline{s}, \gphi) \\
            &\sgWP(s \cdot (\sSeq{\sWhile{e}{\gphi_i}{r}}{s'}) \cdot \overline{s}, \gphi)
            &&= \gWP(s, \gphi_i) \cdot \sgWP^{\gphi_i}((\sSeq{\sWhile{e}{\gphi_i}{r}}{s'}) \cdot \overline{s}, \gphi)
        \end{alignat*}
        where
        \begin{alignat*}{2}
            &\sgWP^{\gphi_f}(\overline{s}, \gphi)
            &&=
            \begin{cases}
            \quad\,\;\sphi_n \cdot \gphi_{n-1} \cdot ... \cdot \gphi_1 \cdot \nil & \text{if } \gphi_f \text{ and } \gphi_n \text{ top-level precise}\\
            \withqm{\sphi_n} \cdot \gphi_{n-1} \cdot ... \cdot \gphi_1 \cdot \nil & \text{otherwise}\\
            \end{cases}\\
            &&&\text{where } \gphi_{n} \cdot \gphi_{n-1} \cdot ... \cdot \gphi_1 \cdot \nil = \sgWP(\overline{s}, \gphi) \\
            &&&\phantom{\text{where }} \sphi_n =
            \begin{cases}
            \minimp \{~ \sphi'_n ~|~ \phiImplies{\static{\gphi_n}}{\phiCons{\sphi'_n}{\sphi_f}} ~\} & \text{if } \gphi_f \text{ completely precise} \\ 
            %\text{ (precise) or } \gphi_f = \withqmpost{\sphi_f} \text{ (\imprB)}   \\
            \minimp \{~ \sphi'_n ~|~ \phiImplies{\static{\gphi_n}}{\sphi'_n} ~\wedge~ \forall H, \rho. \dynamicFP{H}{\rho}{\sphi'_n} = \emptyset ~\} & \text{otherwise}
            \end{cases}
        \end{alignat*}
        \begin{comment}
        \alpha \\
        \minimp \{~ \sphi'_n ~|~ \phiImplies{\sphi_n}{\phiCons{\sphi_f}{\sphi'_n}} ~\}\\
        \sphi_f \in \gamma(\gphi_f), \sphi_n \in \gamma(\gphi_n)

        % \gphi_n precise
        \alpha \\
        \minimp \{~ \sphi'_n ~|~ \phiImplies{\gphi_n}{\phiCons{\sphi_f}{\sphi'_n}} ~\}\\
        \sphi_f \in \gamma(\gphi_f)\\
            % \staticFP{\gphi_n} = \emptyset
            \gphi_n

            % \gphi_f precise
            \minimp \{~ \sphi'_n ~|~ \phiImplies{\gphi_n}{\phiCons{\gphi_f}{\sphi'_n}} ~\}

            % \gphi_f imprecise
            \withqm{\minimp \{~ \sphi'_n ~|~ \phiImplies{\gphi_n}{\sphi'_n} ~\wedge~ \staticFP{\sphi'_n} = \emptyset ~\}}

        % \gphi_n imprecise
        \withqm{\minimp \{~ \sphi'_n ~|~ \phiImplies{\static{\gphi_n}}{\phiCons{\sphi_f}{\sphi'_n}} ~\}}\\
        \sphi_f \in \gamma(\gphi_f)\\
            % \gphi_f precise
            \withqm{\minimp \{~ \sphi'_n ~|~ \phiImplies{\static{\gphi_n}}{\phiCons{\gphi_f}{\sphi'_n}} ~\}}

            % \gphi_f imprecise
            \withqm{\minimp \{~ \sphi'_n ~|~ \phiImplies{\static{\gphi_n}}{\sphi'_n} ~\wedge~ \staticFP{\sphi'_n} = \emptyset ~\}}
        \end{comment}
    \end{small}
    \caption{Stack aware weakest precondition across call boundaries.}
    \label{fig:gvlrp-wlp-multi}
\end{figure}

\ja{if using $\overline{s}$ notation remove use of \nil}
% \et{seriously missing: a motivating example to illustrate static verification scenarios in \gvlidf --(one ok, one not ok, one ok but need checks) again bridging to the dynamic semantics section}

\begin{definition}[Valid method]\label{def:gvlrp-valid-method}
   A method with contract $\contract{\gphi_p}{\gphi_q}$, parameters $\overline{x}$, and body $s$ is considered valid if $\gphiImplies{\gphi_p}{\gWP(s,\gphi_q)[\overline{x/\phiOld{x}}]}$ holds.
\end{definition}

\begin{definition}[Valid program]\label{def:gvlrp-valid-prog}
   A program with entry point statement $s$ is considered valid if $\gphiImplies{\phiTrue}{\gWP(s,\phiTrue)}$ holds and all methods are valid.
\end{definition}

\section{\gvlrp: Dynamic Semantics} \label{sec:gvlrp-dynamics}

\subsection{Footprints and Framing} \label{sec:gvlrp-dyn-fpfrm}
\todo{make sure these definitions are consistent liftings if they need to be}

\subsubsection{Framing.}
Unlike \gvl, we must redefine framing and self-framing for \gvlrp to handle potential imprecision in predicate definitions. \todo{provide an example of a formula we would like to be self-framing even with imprecise predicate definitions} We define formula framing in \gvlrp ($\sfrmgphihrp{I}{\perm} {\phi}$) in the same way as \svlrp except for the \tset{FrmUnfolding} rule, redefined in Figure \ref{fig:gvlrp-iso-frm}. The difference between the two rules is in the computation $\perm'$ for framing $\phi$. New footprint definitions (defined in this section) are used in this computation. \todo{explain the difference in more detail}
%A formula is said to be \emph{framed} by permissions \perm  if it only mentions fields and unfolds predicates in \perm (Fig.~\ref{fig:gvlrp-iso-frm}). 
A formula $\phi$ is called \emph{self-framed} (we write $\sfrmgphi \phi$) if $\evalphiGen{I}{\langle H, \rho, \perm \rangle}{\phi}$ implies $\sfrmgphihrp{I}{\perm} \phi$ (for all $H$, $\rho$, \perm). We redefine the set of self-framed formulas: $\setFormulaB \defeq \{~ \phi \in \setFormula ~|~ \sfrmgphi \phi ~\}$. We still write $\sphi$ to denote self-framed formulas.

\begin{figure}[!ht]
    \begin{scenter}
        %\input{figures/gvlrp-sem-stat-isofrmphi}
        \begin{mathpar}
           \inferrule* [right=\gradT FrmUnfolding]
    			{
    			\evalphiGen{I}{\langle H, \rho, \perm \rangle} {\ttt{$p$($e_1$,$...$,$e_n$)}} \\
    			\sfrmgphihrp{I}{\perm} {e_1} \\
    			... \\
    			\sfrmgphihrp{I}{\perm} {e_n} \\\\
    			\sfrmgphihrp{I}{\perm'} \phi \\
    			\perm' = \perm \cup \dynamicFP{\totalFP{H}{\rho}{\phi}, H}{\rho} {$\body{p}$		(e_1,...,e_n)}
    			}
    			{\sfrmgphihrp{I}{\perm} \unfolding{p(e_1,...,e_n)}{\phi}}
        \end{mathpar}
    \end{scenter}
    \caption{\gvlrp: Framing (selected rules)}
    \label{fig:gvlrp-iso-frm}
\end{figure}

\subsubsection{Footprints.}
For the new definitions of framing and self-framing, 
%\tset{\gradT SsCall} and the while loop rules,
we extend the notion of footprints to gradual formulas in an iso-recursive setting.
\begin{small}
    \begin{alignat*}{2}
        &\dynamicFP{\perm, H}{\rho}{\sphi} &&= \dynamicFP{H}{\rho}{\sphi}
        \\
        %&\dynamicFP{\perm, H}{\rho}{\withqmpost{\sphi}} &&= \dynamicFP{H}{\rho}{\sphi}
        %\\
        &\dynamicFP{\perm, H}{\rho}{\withqm{\phi}} &&= \perm
    \end{alignat*}
\end{small}

To split footprints in our dynamic semantics rules, we extend the notion of footprints to gradual formulas in an equi-recursive setting. This definition also relies on a definition of erasure that handles potential imprecision in predicate bodies (presented in this section).

\begin{small}
    \begin{alignat*}{2}
        &\dynamicFP{\pi, H}{\rho}{\sphi} &&= \gerasurePerm{\dynamicFP{H}{\rho}{\sphi}}
        \\
        %&\dynamicFP{\perm, H}{\rho}{\withqmpost{\sphi}} &&= \dynamicFP{H}{\rho}{\sphi}
        %\\
        &\dynamicFP{\pi, H}{\rho}{\withqm{\phi}} &&= \pi
    \end{alignat*}
\end{small}

In presence of full imprecision, %(precondition or loop invariant)
we must expect that all available permissions \perm or $\pi$ are represented by the formula and must hence be forwarded.% to the procedure body or loop. We analyze the resulting behavior further using the example of procedure calls, the same line of reasoning applies to while loops.

We also define a function that computes the \emph{total footprint} of a formula, which contains both the explicit and implicit permissions required by the formula.

\noindent $\totalFP{\cdot}{\cdot}{\cdot}: \setFormula \times \setHeap \times \setVarEnv \rightarrow \setDFootprintIso$

  \begin{scenter}
        \begin{alignat*}{2}
        	    & \totalFP{H}{\rho}{v}
            &&= \emptyset \\
            & \totalFP{H}{\rho}{x}
            &&= \emptyset \\
            & \totalFP{H}{\rho}{e_1 \odot e_2}
            &&= \totalFP{H}{\rho}{e_1} \cup \totalFP{H}{\rho}{e_2} \\
            & \totalFP{H}{\rho}{e_1 \oplus e_2}
            &&= \totalFP{H}{\rho}{e_1} \cup \totalFP{H}{\rho}{e_2} \\
            & \totalFP{H}{\rho}{e.f}
            &&= \totalFP{H}{\rho}{e} \cup \{ \langle o,f \rangle \vert \evale {e} {o} \} \\
            & \totalFP{H}{\rho}{\phiAcc{e}{f}}
            &&= \totalFP{H}{\rho}{e.f} \\
            & \totalFP{H}{\rho}{\phi_1 \wedge \phi_2}
            &&= \totalFP{H}{\rho}{\phi_1} \cup \totalFP{H}{\rho}{\phi_2} \\
            & \totalFP{H}{\rho}{\phi_1 \ast \phi_2}
            &&= \totalFP{H}{\rho}{\phi_1} \cup \totalFP{H}{\rho}{\phi_2} \\
            & \totalFP{H}{\rho}{p(e_1,...,e_n)}
            &&= \totalFP{H}{\rho}{e_1} \cup ... \cup \totalFP{H}{\rho}{e_n} ~\cup \\
            &&& ~~~~~\{ \langle p, v_1, ..., v_n \rangle \vert \evale {e_1} {v_1}, ..., \evale {e_n} {v_n} \}\\
            & \totalFP{H}{\rho}{\phiCond{e}{\phi_1}{\phi_2}}
            &&= \begin{cases}
            		 \totalFP{H}{\rho}{\phi_1} & \ttt{if } \evale {e} {\phiTrue} \\
            		 \totalFP{H}{\rho}{\phi_2} & \ttt{if } \evale {e} {\phiFalse} \\
            		 \emptyset & \ttt{otherwise}
            		\end{cases} \\
            & \totalFP{H}{\rho}{\unfolding{p(e_1,..., e_n)}{\phi}}
            &&= \totalFP{H}{\rho}{p(e_1, ..., e_n)} \cup \totalFP{H}{\rho}{\phi} \\
        \end{alignat*}
    \end{scenter} 

\subsubsection{Permissions to Dynamic Footprint.}
\noindent $\gerasurePerm{\cdot}: \setDFootprintIso \times \setDFootprintEqui \times \setHeap \rightharpoonup \setDFootprintEqui$

  \begin{scenter}
        \begin{alignat*}{2}
        	    & \gerasurePerm{\perm}
            &&= \{ \langle{o}, {f}\rangle ~\vert~ \langle{o}, {f}\rangle \in \perm \} \cup \pi' \\
            &  \mathtt{where~} \pi' 
            &&= 
            		\begin{cases}
            		\pi \quad\quad\quad\quad\quad\quad\quad\ttt{if } \exists \langle p, v_1, ..., v_n \rangle \in \perm. \exists \phi \in \setFormula. \body{p}(v_1,...,v_n) = \withqm{\phi}\\
            		\gerasurePerm{\perm'} \quad\quad\quad~\ttt{otherwise} \\
            		\mathtt{~~~~for~} \perm' = \cup_{\langle p, v_1, ... , v_n \rangle \in \perm} \dynamicFP {H} {[]} {\body{p}(v_1, ..., v_n)}
            		\end{cases} \\
        \end{alignat*}
    \end{scenter}

Note, $\gerasurePerm{\perm}$ is a partial function, as it may not be well-defined if a predicate instance held in $\perm$ has an infinite unfolding and no nested imprecise predicate instances.

\subsection{Naive Semantics}
$ \cdot \gsstepArrow \cdot \subseteq \setProgramState \times ( \setProgramState \cup \{ \error \})$

\noindent A trivially correct but expensive strategy of adding runtime assertions to each execution step, checking whether the new state would be valid (preservation), right before actually transitioning into that state (progress).

\begin{small}
    \begin{flalign*}
        &\text{Let } \langle H, \langle \rho_n, \pi_n, s_n \rangle \cdot ... \cdot \langle \rho_1, \pi_1, s_1 \rangle \cdot \nil \rangle, \langle H', \langle \rho_n', \pi_n', s_n' \rangle \cdot ... \cdot \langle \rho_1', \pi_1', s_1' \rangle \cdot \nil \rangle \in \setProgramState
        &\\
        &\text{If } \sstep
        {\langle H, \langle \rho_n, \pi_n, s_n \rangle \cdot ... \cdot \langle \rho_1, \pi_1, s_1 \rangle \cdot \nil \rangle
        }
        {\langle H', \langle \rho_n', \pi_n', s_n' \rangle \cdot ... \cdot \langle \rho_1', \pi_1', s_1' \rangle \cdot \nil \rangle
        } \text{ (Fig. \ref{fig:gvlrp-dyn-ss}) holds, then}\\
        &\gsstep
        {\langle H, \langle \rho_n, \pi_n, s_n \rangle \cdot ... \cdot \langle \rho_1, \pi_1, s_1 \rangle \cdot \nil \rangle}
        {\!\!\!}
        & \\
        & \begin{cases}
            {\langle H', \langle \rho_n', \pi_n', s_n' \rangle \cdot ... \cdot \langle \rho_1', \pi_1', s_1' \rangle \cdot \nil \rangle} & \text{if } \rlap{$(\evalgphiGen{\langle H', \rho_n', \pi_n' \rangle}{\langle \gphi_n, \bodyBare \rangle}) \wedge ... \wedge (\evalgphiGen{\langle H', \rho_1', \pi_1' \rangle}{\langle \gphi_1, \bodyBare \rangle})$} \\
            \quad~~\rlap{$\text{where } \gphi_n \cdot ... \cdot \gphi_1 \cdot \nil = \sgWP(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)$}\\
            \error & \text{otherwise}
        \end{cases}
    \end{flalign*}
\end{small}

\begin{figure}[!ht]
    \begin{scenter}
    \input{figures/gvlrp-sem-dyn-ssequi}
    \end{scenter}
    \caption{\gvlrp: Small-step semantics adjusted from Fig. \ref{fig:svlrp-dyn-sem} for gradual formulas}
    \label{fig:gvlrp-dyn-ss}
\end{figure}
\clearpage

\subsection{Residual Check Semantics}
%Figure~\ref{fig:simpl-red} shows a dynamic semantics using residual checks.
%Note that only the last premise of both \tset{SsCall}, \tset{SsCallFinish}, \tset{SsWhileTrue} and \tset{SsWhileFalse} represents overhead.

% (see section~\ref{ssec:impr-idf}).
%Driven by the dynamic gradual guarantee, we must ensure that introducing imprecision will not introduce a runtime error caused by lack of accessibility.
%Hence, we conservatively pass the entire dynamic footprint \perm of the call site on to the callee.
%This is inherently a superset of the access granted in any precise setting.
%In contrast, the call site has no more access to the heap, which is reflected by the adjusted definition of $\sgWP$ that removes all mentions of the heap from the call site's $\gWP$ (Fig.~\ref{fig:gvlidf-wp-multi}).
%Only when the call finishes, the footprint is merged back to the call site, restoring its accessibility.
%
%It is worth mentioning that it is still (as in \gvl) sufficient to only inject runtime assertions concerning the top most stack frame.
%Although $\sgWP$ no longer leaves the $\gWP$ of lower stack frames unchanged, it only weakens them (Fig.~\ref{fig:gvlidf-wp-multi}). % therefore not breaking preservation
%The runtime assertion check performed by \tset{\gradT SsCallFinish} (last premise) is derived analogous to the one we derived for \gvl ($|S| + 1$ selects the top most component of the $\sgWP$; $s \cdot ...$ is the stack of statement $s$ and the statements in $S$).

%\begin{figure}
%    \begin{scenter}
%    \begin{mathpar}
%        \inferrule* [right=\gradT SsLocal]
%        {
%            \sstep
%            {\langle H', \langle \rho'_n, \perm'_n, (\sSeq{s}{s_n}) \rangle \cdot ... \rangle}
%            {\langle H, \langle \rho_n, \perm_n, s_n \rangle \cdot ... \rangle} %\\
%            %\evalgphiGen
%            %{\rho_n}
%            %{\gdiff(\sgWP_n(s_n \cdot ..., \phiTrue), \gSP(s, \sgWP_n((\sSeq{s}{s_n}) \cdot ..., \phiTrue)))}
%        }
%        {
%            \gsstep
%            {\langle H', \langle \rho'_n, \perm'_n, (\sSeq{s}{s_n}) \rangle \cdot ... \rangle}
%            {\langle H, \langle \rho_n, \perm_n, s_n \rangle \cdot ... \rangle}
%        }
%
%        \inferrule* [right=\gradT SsCall]
%        {
%            {\predicate{method}(m)} = {
%                \procedure
%                {T_r}
%                {m}
%                {T}
%                {x'}
%                {\contract {\gphi_p} {\gphi_q}}
%                {r}
%            } \\
%            \evalex {H} {\rho} {z} {o} \\
%            \evalex {H} {\rho} {x} {v} \\
%            {\rho'} = {[{\ethis} \mapsto {{o}}, {{x'}} \mapsto {v}]} \\
%            {\perm'} =
%            \text{$\begin{cases} % without this funky nesting, `cases` don't seem to work here :(
%                    \dynamicFP {H} {\rho'} {\gphi_p} & \text{if } \gphi_p \text{ precise}\\
%                    \perm & \text{otherwise}
%            \end{cases}$} \\
%            \evalgphiGen {\langle H, \rho', \perm' \rangle} {\gphi_p}\\
%            \evalgphiGen
%            {\langle H, \rho', \perm' \rangle}
%            {\gdiff(\gWP(r, \gphi_q), \gphi_p)}
%        }
%        {
%            \gsstep
%            {\langle H, {{\langle \rho, \perm, {\sSeq{\sCall{y}{z}{m}{x}}{s}}\rangle} \cdot {S}}\rangle}
%            {\langle H, {{\langle \rho', \perm', {r}\rangle} \cdot {{\langle{{\rho}, {\perm \backslash {\perm'}}}, {\sSeq{\sCall{y}{z}{m}{x}}{s}}\rangle} \cdot {S}}}\rangle}
%        }
%
%        \inferrule* [right=\gradT SsCallFinish]
%        {
%            \mpost{m} = {\gphi_q} \\
%            \evalgphiGen {\langle H, \rho', \perm' \rangle} {\gphi_q} \\
%            {\rho''} = {{\rho}[{y} \mapsto \rho'(\eresult)]} \\
%            \gphi_q' = \gphi_q[z,x,y/\ethis,\phiOld{\mparam{m}},\eresult]\\
%            \gphi_p' = \mpre{m}[z,x/\ethis,\mparam{m}]\\
%            \evalgphiGen
%            {\langle H, \rho'', \perm \cup \perm' \rangle} % TODO: compare with GVL
%            {\gdiff(\gdiff(\sgWP_{|S| + 1}(s \cdot ..., \phiTrue), \gphi_p'), \gphi_q')}
%            %\evalgphiGen
%            %{\langle H, \rho'', {\perm \cup \perm'} \rangle}
%            %{\gdiff(\sgWP_n(s_n \cdot ..., \phiTrue), \gSP(\sCall{y}{z}{m}{x}, \sgWP_n((\sSeq{\sCall{y}{z}{m}{x}}{s_n}) \cdot ..., \phiTrue)))}
%        }
%        {
%            \gsstep
%            {\langle{H}, {{\langle \rho', \perm', \sSkip \rangle} \cdot {{\langle \rho, \perm, {\sSeq{\sCall{y}{z}{m}{x}}{s}} \rangle} \cdot S}}\rangle}
%            {\langle{H}, {{\langle {\rho'', {\perm \cup \perm'}}, {s}\rangle} \cdot {S}}\rangle}
%        }
%
%        \and
%        \inferrule* [right=\gradT SsWhileFalse]
%        {
%            \evalgphiGen {\langle H, \rho, \perm \rangle} {\gphi_i}\\
%            \evalex {H} {\rho} {e} {\phiFalse}\\
%            \evalgphiGen
%            {\langle H, \rho, \perm \rangle}
%            {\gdiff(\sgWP_{|S| + 1}(s \cdot ..., \phiTrue), \phiCons{\gphi_i}{\phiEq{$e$}{\phiFalse}})}
%        }
%        {
%            \gsstep
%            {\langle H, {{\langle \rho, \perm, {\sSeq{\sWhile{e}{\gphi_i}{r}}{s}}\rangle} \cdot {S}}\rangle}
%            {\langle H, {{\langle \rho, \perm, s\rangle} \cdot {S}}\rangle}
%        }
%        \and
%        \inferrule* [right=\gradT SsWhileTrue]
%        {
%            \evalgphiGen {\langle H, \rho, \perm \rangle} {\gphi_i}\\
%            \evalex {H} {\rho} {e} {\phiTrue}\\\\
%            {\rho'} = {[{\ethis} \mapsto {{o}}, {{x'}} \mapsto {v}]} \\
%            {\perm'} =
%            \text{$\begin{cases} % without this funky nesting, `cases` don't seem to work here :(
%                \dynamicFP {H} {\rho} {\gphi_i} & \text{if } \gphi_i \text{ precise}\\
%                \perm & \text{otherwise}
%                \end{cases}$} \\
%            \evalgphiGen
%            {\langle H, \rho, \perm' \rangle}
%            {\gdiff(\gWP(r, \gphi_i), \phiCons{\gphi_i}{\phiEq{$e$}{\phiTrue}})}
%        }
%        {
%            \gsstep
%            {\langle H, {{\langle \rho, \perm, {\sSeq{\sWhile{e}{\sphi_i}{r}}{s}}\rangle} \cdot {S}}\rangle}
%            {\langle H, {{\langle \rho, \perm', r\rangle} \cdot {{\langle{{\rho}, {\perm \backslash {\perm'}}}, {\sSeq{\sWhile{e}{\sphi_i}{r}}{s}}\rangle} \cdot {S}}}\rangle}
%        }
%        \and
%
%        \inferrule* [right=\gradT SsWhileFinish]
%        {
%        }
%        {
%            \gsstep
%            {\langle{H}, {{\langle \rho', \perm', \sSkip \rangle} \cdot {{\langle \rho, \perm, {\sSeq{\sWhile{e}{\sphi_i}{r}}{s}} \rangle} \cdot S}}\rangle}
%            {\langle{H}, {{\langle {\rho', {\perm \cup \perm'}}, {\sSeq{\sWhile{e}{\sphi_i}{r}}{s}}\rangle} \cdot {S}}\rangle}
%        }
%    \end{mathpar}
%    \end{scenter}
%    \caption{Dynamic semantics of \gvlidf with reduced checks.}
%    \label{fig:simpl-red}
%\end{figure}
%
%\subsection{Relying on dynamically tracked permissions}
%As noted in Sect.~\ref{ssec:svlidf-dyn-sem}, an implementation of \svlidf need not actually maintain permissions \perm because verification is entirely static, and sound:
%\perm does not influence calculations but is only ever required for accessibility checks that are guaranteed to succeed due to progress and preservation.
%However, for gradual verification, the reduction rules of Fig.~\ref{fig:simpl-red} rely on a realization of \perm that \emph{can} decide accessibility.
%
%Therefore we use a runtime that tracks the footprint \perm (as modeled) as starting point, giving criteria for simplifying it in the next section.
%The situation is comparable to that of \gvl regarding \ttt{\textbf{old}}:
%An entity of the static verification semantics (but not original runtime semantics) becomes part of the gradual runtime semantics since this semantics now performs verification as well.
%
%\subsection{Tracking Permission Masks}
%\newcommand{\permmax}{\ensuremath{\mathring{\perm}}\xspace}
%A key observation is that precisely-annotated code results in residual
%formulas $\phiTrue$. This not only allows the compiler to drop the corresponding runtime
%checks, but also implies that dynamic footprint \perm will not be required.
%With increasing imprecision, the set of fields that \perm could {\em potentially} be queried for grows.
%
%In the following, we outline a simple data-flow based strategy to determine an upper bound to the set $\permmax$ of (accessibility) predicates that might be queried for.
%In contrast to $\perm \in \setDFootprint$, $\permmax$ tracks predicate arguments syntactically (\setExpr instead of \setVal).
%For every allocation $\sAlloc{x}{C}$, \perm will only be augmented with access to fields of $x$ if they can be found in $\permmax$ (compare with rule \tset{SsAlloc} of Fig.~\ref{fig:svlidf-dyn-sem}, which unconditionally adds all fields).
%Folding/unfolding will behave similarly, \ie only augment/reduce \perm conditionally, otherwise do nothing (note that this decision can be made at compile time).
%As a result, since $\permmax$ is empty in precisely-annotated code, dynamic footprint \perm will remain empty throughout execution.
%
%Note that $\permmax$ may be larger than \perm.
%Specifically, $\permmax$ may be infinite at the call site of a method with precondition $\qm$ that accepts a linked list as parameter, \eg $$\permmax = \{~ \langle \ttt{l}, \ttt{head} \rangle, \langle \ttt{l.tail}, \ttt{head} \rangle, \langle \ttt{l.tail.tail}, \ttt{head} \rangle, ... ~\}$$
%However, this can only affect a finite set of allocations.
%For example, if the statement prior to the call is an allocation $\sAlloc{l}{List}$, then this statement will be tagged to add both $\langle o, \ttt{head} \rangle$ and $\langle o, \ttt{tail} \rangle$ to \perm at runtime (where $o$ is the new heap reference).
%This covers elements $\langle \ttt{l}, \ttt{head} \rangle$ and $\langle \ttt{l.tail}, \ttt{head} \rangle$ of $\permmax$.
%If there's an additional assignment $\sFieldAssign{l}{tail}{l}$ then all of $\permmax$ is covered by the the two elements in \perm due to aliasing.
%
%%Note that an actual implementation does not have to implement \perm as a list.
%%For example, one could use a boolean flag per entry in $\permmax$ (would have to live on the stack) and update these throughout execution, resulting in constant time querying and a predetermined memory layout.
%%We assume that the overhead for realizing \perm is proportional to the size of $\permmax$, upholding the pay-as-you-go runtime cost of imprecision we achieved for \gvl (see \ref{TODO}).
%
%\subsubsection{Determining $\permmax$}
%We informally outline how to iteratively determine $\permmax$ for each location in the program.
%We look at each method in isolation, starting from the last statement of each method and working our way to the front.
%
%If a method $m$'s post condition is precise, we initialize $\permmax = \emptyset$.
%Otherwise, callers of $m$ may query for any access we could possibly return so we initialize $\permmax$ to contain all fields reachable from a call to $m$ that are not statically guaranteed to be accessible.
%For example, for a method with signature $\procedure{\ttt{Point2D}}{m}{\ttt{Point3D}}{\ttt{p}}{\contract{\phiAcc{p}{y}}{\withqm{\phiEq{result.x}{3}}}}{...}$
%we initialize $\permmax = \{~ \langle \ttt{p}, \ttt{x} \rangle, \langle \ttt{p}, \ttt{z} \rangle, \langle \ttt{result}, \ttt{y} \rangle ~\}$ since access to \ttt{p.y} and \ttt{result.x} is statically derivable.
%
%\permmax is propagated upwards from there, undergoing corresponding transformations such as substituting $e$ for $x$ due to assignment $\sVarAssign{x}{e}$.
%Method calls $\sCall{y}{z}{m}{x}$ require further inspection:
%Any (residual) runtime assertion checks encountered augment \permmax by the fields mentioned.
%Furthermore, all mentions of variable $y$ may be removed as accessibility of its field must come from $m$.
%However, if $m$ has an imprecise precondition, \permmax is again augmented by the potentially accessible set of fields that is not statically guaranteed.
%In case of the example signature above, this would be $\{~ \langle \ttt{p}, \ttt{x} \rangle ~\}$.
%
\section{Properties of \gvlrp}
\newcommand{\almosteq}{\lesssim}
\gvlidf is a sound, conservative extension of \svlrp
% and has a pay-as-you-go cost model for runtime checks.

\subsection{Soundness}
\begin{definition}[Valid state]\label{def:gvlrp-valid-conf-equi}
    We call the state $\langle H, \langle \rho_n, \pi_n, s_n \rangle \cdot ... \cdot \langle \rho_1, \pi_1, s_1 \rangle \cdot \nil \rangle \in \setProgramState$ {\em valid} if $\evalgphiGen{\langle H, \rho_i, \pi_i \rangle}{\sgWP_i(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}$ for all $1 \leq i \leq n$.
\end{definition}

\begin{proposition}[\svlrp Progress]\label{prop:gvlrp-progress-equi}
    If $\psi \in \setProgramState$ is a valid state and 
    
\noindent $\psi \not \in \{\langle H, \langle \rho, \pi, skip \rangle \cdot nil \rangle ~\vert~ H \in \setHeap, \rho \in \setVarEnv, \pi \in \setDFootprintEqui\}$ 

\noindent then $\psi ~\gsstepArrow~ \psi'$ for some $\psi' \in \setProgramState$ or $\psi ~\gsstepArrow~ \error$. 
\end{proposition}

\begin{proposition}[\svlrp Preservation]\label{prop:gvlrp-preservation-equi}
    If $\psi$ is a valid state and $\psi ~\gsstepArrow~ \psi'$ for some $\psi' \in \setProgramState$ then $\psi'$ is a valid state.
\end{proposition}

\subsection{Gradual Guarantee}
It satisfies the gradual guarantee, with slight adjustments to both the static and dynamic gradual guarantees.

Due to potentially imprecise predicate definitions and loop invariants, we must adjust \gvl's program precision definition. We say a program $p_1$ is more precise than program $p_2$ ($p_1 \mpt p_2$) if $p_1$ and $p_2$ are equivalent except in terms of contracts, loop invariants, and/or predicate definitions and if $p_1$'s contracts, loop invariants, and predicate definitions are more precise than $p_2$'s corresponding contracts, loop invariants, and predicate definitions.
A contract $\contract{\gphi_p^1}{\gphi_q^1}$ is more precise than contract $\contract{\gphi_p^2}{\gphi_q^2}$ if $\gphi_p^1 \mpt \gphi_p^2$ and $\gphi_q^1 \mpt \gphi_q^2$. Similarly, a loop invariant (predicate definition) $\gphi_i^1$ is more precise than loop invariant (predicate definition) $\gphi_i^2$ if $\gphi_i^1 \mpt \gphi_i^2$. 

The static gradual guarantee can now be stated (as in \gvl) using this new precision definition.

\begin{proposition}[Static gradual guarantee of verification]\label{prop:gvlidf-static-gg}~\\
    Let $p_1, p_2 \in \setProgram$ such that $p_1 \mpt p_2$.
    If $p_1$ is valid then $p_2$ is valid.
\end{proposition}

The fact that footprint tracking and splitting is influenced by increasing imprecision means that we can no longer talk about {\em equal} program states $\psi_1$ and $\psi_2$ as we did in \gvl.
We hence first refine state equality to an asymmetric {\em state precision} relation $\almosteq$:

\begin{definition}[State Precision]\label{def:obs-eq}
    Let $\psi_1, \psi_2 \in \setProgramState$.
    Then $\psi_1$ is more precise than $\psi_2$, written $\psi_1 \almosteq \psi_2$, if and only if all of the following applies:\\
    {\em a)} $\psi_1$ and $\psi_2$ have stacks of size $n$ and identical heaps.\\
    {\em b)} $\psi_1$ and $\psi_2$ have stacks of variable environments and stacks of statements that are identical.\\
    {\em c)} Let $\pi^1_{1..n}$ and $\pi^2_{1..n}$ be the stack of footprints of $\psi_1$ and $\psi_2$, respectively.
    Then the following holds for $1 \le m \le n$:
    $$\bigcup^n_{i = m}{\pi^1_i} \subseteq \bigcup^n_{i = m}{\pi^2_i}$$
\end{definition}

% State precision is aligned with the fact that $\pi_1$ executes in the context of a more precise program than $\pi_2$.

The new dynamic gradual guarantee reflects the fact that imprecision
potentially results in larger parts of footprints being passed up the stack, and \todo{confirm this after finishing residual checks} hence residual checks, which are evaluated against the top most stack frame, are more likely to succeed in the less precise program.
Therefore, Prop. \ref{prop:ggvlidf-dynamic-gg} establishes that successful progress from a state $\psi_1$ for a program $p_1$ also implies successful progress for a less precise state $\psi_2$ and less precise program $p_2$ (using the new program precision definition).

\begin{proposition}[Dynamic gradual guarantee of verification]\label{prop:ggvlidf-dynamic-gg}~\\
	Let $p_1, p_2 \in \setProgram$ such that $p_1 \mpt p_2$,
	and $\psi_1, \psi_2 \in \setProgramState$ such that $\psi_1 \almosteq \psi_2$.

	If $\psi_1\ \gsstepArrow_{p_1}\ \psi'_1$ then
    $\psi_2\ \gsstepArrow_{p_2}\ \psi'_2$, with
    $\psi'_1 \almosteq \psi'_2$.
\end{proposition}


\subsubsection{Additional Program Imprecision}
Our formal system allows additional program imprecision in more specific cases. Fold and unfold statements may be removed from programs that do not rely on them to adhere to the static gradual guarantee (ie. if the programs rely on them for validity). Since \gvlrp's equi-recursive styled dynamic semantics essentially ignores fold and unfold statements, the spirit of the dynamic gradual guarantee is preserved in these cases.
\todo{maybe state variants on the dynamic and static gradual guarantees, which include these cases of imprecision}

%\subsection{Blame Assignment}
%It is worth mentioning how blame assignment works in \gvlidf.
%The language is purely imperative (no function pointers) and strictly evaluated.
%Runtime checks, the only source of runtime errors, check the current program state against an expected formula.
%Technically, one can view runtime checks as checking the implication $\gphiImplies{\phi_{\text{current state}}}{\gphiImplies{\gphi_{\text{statically known}}}{\gphi_{\text{goal}}}}$ for transitivity.
%The first implication plays the role of an upcast that happens continuously as the program executes (whenever annotations abstract away some details).
%The second implication plays the role of the downcast that is guarded by a runtime check and \emph{always to blame} in case of an error.
%
%% relates closely to terms used in minimized runtime checking paragraph of GVL
%
%\clearpage
%
\bibliographystyle{abbrv}
\bibliography{references}

\clearpage
% Appendix
\appendix
\section{Appendix}

\begin{figure}[h!]
    \begin{small}
        \begin{align*}
        		&\gWP(\sSeq{s_1}{s_2},\langle \gphi, \grad{\bodyBareAny} \rangle)
            = \gWP(s_1, \gWP(s_2,\langle \gphi, \grad{\bodyBareAny} \rangle)) \\
%
			&\gWP(\sIf{e}{s_1}{s_2},\langle \gphi, \grad{\bodyBareAny} \rangle)
            = \alpha(\{~ \langle \phiCond{e}{\sphi_1}{\sphi_2}, \bodyBareAny \rangle \\
            &\hspace*{90pt} ~|~ \langle \sphi_1, \bodyBareAny_1 \rangle \in \gamma(\gWP(s_1,\langle \gphi,~ \grad{\bodyBareAny} \rangle)),~ \langle \sphi_2, \bodyBareAny_2 \rangle \in \gamma(\gWP(s_2,\langle \gphi, \grad{\bodyBareAny} \rangle)), \\
            &\hspace*{100pt} \bodyBareAny \in \gamma(\grad{\bodyBareAny}) ~\}) \\
%
			&\gWP(\sCall{y}{z}{m}{\overline{x}}, \langle \gphi, \grad{\bodyBareAny} \rangle)
            = \alpha(\{~
            \langle \maximp~ \{~ \sphi' ~|~
            y \not \in \FV(\sphi')~~~~\wedge\\
            &\hspace*{131pt}
            \phiImplies{\sphi'}{\phiCons{\phiNeq{$z$}{\enull}}{\sphi_p[z/\ethis,\overline{x/\mparam{m}}]}}~~~~\wedge\\
            &\hspace*{131pt}
            \phiImplies{\phiCons{\sphi'}{\sphi_q[z/\ethis,\overline{x/\phiOld{\mparam{m}}},y/\eresult]}}{\sphi} ~\}, \bodyBareAny \rangle \\
            &\hspace*{90pt}~|~ \sphi \in \gamma(\gphi),~ \sphi_p \in \gamma(\mpre{m}),~ \sphi_q \in \gamma(\mpost{m}),~ \bodyBareAny \in \gamma(\grad{\bodyBareAny}) ~\}) \\
%
            &\gWP(\sWhile{e}{\gphi_i}{s}, \langle \gphi, \grad{\bodyBareAny} \rangle)
            = \alpha(\{~
            \langle \maximp~ \{~ \sphi' ~|~
            \phiImplies{\sphi'}{\sphi_i}~~~\wedge~~~\phiImplies{\phiCons{\sphi'}{\phiEq{$e$}{\phiFalse}}}{\sphi} ~\}, \bodyBareAny \rangle \\
            &\hspace*{90pt}~|~ \sphi \in \gamma(\gphi),~ \sphi_i \in \gamma(\gphi_i),~ \bodyBareAny \in \gamma(\grad{\bodyBareAny}) ~\}) \\
%
            &\gWP(\sFold {\ttt{$p$($e_1$,$...$,$e_n$)}},\langle \gphi, \grad{\bodyBareAny} \rangle)
            = \alpha(\{~ \langle \phiCons{\bodyBareAny(p)(e_1,...,e_n)}{} \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\ttt{$p$($e_1$,$...$,$e_n$)}}}{\sphi} ~~~~\wedge \\
            &\hspace*{131pt} \phiCons{\sphi'}{\ttt{$p$($e_1$,$...$,$e_n$)}} \in \setFormulaA ~\}, \bodyBareAny \rangle\\
            &\hspace*{90pt} ~|~ \langle \sphi,\bodyBareAny \rangle \in \gamma(\langle \gphi, \grad{\bodyBareAny} \rangle) ~\}) \\
%
			&\gWP(\sUnfold {\ttt{$p$($e_1$,$...$,$e_n$)}},\langle \gphi, \grad{\bodyBareAny} \rangle)
            = \alpha(\{~ \langle \phiCons{\ttt{$p$($e_1$,$...$,$e_n$)}}{} \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\bodyBareAny(p)(e_1,...,e_n)}}{\sphi} ~~~~\wedge \\
            &\hspace*{131pt} \phiCons{\sphi'}{\bodyBareAny(p)(e_1,...,e_n)} \in \setFormulaA ~\}, \bodyBareAny \rangle \\
            &\hspace*{90pt} ~|~ \langle \sphi,\bodyBareAny \rangle \in \gamma(\langle \gphi, \grad{\bodyBareAny} \rangle) ~\}) \\
%
            &\gWP(s, \langle \gphi, \grad{\bodyBareAny} \rangle)
            = \alpha(\{~ \WP(s, \langle \sphi, \bodyBareAny \rangle) ~|~ \langle \sphi, \bodyBareAny \rangle \in \gamma(\langle \gphi,\grad{\bodyBareAny} \rangle) ~\}) \quad \text{otherwise}
        \end{align*}
    \end{small}
    \caption{\gvlidf: Weakest preconditions alternative, equivalent to Figure \ref{fig:gvlrp-wlp} when \bodyBare~provided as an argument.}
    \label{fig:gvlrp-wlp-alt}
\end{figure}

The $\gWP$ for \textit{if statements} is defined correctly, since Lemma \ref{lemma:gvlrp-wlp-alt-prop} is provable by induction on the syntax of program statements. Lemma \ref{lemma:gvlrp-wlp-defs-equiv} is also provable by induction on the syntax of program statements, leading to an equivalence between definitions in Figures \ref{fig:gvlrp-wlp} and \ref{fig:gvlrp-wlp-alt}.

\begin{lemma}[$\gWP$ (Fig. \ref{fig:gvlrp-wlp-alt}) preserves $\grad{\bodyBareAny}$]\label{lemma:gvlrp-wlp-alt-prop}~\\
Let $s \in \setStmt$, $\langle \gphi, \grad{\bodyBareAny} \rangle \in \setGFormula \times (\setPredName \rightarrow \setExpr^* \rightarrow \setGFormula)$, \\

\noindent then $\gWP(s, \langle \gphi, \grad{\bodyBareAny} \rangle) = \langle \gphi', \grad{\bodyBareAny} \rangle$ for some $\gphi' \in \setGFormula$.
\end{lemma}
\todo{proof}

\begin{lemma}[$\gWP$ equivalent definitions]\label{lemma:gvlrp-wlp-defs-equiv}~\\
Let $s \in \setStmt$, $\gphi \in \setGFormula$, \\

\noindent then $\langle \gWP(s, \gphi), \bodyBare \rangle = \gWP(s, \langle \gphi, \bodyBare \rangle)$.
\end{lemma}
\todo{proof}

%\begin{comment}
%\subsection{Dynamic Semantics using AGT}
%We have used the methodologies of Abstracting Gradual Typing \cite{garcia2016abstracting}, specifically abstract interpretation, to derive the static semantics of \gvl and \gvlidf, respectively.
%However, for the dynamic semantics we have deviated from the approach proposed by Garcia \etal.
%In this section, we introduce their syntax-directed approach and apply it to (parts of) \svl/\gvl.
%It will become apparent that the approach, designed for type systems, is unnecessarily abstract and complicated for our purposes.
%We show that the approaches are ultimately equivalent and discuss which approach is preferable when and why.
%
%\subsubsection{Dynamic Semantics using Consistent Judgments}\label{sec:ds-using-cons-judgj}
%Statically accepting a gradually verified program is based on consistent judgments.
%Consider the following program:
%\begin{lstlisting}
%int withdraw(int b, int a) requires ? ensures result $\ge$ 0
%{ return b - a; }
%...
%int b $≔$ 20; int a $≔$ 30; b $≔$ withdraw(b, a);
%\end{lstlisting}
%The method is statically accepted due to $\gphiImplies{\qm}{\phiGeq{b - a}{0}}$ \ie the method's precondition implies the $\gWP$ of the method body.
%At runtime, right before making the call, the program state is described by $\phiAnd{phiEq{b}{20}}{\phiEq{a}{30}}$ which does not yet uncover a contract violation either: $\gphiImplies{\phiAnd{phiEq{b}{20}}{\phiEq{a}{30}}}{\qm[\ttt{b}, \ttt{a}/\ttt{b}, \ttt{a}]}$ (in the following, we omit the substitution)
%Only when entering the method, a violation becomes apparent: $\gphiImplies{\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}}{\phiGeq{b - a}{0}}$ does not hold, where $\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}$ describes the first program state {\em after} entering the method.
%That the consistent judgment does not hold must lead to a runtime error.
%
%Note that despite formula implication $\phiImplies{}{}$ (Def.~\ref{def:form-implication}) is transitive, consistent implication is not: While $\gphiImplies{\phiAnd{phiEq{b}{20}}{\phiEq{a}{30}}}{\qm}$ and $\gphiImplies{\qm}{\phiGeq{b - a}{0}}$ hold, the transitive judgment $\gphiImplies{\phiAnd{phiEq{b}{20}}{\phiEq{a}{30}}}{\phiGeq{b - a}{0}}$ does not.
%
%We have characterized the dynamic semantics of \gvl in terms of consistent implication instead of the evaluation judgment $\evalgphiGen{}{}$.
%This syntax-directed approach allows basing not only the semantics but also the soundness of \gvl on consistent implication.
%As a program reduces, the progress and preservation arguments require combining consistent implication judgments transitively.
%In the following, we formalize this approach.
%
%\subsubsection{Program States as Formulas}\label{sec:state-as-fomula}
%For any variable environment $\rho$ there exists a minimal (w.r.t. $\phiImplies{}{}$) formula $\phi_{\rho}$ describing $\rho$.
%This $\phi_{\rho}$ arises from $\rho$ by encoding all variable values as equalities.
%For example $\rho = [\ttt{x} \mapsto 3, \ttt{y} \mapsto 5]$ yields $\phi_{\rho} = \phiAnd{\phiEq{x}{3}}{\phiEq{y}{5}}$.
%Note that this construction of $\phi_{\rho}$ yields a minimal (w.r.t $\phiImplies{}{}$) formula \ie any formula that implies $\phi_{\rho}$ must either be equivalent to $\phi_{\rho}$ or it must contradict $\rho$ since it contains additional information.
%
%\begin{lemma}[Syntactic equivalence of formula evaluation]\label{lemma:rho-syntax-semantics}~\\
%    Let $\rho \in \setVarEnv$ and $\phi \in \setFormula$.
%    Then $(\evalphiGen{\rho}{\phi}) \iff (\phiImplies{\phi_{\rho}}{\phi})$ where
%    $\phi_{\rho} = \minimp \{~ \phi ~|~ \evalphiGen{\rho}{\phi} ~\}$.
%    Likewise, $(\evalgphiGen{\rho}{\gphi}) \iff (\gphiImplies{\phi_{\rho}}{\gphi})$ for any $\gphi \in \setGFormula$.
%\end{lemma}
%\begin{proof}
%    Let $\rho \in \setVarEnv$, $\phi \in \setFormula$ and $\phi_{\rho} = \minimp \{~ \phi ~|~ \evalphiGen{\rho}{\phi} ~\}$.
%    \begin{description}
%        \item[Case $\Longrightarrow$]~\\
%        Given: $\evalphiGen{\rho}{\phi}$
%
%        $\phi$ is hence in the set $\{~ \phi ~|~ \evalphiGen{\rho}{\phi} ~\}$ that has minimum $\phi_{\rho}$, so $\phiImplies{\phi_{\rho}}{\phi}$
%        \item[Case $\Longleftarrow$]~\\
%        Given: $\phiImplies{\phi_{\rho}}{\phi}$
%
%        By definition of $\phi_{\rho}$, $\evalphiGen{\rho}{\phi_{\rho}}$ holds.
%        By definition of $\phiImplies{}{}$ (see Def. \ref{def:form-implication}), $\evalphiGen{\rho}{\phi}$ follows.
%    \end{description}
%\end{proof}
%
%Operations on program states (\eg variable assignment $\rho[x \mapsto v]$) can be reinterpreted to operate on formulas representing program states.
%For example we assume that $(\phiAnd{\phiEq{x}{3}}{\phiEq{y}{5}})[\ttt{x} \mapsto 1] = \phiAnd{\phiEq{x}{1}}{\phiEq{y}{5}}$.
%
%We rewrite the semantics and soundness (progress and preservation) definitions of \svl and \gvl to use the above translation.
%It is worth discussing the similarities of the resulting system with a (gradual) type system:
%
%One could consider a stack of statements $s_n \cdot ... \cdot s_1 \cdot \nil$ as a term in a statically typed language.
%Just like a compiler of a typed language derives {\em compile time types} for all terms to check their integrity, \svl derives weakest preconditions for all source locations to check their conformance with contracts.
%In that sense, a weakest precondition of statements can be thought of as the compile time type of the remaining program represented by those statements.
%
%In a sound statically typed language, it is guaranteed that the runtime always type complies with the compile time type.
%For example, in a polymorphic setting, the runtime type may even be more specific than the compile time type, but may never contradict it.
%In \svl, weakest preconditions (the compile time types) must correctly describe corresponding environment $\rho$ (the runtime types) during execution.
%$\rho$ may be way more specific (e.g. map $x$ to 5, now represented as $\phiEq{x}{5}$) than the weakest precondition (e.g. $\phiNeq{x}{0}$) but may not contradict it.
%In that sense, there is a subtyping relationship between compile time and runtime types that must not be violated.
%
%In the gradual setting, this relationship gets altered only slightly, the compile time types may be imprecise now (while runtime types are inherently not, there is nothing imprecise about a particular program state).
%Recall our additional condition to make sure that a reduction $$\gsstep
%{\langle \rho'_m, s'_m \rangle \cdot ... \cdot \langle \rho'_1, s'_1 \rangle \cdot \nil}
%{\langle \rho_n, s_n \rangle \cdot ... \cdot \langle \rho_1, s_1 \rangle \cdot \nil}$$ is sound (see end of Sec.~\ref{sec:gvl-full-checks}):
%\begin{displaymath}
%\evalgphiGen{\rho_n}{\sgWP_n(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}
%\end{displaymath}
%We can now express the necessary runtime check syntactically:
%\begin{displaymath}
%\gphiImplies{\phi_{\rho_n}}{\sgWP_n(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}
%\end{displaymath}
%
%\subsubsection{Evidence of Consistent Implication}
%Motivated by the approach by Garcia \etal \cite{garcia2016abstracting} we have exemplified how soundness in \gvl now relies on making sure that combining judgments transitively succeeds.
%To realize this, AGT introduces the notion of {\em evidence} $\ev \in \Ev$ to characterize \emph{why} a consistent judgment holds.
%A combination judgment must be justified by evidence that is obtained from the evidences of the combined judgments.
%Failure to derive this evidence indicates that the plausibility of the judgment (and by extension verification) has been refuted, and that a runtime error should be raised.
%
%In this section we formalize our representation of such evidence.
%A canonical choice would be a set of concretizations that (following Def.~\ref{def:cons-pred-lift}) imply that the consistent judgment holds, \ie define $\Ev = \PP^{\setFormula \times \setFormula}$ in case of consistent implication.
%\begin{example}[Evidence as a set of concretizations]\label{ex:ev1}
%    All of the following sets are valid evidence for $\gphiImplies{\withqmGen{\phiEq{x}{4}}}{\withqmGen{\phiEq{y}{3}}}$:
%    \begin{alignat*}{2}
%        &\ev_1 = \{ &&\langle \phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}, \phiEq{y}{3} \rangle \}\\
%        &\ev_2 = \{ &&\langle \phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}, \phiAnd{\phiEq{y}{3}}{\phiEq{x}{4}} \rangle, \\
%        &           &&\langle \phiAnd{\phiAnd{\phiNeq{a}{b}}{\phiEq{x}{4}}}{\phiEq{y}{3}}, \phiAnd{\phiEq{y}{3}}{\phiNeq{a}{b}} \rangle \}\\
%        &\ev_3 = \{~ &&\langle \phi_a, \phi_b \rangle ~|~ \phi_a \in \gamma(\withqmGen{\phiEq{x}{4}}) ~\wedge~ \phi_b \in \gamma(\withqmGen{\phiEq{y}{3}}) ~\wedge~ (\phiImplies{\phi_a}{\phi_b}) ~\}
%    \end{alignat*}
%    Note that the last set is infinite.
%\end{example}
%The presence of possibly infinite sets poses a practical problem:
%Evidence is supposed to be used and combined at runtime.
%Fortunately we already have a mechanism in place that allows approximating (possibly infinite) set of formulas using gradual formulas (that have a finite representation), namely abstraction $\alpha$ (Def.~\ref{def:abstraction}).
%
%In a new attempt we pose $\Ev = \setGFormula \times \setGFormula$ and define evidence as the abstraction of a set of tuples backing the consistent judgment.
%\begin{example}[Evidence as an abstracted set of concretizations]\label{ex:ev2}
%    Following example~\ref{ex:ev1}, all of the following sets are valid evidence for $\gphiImplies{\withqmGen{\phiEq{x}{4}}}{\withqmGen{\phiEq{y}{3}}}$:
%    \begin{alignat*}{2}
%        &\ev_1 = \langle \phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}, \phiEq{y}{3} \rangle\\
%        &\ev_2 = \langle \withqmGen{\phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}}, \phiAnd{\phiEq{y}{3}}{\phiEq{z}{8}} \rangle, \\
%        &\ev_3 = \langle \withqmGen{\phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}}, \withqmGen{\phiEq{y}{3}} \rangle
%    \end{alignat*}
%    On the other hand $\langle \withqmGen{\phiEq{x}{4}}, \withqmGen{\phiEq{y}{3}} \rangle$ is not valid evidence since $\withqmGen{\phiEq{x}{4}}$ could not have been yielded by abstraction.
%    In particular, it is even less precise than the abstraction of \emph{all} possible first parameters to the implication (which is $\withqmGen{\phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}}$).
%\end{example}
%
%In the following sections we show how to obtain and process such evidence.
%
%%We address implementation considerations in Sect.~\ref{sec:implementation-dynamic-semantics}.
%
%% In this section we derive a formal runtime semantics based on AGT and analyze the resulting gradual verification system \gvlidf.
%% However, this semantics is impractical to implement as it requires sophisticated evidence calculations that impose a runtime overhead.
%% Thus, we determine the essence of evidence and move towards a more efficient implementation strategy.
%% Finally, we demonstrate our system by applying it to the initial motivating example (see Sec.~\ref{sec:introduction}).
%
%
%\subsubsection{Initial Evidence}
%\label{sec:init-ev}
%%\et{first formally introduce the notion of evidence and the judgment, then how to determine initial evidence}
%As motivated by AGT one can determine the {\em interior} of consistent implication as initial evidence that the implication is plausible.
%The interior is the abstraction of \emph{all} concretizations that back a consistent judgment (corresponds to $\ev_3$ in examples \ref{ex:ev1} and \ref{ex:ev2}).
%%Recall that the plausibility of a consistent implication $\gphiImplies{\gphi_1}{\gphi_2}$ requires the existence of some $\phi_1 \in \gamma(\gphi_1),\, \phi_2 \in \gamma(\gphi_2)$ such that $\phiImplies{\phi_1}{\phi_2}$. There might exist multiple such formulas.
%
%\begin{definition}[Interior of consistent implication]
%    The interior of consistent implication is defined as
%    \begin{align*}
%        \mathcal{I}(\gphi_1, \gphi_2) =
%        \langle
%        &\alpha(\{~ \phi_1 \in \gamma(\gphi_1) ~|~ \exists \phi_2 \in \gamma(\gphi_2).~ \phiImplies{\phi_1}{\phi_2} ~\}),\\
%        &\alpha(\{~ \phi_2 \in \gamma(\gphi_2) ~|~ \exists \phi_1 \in \gamma(\gphi_1).~ \phiImplies{\phi_1}{\phi_2} ~\})
%        \rangle
%    \end{align*}
%    % where $\alpha$ is chosen such that $\langle \alpha, \gamma \rangle$ is a Galois connection.\et{alpha was already defined, right?}
%\end{definition}
%
%%The interior uses the abstraction function $\alpha$ (Def.~\ref{def:abstraction}), which produces the most precise gradual formula over-approximating a given set of formulas.
%%As a result, the interior of an invalid consistent implication is undefined: invalid consistent implications have no supporting evidence.
%% is undefined if the consistent implication is invalid: there cannot be evidence for an invalid consistent judgment.
%%  (\eg $\gphiImplies{\withqmGen{\phiEq{x}{3}}}{\withqmGen{\phiEq{x}{4}}}$).
%For example:
%\begin{align*}
%    &\mathcal{I}(\withqmGen{\phiEq{x}{4}}, \withqmGen{\phiEq{y}{3}}) = \langle \withqmGen{\phiAnd{\phiEq{x}{4}}{\phiEq{y}{3}}}, \withqmGen{\phiEq{y}{3}} \rangle\\
%    &\mathcal{I}(\phiEq{x}{3}, \qm) = \langle \phiEq{x}{3}, \qm \rangle\\
%    &\mathcal{I}(\qm, \phiEq{x}{4}) = \langle \withqmGen{\phiEq{x}{4}}, \phiEq{x}{4} \rangle\\
%    &\mathcal{I}(\phiEq{x}{3}, \phiEq{x}{4}) \text{ is undefined}
%\end{align*}
%for the consistent judgments $\gphiImplies{\withqmGen{\phiEq{x}{4}}}{\withqmGen{\phiEq{y}{3}}}$, $\gphiImplies{\phiEq{x}{3}}{\qm}$, $\gphiImplies{\qm}{\phiEq{x}{4}}$, and $\gphiImplies{\phiEq{x}{3}}{\phiEq{x}{4}}$, respectively.
%% $\mathcal{I}(\phiEq{x}{3}, \phiEq{x}{4})$ is undefined.
%We write $\ev \vdash \gphiImplies{\gphi_1}{\gphi_2}$ to express that $\ev$ is evidence for the implication, i.e. $\ev = \mathcal{I}(\gphi_1, \gphi_2)$ would be such evidence.
%
%Initial evidence is determined by the static checker,
%backing all implications $\gphiImplies{\cdot}{\gWP(\cdot, \cdot)}$ required for validity of a program (Sec.~\ref{sec:abstracting-static-semantics}).
%Note that computing $\gWP(\sInvoke{y}{m}{x}, \gphi)$ itself also relies on consistent implication in order to justify the choice of $\phi'$ (see Fig.~\ref{fig:gvl-wp}).
%We formalize this notation as $\withEv{\ev}{\gphiImplies{\cdot}{\cdot}}$, $\withEv{\eta}{\gWP(\cdot, \cdot) = \cdot}$ and $\withEv{\ev, \eta}{\gphiImplies{\cdot}{\gWP(\cdot, \cdot)}}$ where $\eta ::= \langle \rangle ~|~ \langle \ev \rangle ~|~ \langle \ev, \ev \rangle ~|~ \langle \eta, \eta \rangle$ and $\ev \in \Ev$.
%Fig.~\ref{fig:gvlidf-hoare-initial-evidence} shows how one can annotate the above judgments with evidence.
%Evidence for judgments consists of evidence for the premises of the rules used to derive it, having evidence for only consistent implication at its leaves.
%Note how we gather evidence recursively in rule \tset{\gradT EvWpSeq}, hence the syntax of $\eta$ is recursive as well.
%
%\begin{figure}
%    \begin{center}
%        \begin{mathpar}\small
%            \inferrule* [right=EvValid]
%            {
%                \withEv{\ev}{\gphiImplies {\gphi_p} {\gphi}}\\
%                \withEv{\eta}{\gWP(s, \gphi_q) = \gphi}
%            }
%            {
%                \withEv{\ev, \eta}{\gphiImplies {\gphi_p} {\gWP(s, \gphi_q)}}
%            }
%
%            \inferrule* [right=EvWpSeq]
%            {
%                \withEv{\eta_2}{\gWP(s_2, \gphi) = \gphi'}\\
%                \withEv{\eta_1}{\gWP(s_1, \gphi') = \gphi''}
%            }
%            {
%                \withEv{\langle \eta_1, \eta_2 \rangle}{\gWP(\sSeq{s_1}{s_2}, \gphi) = \gphi''}
%            }
%
%            \inferrule* [right=EvWpAssert]
%            {
%                \withEv{\ev}{\gphiImplies{\gphi'}{\phi_a}}
%            }
%            {
%                \withEv{\langle \ev \rangle}{\gWP(\sAssert{$\phi_a$}, \gphi) = \gphi'}
%            }
%
%            \inferrule* [right=EvWpCall]
%            {
%                \withEv{\ev_1}{\gphiImplies {\gphi'} {\mpre{m}[x/\mparam{m}]}}\\
%                \withEv{\ev_2}{\gphiImplies {\phiAnd{\gphi'}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult}]} {\gphi}}
%            }
%            {
%                \withEv{\langle \ev_1, \ev_2 \rangle}{\gWP(\sInvoke{y}{m}{x}, \gphi) = \gphi'}
%            }
%
%            \inferrule* [right=EvWpOther]
%            {
%                s \text{ is neither call, assertion nor sequence statement}
%            }
%            {
%                \withEv{\langle \rangle}{\gWP(s, \gphi) = \gphi'}
%            }
%        \end{mathpar}
%    \end{center}
%    \caption{\gvlidf: Verification rules with evidence
%        %\jb{think about different presentation that makes difference between implicit and explicit implications clearer}
%    }
%    \label{fig:gvlidf-hoare-initial-evidence}
%\end{figure}
%
%The static checker instantiates evidence for consistent implication with the interior.
%
%\subsubsection{Combining Evidence}\label{ssec:cons-trans}
%Note that not only initial verification relies on $\gphiImplies{\cdot}{\gWP(\cdot, \cdot)}$ judgments as backed by \tset{EvValid} but also the preservation argument (rewritten as motivated in \ref{sec:state-as-fomula}), \ie \tset{EvValid} also describes evidence for valid program {\em states}.
%The dynamic semantics of \gvl will have to ensure that evidence for the validity of program states exists.
%While evidence for the initial program state is determined statically (see previous section), evidence has to be evolved and combined as execution proceeds.
%
%We define a consistent transitivity operator that combines evidence of implications into evidence for a transitive judgment. As expected, this operator is partial: failure to derive evidence means that the transitive judgment is invalid.
%
%\begin{definition}[Consistent transitivity]\label{def:cons-trans}
%    Given
%    $\ev_{12} \vdash \gphiImplies{\gphi_1}{\gphi_2}$
%    and
%    $\ev_{23} \vdash \gphiImplies{\gphi_2}{\gphi_3}$
%    we deduce evidence for consistent transitivity as
%    $(\ev_{12} \ctran \ev_{23}) \vdash \gphiImplies{\gphi_1}{\gphi_3}$
%    where
%    \begin{align*}
%        &\langle \gphi_1, \gphi_{21} \rangle \ctran \langle \gphi_{22}, \gphi_3 \rangle &= &
%        ~\alpha^2(\{~ \langle \phi_1, \phi_3 \rangle \in \gamma^2(\gphi_1, \gphi_3) ~|~ \\
%        &&&\quad\quad\quad \exists \phi_2 \in \gamma(\gphi_{21}) \cap \gamma(\gphi_{22}).~
%        \phiImplies{\phi_1}{\phi_2} \wedge \phiImplies{\phi_2}{\phi_3} ~\})
%    \end{align*}
%\end{definition}
%
%As expected, combining the initial evidence for $\gphiImplies{\phiEq{x}{3}}{\qm}$ and $\gphiImplies{\qm}{\phiEq{x}{4}}$ fails:\\
%$\langle \phiEq{x}{3}, \qm \rangle \ctran \langle \withqmGen{\phiEq{x}{4}}, \phiEq{x}{4} \rangle$
%is undefined because there exists no $\phi_2$ such that\\ $\phiImplies{\phiEq{x}{3}}{\phi_2} \wedge \phiImplies{\phi_2}{\phiEq{x}{4}}$ holds.
%On the other hand, if the second consistent judgment was $\gphiImplies{\qm}{\ttt{(x < 4)}}$ then the combination would succeed:
%\begin{align*}
%    &\langle \phiEq{x}{3}, \qm \rangle \ctran \langle \withqmGen{\ttt{(x < 4)}}, \ttt{(x < 4)} \rangle = \langle \phiEq{x}{3}, \ttt{(x < 4)} \rangle
%\end{align*}
%
%\begin{example}[Consistent transitivity guards calls to \ttt{withdraw}]
%    \label{ex:cons-trans}
%    We show how consistent transitivity calculations reveal whether execution can proceed in case of the call to \ttt{withdraw} as examined in section~\ref{sec:ds-using-cons-judgj}.
%    From verification we have (initial) evidence for the validity of \ttt{withdraw}:
%    \begin{scenter}
%    \begin{mathpar}
%    \inferrule* [right=\gradT EvValid]
%    {
%        \withEv{\ev_i}{\gphiImplies {\qm} {\phiGeq{b - a}{0}}}\\
%        \inferrule* [Right=\gradT EvWpOther]
%        {
%        }
%        {
%            \withEv{\langle \rangle}{\gWP(\sReturn{b - a}, \phiGeq{result}{0}) = \phiGeq{b - a}{0}}
%        }
%    }
%    {
%        \withEv{\ev_i, \langle \rangle}{\gphiImplies {\qm} {\gWP(\sReturn{b - a}, \phiGeq{result}{0})}}
%    }
%    \end{mathpar}
%    \end{scenter}
%
%    We assume that execution is at the spot right before the call and the program state is thus $\phiEq{b}{20}$.
%    Validity of this state is backed by:
%    \begin{scenter}
%    \begin{mathpar}
%    \inferrule* [right=\gradT EvValid]
%    {
%        \withEv{\ev}{\gphiImplies {\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}} {\qm}}\\
%        \inferrule* [Right=\gradT EvWpCall]
%        {
%            \withEv{\ev_1}{\gphiImplies {\qm} {\qm}}\\
%            \withEv{\ev_2}{\gphiImplies {\withqmGen{\phiGeq{result}{0}}} {\phiTrue}}
%        }
%        {
%            \withEv{\langle \ev_1, \ev_2 \rangle}{\gWP(\sInvoke{\ttt{b}}{\ttt{withdraw}}{\ttt{b, a}}, \phiTrue) = \qm}
%        }
%    }
%    {
%        \withEv{\ev, \langle \ev_1, \ev_2 \rangle}{\gphiImplies {\phiAnd{phiEq{b}{20}}{\phiEq{a}{30}}} {\gWP(\sInvoke{\ttt{b}}{\ttt{withdraw}}{\ttt{b, a}}, \phiTrue)}}
%    }
%    \end{mathpar}
%    \end{scenter}
%
%    For the next program state $\phi_{\rho} = \phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}$ (\ttt{withdraw} has been entered) to be valid, we have to {\em derive} evidence for $\gphiImplies {\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}} {\gWP(\sReturn{b - a}, \phiGeq{result}{0})}$ from the evidence above, \ie evidence for the validity of the previous state and function \ttt{withdraw}.
%    In this case, this is achieved by combining $\ev$ (previous state implies precondition of call), $\ev_1$ (precondition of call implies precondition of \ttt{withdraw}'s contract) and $\ev_i$ (precondition of \ttt{withdraw}'s contract implies $\gWP$ of method body).
%
%    Specifically, $$\withEv{\ev \ctran \ev_1 \ctran \ev_i, \langle \rangle}{\gphiImplies {\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}} {\gWP(\sReturn{b - a}, \phiGeq{result}{0})}}$$ would be a proof tree (premises omitted) for the validity of program state $\phi_{\rho}$.
%    (Note that in general, one has to normalize the variable names of $\ev$ and $\ev_1$ to the callee's context.)
%
%    However, $\ev \ctran \ev_1 \ctran \ev_i$ is undefined (w.l.o.g. we assume that $\ev$ is instantiated with initial evidence):
%    \begin{flalign*}
%        &\text{Given:} &\\
%        &\ev = \mathcal{I}(\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}, \qm) = \langle \phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}, \qm \rangle\\
%        &\ev_1 = \mathcal{I}(\qm, \qm) = \langle \qm, \qm \rangle\\
%        &\ev_i = \mathcal{I}(\qm, \phiGeq{b - a}{0}) = \langle \withqmGen{\phiGeq{b - a}{0}}, \phiGeq{b - a}{0} \rangle\\
%        &\\
%        &\ev \ctran \ev_1 \ctran \ev_i \\
%        =~& \langle \phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}, \qm \rangle \ctran \langle \qm, \qm \rangle \ctran \langle \withqmGen{\phiGeq{b - a}{0}}, \phiGeq{b - a}{0} \rangle \\
%        =~& \langle \phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}, \qm \rangle \ctran \langle \withqmGen{\phiGeq{b - a}{0}}, \phiGeq{b - a}{0} \rangle \\
%        =~& \textit{undefined}\\
%        &\text{ since } \gamma(\qm) \cap \gamma(\withqmGen{\phiGeq{b - a}{0}}) = \gamma(\withqmGen{\phiGeq{b - a}{0}}) \\
%        &\text{ contains no element implied by $\phiAnd{\phiEq{b}{20}}{\phiEq{a}{30}}$}
%    \end{flalign*}
%
%    In contrast, if \ttt{b} was assigned 40 instead of 20, the state would be $\phi_{\rho} = \phiAnd{\phiEq{b}{40}}{\phiEq{a}{30}}$ and
%    $\ev \ctran \ev_1 \ctran \ev_i = \langle \phiAnd{\phiEq{b}{40}}{\phiEq{a}{30}}, \phiGeq{b - a}{0} \rangle$ would be evidence for the validity of $\phi_{\rho}$.
%\end{example}
%
%
%
%\subsubsection{Reduction Rules}
%Equipped with the notion of evidence, how to determine it initially, and how to combine it through consistent transitivity, we can formalize the runtime semantics of \gvl as small-step reduction rules.
%%Due to the lock step criterion of the dynamic gradual guarantee\et{who will know what that means here?},
%Similar to the runtime assertion approach (Section~\ref{sec:gvl-full-checks}), we base these rules on the reduction rules of \svl, but use evidence (instead of runtime assertion checks) to deduce whether a derivation may happen or not.
%Preservation is explicitly addressed by constructing the proof trees for the validity of the new program state including evidence for the derived judgments. This results in the reduction rules presented in Fig.~\ref{fig:grad-reduction}.
%We use notation $\withEv{\langle \ev_n, \eta_n \rangle \cdot ... \cdot \langle \ev_1, \eta_1 \rangle \cdot \nil}{\langle \phi_{\rho_n}, s_n \rangle \cdot ... \cdot \langle \phi_{\rho_1}, s_1 \rangle \cdot \nil}$ as a shorthand for program state $\langle \phi_{\rho_n}, s_n \rangle \cdot ... \cdot \langle \phi_{\rho_1}, s_1 \rangle \cdot \nil$ with $\withEv{\ev_i, \eta_i}{\gphiImplies{\phi_{\rho_i}}{\sgWP_i(s_n \cdot ... \cdot s_1 \cdot \nil)}}$ for $1 \le i \le n$.
%If evidence computation (\eg in \tset{\gradT SsCall}) fails, we transition into the error state (those rules were omitted).
%
%\begin{figure}
%    \begin{center}
%        \begin{mathpar}
%            \inferrule* [right=\gradT SsSeqSkip]
%            {
%            }
%            {
%                \gsstep
%                {\withEv
%                    {\langle \ev, \langle \langle \rangle, \eta \rangle \rangle \cdot E}
%                    {\langle \phi_{\rho}, \sSeq{\sSkip}{s} \rangle \cdot S}
%                }
%                {\withEv
%                    {\langle \ev, \eta \rangle \cdot E}
%                    {\langle \phi_{\rho}, s \rangle \cdot S}
%                }
%            }
%            \and
%            \inferrule* [right=\gradT SsSeq]
%            {
%                \gsstep
%                {\withEv
%                    {\langle \ev, \eta_1 \rangle \cdot E}
%                    {\langle \phi_{\rho}, s_1 \rangle \cdot S}
%                }
%                {\withEv
%                    {\langle \ev', \eta'_1 \rangle \cdot E}
%                    {\langle \phi_{\rho'}, s_1' \rangle \cdot S}
%                }
%            }
%            {
%                \gsstep
%                {\withEv
%                    {\langle \ev, \langle \eta_1, \eta_2 \rangle \rangle \cdot E}
%                    {\langle \phi_{\rho}, \sSeq{s_1}{s_2} \rangle \cdot S}
%                }
%                {\withEv
%                    {\langle \ev', \langle \eta'_1, \eta_2 \rangle \rangle \cdot E}
%                    {\langle \phi_{\rho'}, \sSeq{s_1'}{s_2} \rangle \cdot S}
%                }
%            }
%            %\and
%            %\inferrule* [right=\gradT SsAssert]
%            %{
%            %    \evalphiGen{\rho}{\phi}
%            %}
%            %{
%            %    \gsstep
%            %    {\langle \rho, {\sAssert {$\phi$}} \rangle \cdot S}
%            %    {\langle \rho, \sSkip \rangle \cdot S}
%            %}
%            %\and
%            %\inferrule* [right=\gradT SsAssign]
%            %{
%            %    \evalexpr {\rho} {e} {v} \\
%            %    {\rho'} = {{\rho}[{x} \mapsto {v}]}
%            %}
%            %{
%            %    \gsstep
%            %    {\langle \rho, {\sVarAssign {x} {e}} \rangle \cdot S}
%            %    {\langle \rho', \sSkip \rangle \cdot S}
%            %}
%            \and
%            \inferrule* [right=\gradT SsCall]
%            {
%                {\predicate{method}(m)} = {
%                    \method
%                    {T_r}
%                    {m}
%                    {T}
%                    {x'}
%                    {\contract {\gphi_p} {\gphi_{q}}}
%                    {r}
%                } \\
%                \text{initial evidence } \withEv{\ev_i, \eta_i}{\phiImplies{\gphi_p}{\gWP(r), \gphi_q}} \\
%                \phiImplies{\phi_{\rho}}{\phiEq{$x$}{$v$}} \\
%                \phi_{\rho'} = \phiEq{$x'$}{$v$} \\
%                \gphiImplies{\phi_{\rho'}}{\gphi_p}
%            }
%            {
%                {\withEv
%                    {\langle \ev, \langle \langle \ev_1, \ev_2 \rangle, \eta \rangle \rangle \cdot E}
%                    {\langle \phi_{\rho}, \sSeq{\sInvoke{y}{m}{x}}{s} \rangle \cdot S}
%                }
%                \\\\
%                \gsstep{}{}
%                \\\\
%                {\withEv
%                    {\langle \ev[x/x'] \ctran \ev_1[x/x'] \ctran \ev_i, \eta_i \rangle \cdot
%                     \langle \ev, \langle \langle \ev_1, \ev_2 \rangle, \eta \rangle \rangle \cdot E}
%                    {\langle \phi_{\rho'}, r \rangle \cdot \langle \phi_{\rho}, \sSeq{\sInvoke{y}{m}{x}}{s} \rangle \cdot S}
%                }
%            }
%            %\and
%            %\inferrule* [right=\gradT SsCallFinish]
%            %{
%            %    \predicate{post}({m}) = {\phi_q} \\
%            %    \evalphiGen {\rho'} {\phi_q} \\
%            %    {\rho''} = {{\rho}[{y} \mapsto \rho'(\eresult)]}
%            %}
%            %{
%            %    \gsstep
%            %    {{\langle{\rho'}, {\sSkip}\rangle} \cdot {{\langle{\rho}, {\sSeq{\sInvoke{y}{m}{x}}{s}}\rangle} \cdot {S}}}
%            %    {{\langle{\rho''}, {s}\rangle} \cdot {S}}
%            %}
%        \end{mathpar}
%    \end{center}
%    \caption{\gvlidf: Reduction on evidence derivations (selected rules).}
%    \label{fig:grad-reduction}
%\end{figure}
%
%%Note how evidence is combined in order to ensure progress and preservation for assertions:
%%$\ev$ is evidence that the current state implies the $\gWP$ of the assertion (see Fig.~\ref{fig:gvlidf-hoare-initial-evidence}).
%%It is combined with the evidence that this $\gWP$ implies the assertion ($\ev'$, determining whether we may progress normally) and postcondition $\gphi_q$ ($\ev''$, determining whether the resulting state is still plausible).
%
%Note how the scenario in example \ref{ex:cons-trans} is described by \tset{\gradT SsCall}.
%
%\subsubsection{Equivalence with runtime assertion based semantics}
%The reduction rules of Fig.~\ref{fig:grad-reduction} are sound by construction (without proof; similarly to full runtime check as introduced in sec.~\ref{sec:gvl-full-checks}, preservation is explicitly checked for).
%Any overhead relative to \svl comes from tracking and combining evidence.
%
%As a first step, we explain how to simplify the {\em representation} of evidence, thereby enabling algorithmic definitions for computing initial evidence and combining it. We then show that these definitions no longer rely on tracking evidence per se, and rather correspond to {\em evaluating} formulas in a runtime model using (as originally) variable environments $\rho$.
%Furthermore, these checks are equivalent to the runtime assertions proposed in \ref{??}. \jb{check... is it rather full checks or residual?}
%
%\paragraph{Implementing Evidence}
%%Recall the definition of interior of consistent implication from Section~\ref{sec:init-ev}.
%By definition, evidence $\langle \gphi_1, \gphi_2 \rangle$ of a consistent implication satisfies $\exists \phi_1 \in \gamma(\gphi_1).~ \gphiImplies{\phi_1}{\gphi_2}$.
%%\et{so this is true of evidence, right? phrase it in terms of evidence as much as possible, since the term is used more frequently and is less "scary" than interior}
%% \end{align*}
%However, we observe that due to the specific syntax of gradual formula, a stronger property holds, quantified {\em universally}:
%% \begin{align*}
%$\forall \phi_1 \in \gamma(\gphi_1).~ \gphiImplies{\phi_1}{\gphi_2}$.
%% \end{align*}
%%
%This property relies on the fact that we are able to encode static information in gradual formulas. The property would not be true if we had defined $\gphi ::= \phi ~|~ \qm$, \ie~if a gradual formula would be either fully precise or completely unknown.
%
%In \gvl, the left component of evidence represents \emph{precisely} a set of formulas that imply the right component.
%%\jb{should we go with “dense”?} \et{not needed}
%Therefore, the right component is irrelevant for further processing, in particular combining evidence.
%%\et{left/right vs first/second: pick one and be consistent.}
%Specifically, we can simplify evidence calculations as follows, using a new interior function $\mathcal{I}' \in \setGFormula \times \setGFormula \rightharpoonup \setFormulaB$:
%%\et{give the new signature of I, using maybe I' to differentiate}
%\begin{alignat*}{3}
%    &\mathcal{I}'(\gphi_1, \gphi_2) &&= \alpha(\{~ \phi_1 \in \gamma(\gphi_1) ~|~ \exists \phi_2 \in \gamma(\gphi_2).~ \phiImplies{\phi_1}{\phi_2} ~\}) & \\
%    %& &&=
%    %\begin{cases}
%    %\phi_1 \\
%    %\quad\quad\quad\text{if } \gphi_1 = \phi_1 \\
%    %\quad\quad\quad\wedge~ \phiImplies{\phi_1}{\static{$\gphi_2$}}\\
%    %\withqm{\phiCons{$\phi_1$}{$\snorm{\static{$\gphi_2$}}$}} \\
%    %\quad\quad\quad\text{if } \gphi_1 = \withqm{\phi_1} \\
%    %\quad\quad\quad\wedge~ \phiCons{$\phi_1$}{$\snorm{\static{$\gphi_2$}}$} \in \setFormulaA
%    %\end{cases} \\
%    &\gphi_1 \ctran \gphi_2 &&= \mathcal{I}'(\gphi_1, \gphi_2) &
%\end{alignat*}
%%TODO: cases not entirely true, case 1 has more complex side condition due to IDF!
%%TODO: if cases are shown, normal form $\snorm{\cdot}$ must be introduced.~
%
%% \jb{Formal relation between those definitions and the original one?}
%
%%% traditional story
%A further optimization is possible by looking at the specific evidence calculations that the reduction rules rely on. In fact, the judgments that are being justified by combining evidence always have the same shape: $\gphiImplies{\phi_{\rho}}{...}$ (see Fig.~\ref{fig:grad-reduction}).
%This is not surprising since the (syntactic version of) preservation is such a judgment.
%Both initial evidence and successfully-combined evidence for judgments of this shape will always be $\phi_{\rho}$ and therefore carries no information that the actual environment $\rho$ does not already provide. This observation yields the following further simplifications:
%\begin{alignat*}{3}
%    &\mathcal{I}'(\phi_{\rho}, \gphi_2) &&= \alpha(\{~ \phi_1 \in \gamma(\phi_{\rho}) ~|~ \exists \phi_2 \in \gamma(\gphi_2).~ \phiImplies{\phi_1}{\phi_2} ~\})
%    =
%    \begin{cases}
%        \phi_{\rho} &
%        \text{if } \gphiImplies{\phi_{\rho}}{\gphi_2}\\
%        \text{undefined} &
%        \text{otherwise }\\
%    \end{cases} \\
%    &\phi_{\rho} \ctran \gphi_2 &&= \mathcal{I}'(\phi_{\rho}, \gphi_2) &
%\end{alignat*}
%
%Intuitively, all that remains to be checked is \emph{whether} an initial/combining evidence calculation succeeds or not. In case of success, $\phi_{\rho}$ is simply forwarded.
%Note that this check corresponds to proving a consistent implication, but can be translated back to evaluating $\evalgphiGen{\rho}{\gphi_2}$ (see Lemma.~\ref{lemma:rho-syntax-semantics}).
%After all, we do not rely on the evidence $\phi_m$ at all, \ie~computing and combining evidence can be dropped from the implementation altogether.
%
%The resulting semantics corresponds to the runtime semantics using assertion checks we derived for \gvl.
%
%\subsubsection{Conclusion}
%The syntax-directed approach relying on evidence tracking becomes increasingly attractive as the formula logic can no longer be decided using only the program state (that is readily available from runtime context, \ie heap and stack).
%Accessibility predicates are a step in this direction, type systems are all the way on the other side of the spectrum.
%In practice, the lines are often blurred. For example, a refinement type system also has elements that are decidable using program state, however it may still be more appropriate to use an evidence based approach as developed by \citet{lehmannTanter:popl2017}.
%
%\end{comment}
%
%\begin{comment}
%\subsection{Full Definitions}~\\
%
%\FloatBarrier
%
%%\subsubsection{\svlidf}
%
%\begin{figure}
%	\begin{center}
%	% need that for sublime text to build properly with multiple files
%	%!TEX root = ../main.tex
%
%	\newcommand{\tempStmtA}{\sSkip
%		~|~ \sSeq {s_1} {s_2}
%		~|~ \sDeclare {$T$} {$x$}
%		~|~ \sVarAssign {x} {e}
%		~|~ \sAssert {$\phi$} }
%	\newcommand{\tempStmtB}{~~~
%		~|~ \sFieldAssign {$x$} {$f$} {$y$}
%		~|~ \sAlloc {$x$} {$C$}
%		~|~ \sCall{y}{z}{m}{x}
%	}
%	\newcommand{\tempFrmA}{  \phiTrue
%		%~|~ \phiEq {$e$} {$e$}
%		%~|~ \phiNeq {$e$} {$e$}
%		~|~ \phiCompOp {e} {e}}
%	\newcommand{\tempFrmB}{
%		~|~ \phiCons {\phi} {\phi}
%		~|~ \phiAcc {$e$} {$f$}}
%	\newcommand{\tempExpr}{ v
%		~|~ x
%		~|~ \eOp {e} {e}
%		~|~ \edot{e}{f}}
%
%	\begin{minipage}{.5\linewidth}
%		\small\noindent
%		\begin{align*}
%			program  & ::= \overline{cls}~s                             \\
%			cls      & ::= \class {$C$} {$\overline{field}$} {$\overline{method}$} \\
%			field    & ::= \field {$T$} {$f$}                                      \\
%			method   & ::= \procedure {T} {m} {T} {x} {contract} {s}      \\
%			contract & ::= \contract{\sphi}{\sphi}                               \\
%			T        & ::= \Tint ~|~ C                                             \\
%			\phi     & ::= \tempFrmA \tempFrmB
%		\end{align*}
%	\end{minipage}%
%	\begin{minipage}{.5\linewidth}
%		\small\noindent
%		\begin{align*}
%			s        & ::= \tempStmtA\\
%					 & \tempStmtB                                   \\
%			e        & ::= \tempExpr                                               \\
%			x        & ::= \eresult ~|~ ident ~|~ \phiOld{ident} ~|~ \ethis        \\
%			v        & ::= n ~|~ o ~|~ \enull \\
%			\oplus   & ::= \ttt{+}~|~\ttt{-}~|~...\\
%			\odot    & ::=~\ttt{=}~|~\ttt{≠}~|~\ttt{<}~|~...
%		\end{align*}
%	\end{minipage}%
%\\~\\
%where $o \in \setLoc$ is a heap location and $f \in \setFieldName$ are field names
%	\end{center}
%	\caption{\svlidf: Syntax}
%	\label{appfig:svlidf-syntax}
%\end{figure}
%
%\begin{figure}[t]
%    \begin{scenter}
%    \begin{mathpar}
%        \inferrule* [right=FrmVar]
%        {
%            ~
%        }
%        {
%            {A_s} \sfrmphi {x}
%        }
%
%        \inferrule* [right=FrmVal]
%        {
%            ~
%        }
%        {
%            {A_s} \sfrmphi {v}
%        }
%
%        \inferrule* [right=FField]
%        {
%            {\langle {e}, {f} \rangle} \in {A} \\
%            {A} \sfrmphi {e}
%        }
%        {
%            {A} \sfrmphi {\edot{e}{f}}
%        }
%
%        \inferrule* [right=SfrmTrue]
%        {
%            ~
%        }
%        {
%            {A} \sfrmphi {\phiTrue}
%        }
%
%        \inferrule* [right=SFComp]
%        {
%            {A} \sfrmphi {e_1} \\
%            {A} \sfrmphi {e_2}
%        }
%        {
%            {A} \sfrmphi {e_1 \odot e_2}
%        }
%
%        \inferrule* [right=SFAcc]
%        {
%            {A} \sfrmphi {e}
%        }
%        {
%            {A} \sfrmphi {\phiAcc {${e}$} {${f}$}}
%        }
%
%        \inferrule* [right=SFSepOp]
%        {
%            A \sfrmphi \phi_1 \\
%            A \cup \staticFP {\phi_1} \sfrmphi \phi_2
%        }
%        {A \sfrmphi \phiCons{\phi_1}{\phi_2}}
%    \end{mathpar}
%    \end{scenter}
%    \caption{\svlidf: Framing \jb{TODO, sync with main, consistent naming}}
%    \label{appfig:svlidf-frm}
%\end{figure}
%
%\begin{figure}
%    \begin{scenter}
%    \begin{mathpar}
%        \inferrule* [right=EvTrue]
%        {
%            ~
%        }
%        {
%            \evalphiGen {\langle H, \rho, A \rangle} {\phiTrue}
%        }
%
%        \inferrule* [right=EvComp]
%        {
%            \evalex {H} {\rho} {e_1} {v_1} \\
%            \evalex {H} {\rho} {e_2} {v_2} \\
%            {v_1} \odot {v_2}
%        }
%        {
%            \evalphiGen {\langle H, \rho, A \rangle} {\phiCompOp {e_1} {e_2}}
%        }
%
%        \inferrule* [right=EvAcc]
%        {
%            \evalex {H} {\rho} {e} {{o}} \\
%            \evalex {H} {\rho} {\edot{e}{f}} {v} \\
%            {\langle{o}, {f}\rangle} \in {A}
%        }
%        {
%            \evalphiGen {\langle H, \rho, A \rangle} {\phiAcc {${e}$} {${f}$}}
%        }
%
%        \inferrule* [right=EvSepOp]
%        {
%            \evalphiGen {\langle H, \rho, {A_1} \rangle} {\phi_1} \\
%            \evalphiGen {\langle H, \rho, {A_2} \rangle} {\phi_2}
%        }
%        {\evalphiGen {\langle H, \rho, A_1 \uplus A_2 \rangle} {\phiCons {\phi_1} {\phi_2}}}
%    \end{mathpar}
%    \end{scenter}
%    \caption{\svlidf: Formula semantics}
%    \label{appfig:svlidf-evalphi}
%\end{figure}
%
%\begin{figure}[t]
%    \begin{scenter}
%        \begin{mathpar}
%            \inferrule* [right=SsSkip]
%            {
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, {\sSkip} \rangle \cdot S \rangle}
%                {\langle H, \langle \rho, A, \sSkip \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsSeq]
%            {
%                \sstep
%                {\langle H, \langle \rho, A, s_1 \rangle \cdot S \rangle}
%                {\langle H, \langle \rho', A, s_1' \rangle \cdot S \rangle}
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, \sSeq{s_1}{s_2} \rangle \cdot S \rangle}
%                {\langle H, \langle \rho', A, \sSeq{s_1'}{s_2} \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsSkip]
%            {
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, {\sSkip} \rangle \cdot S \rangle}
%                {\langle H, \langle \rho, A, \sSkip \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsAssert]
%            {
%                \evalphiGen{\langle H, \rho, A \rangle}{\phi}
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, {\sAssert {$\phi$}} \rangle \cdot S \rangle}
%                {\langle H, \langle \rho, A, \sSkip \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsFAssign]
%            {
%                \evalphiGen{\langle H, \rho, A \rangle}{\phiAcc{$x$}{$f$}}\\
%                \evalex {H} {\rho} {y} {v} \\
%                {H'} = {{H}[o \mapsto [f \mapsto v]]}
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, {\sFieldAssign {${x}$} {${f}$} {${y}$}} \rangle \cdot S \rangle}
%                {\langle H', \langle \rho, A, \sSkip \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsAssign]
%            {
%                \evalphiGen{\langle H, \rho, A \rangle}{\accFor{e}}\\
%                \evalex {H} {\rho} {e} {v} \\
%                {\rho'} = {{\rho}[{x} \mapsto {v}]}
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, {\sVarAssign {x} {e}} \rangle \cdot S \rangle}
%                {\langle H, \langle \rho', A, \sSkip \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsDeclare]
%            {
%                {\rho'} = {{\rho}[{x} \mapsto {\defaultValue{T}}]}
%            }
%            {
%                \sstep
%                {\langle H, \langle \rho, A, {\sDeclare {$T$} {$x$}} \rangle \cdot S \rangle}
%                {\langle H, \langle \rho', A, \sSkip \rangle \cdot S \rangle}
%            }
%            \and
%            \inferrule* [right=SsCall]
%            {
%                {\predicate{method}(m)} = {
%                    \procedure
%                    {T_r}
%                    {m}
%                    {T}
%                    {x'}
%                    {\contract {\sphi_p} {\sphi_{q}}}
%                    {r}
%                } \\
%                \evalex {H} {\rho} {z} {o} \\
%                \evalex {H} {\rho} {x} {v} \\
%                {\rho'} = {[{\ethis} \mapsto {{o}}, {{x'}} \mapsto {v}]} \\
%                {A'} = {\dynamicFP {H} {\rho'} {\sphi_p}} \\
%                \evalphiGen {\langle H, \rho', A' \rangle} {\sphi_p}
%            }
%            {
%                \sstep
%                {\langle H, {{\langle \rho, A, {\sSeq{\sCall{y}{z}{m}{x}}{s}}\rangle} \cdot {S}}\rangle}
%                {\langle H, {{\langle \rho', A', {r}\rangle} \cdot {{\langle{{\rho}, {{A} \backslash {A'}}}, {\sSeq{\sCall{y}{z}{m}{x}}{s}}\rangle} \cdot {S}}}\rangle}
%            }
%            \and
%
%            \inferrule* [right=SsCallFinish]
%            {
%                \predicate{post}({m}) = {\sphi_q} \\
%                \evalphiGen {\langle H, \rho', A' \rangle} {\sphi_q} \\
%                {\rho''} = {{\rho}[{y} \mapsto \rho'(\eresult)]}
%            }
%            {
%                \sstep
%                {\langle{H}, {{\langle \rho', A', \sSkip \rangle} \cdot {{\langle \rho, A, {\sSeq{\sCall{y}{z}{m}{x}}{s}} \rangle} \cdot S}}\rangle}
%                {\langle{H}, {{\langle {\rho'', {A \cup A'}}, {s}\rangle} \cdot {S}}\rangle}
%            }
%        \end{mathpar}
%    \end{scenter}
%    \caption{\svlidf: Local small-step semantics}
%    \label{appfig:svlidf-dyn-sem}
%\end{figure}
%
%
%\begin{figure}
%    \begin{scenter}
%        \begin{alignat*}{2}
%            &\WP(\sSkip, \sphi)
%            &&= \sphi\\
%            &\WP(\sSeq{s_1}{s_2}, \sphi)
%            &&= \WP(s_1, \WP(s_2, \sphi))\\
%            &\WP(\sDeclare{$T$}{$x$}, \sphi)
%            &&= \sphi[\defaultValue{$T$}/x]\\
%            &\WP(\sVarAssign{x}{e}, \sphi)
%            &&= \maximp~ \{~ \sphi' ~|~ \phiImplies{\sphi'}{\sphi[e/x]} ~~~~\wedge~~~~ \phiImplies{\sphi'}{\accFor{e}} ~\}\\
%            &\WP(\sFieldAssign{$x$}{$f$}{$y$}, \sphi)
%            &&= \phiCons{\phiAcc{$x$}{$f$}}{}
%            \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\phiCons{\phiAcc{$x$}{$f$}}{\phiEq{\edot{x}{f}}{$y$}}}}{\sphi} ~~~~\wedge\\
%            &&& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\,\,\,\, \phiCons{\sphi'}{\phiAcc{$x$}{$f$}} \in \setFormulaA ~\}\\
%            &\WP(\sAlloc{$x$}{$C$}, \sphi)
%            &&= \max~ \{~ \sphi' ~|~ \phiCons{\sphi'}{\phiNeq{$x$}{\enull}}\\
%            &&&~~\ttt{*}\,\phiImplies{\overline{\phiCons{\phiAcc{$x$}{$f_i$}}{\phiEq{$x$.$f_i$}{\defaultValue{$T_i$}}}}}{\sphi} ~\}\\
%            &&&~~\text{where } \fields{C} = \overline{T_i~f_i}\\
%            &\WP(\sAssert{$\phi_a$}, \sphi)
%            &&= \maximp~ \{~ \sphi' ~|~ \phiImplies{\sphi'}{\sphi} ~~~~\wedge~~~~ \phiImplies{\sphi'}{\phi_a} ~\}\\
%            &\WP(\sCall{y}{z}{m}{x}, \sphi)
%            &&= \maximp~ \{~ \sphi' ~|~
%            \
%            y \not \in \FV(\sphi')~~~~\wedge\\
%            &&&
%            \phiImplies{\sphi'}{\phiCons{\phiNeq{$z$}{\enull}}{\mpre{m}[z,x/\ethis,\mparam{m}]}}~~~~\wedge\\
%            &&&
%            \phiImplies{\phiCons{\sphi'}{\mpost{m}[z,x,y/\ethis,\phiOld{\mparam{m}},\eresult]}}{\sphi} ~\}
%        \end{alignat*}
%    \end{scenter}
%    \caption{\svlidf: Weakest precondition}
%    \label{appfig:svlidf-wp}
%\end{figure}
%
%%\subsubsection{\gvlidf}
%
%\begin{figure}
%    \begin{small}
%        \begin{alignat*}{2}
%            &\gWP(s, \sphi)
%            &&= \WP(s, \sphi) \quad \text{ if $s$ is not a call statement}\\
%            &\gWP(\sSkip, \withqm{\phi})
%            &&= \withqm{\phi}\\
%            &\gWP(\sSeq{s_1}{s_2}, \withqm{\phi})
%            &&= \gWP(s_1, \gWP(s_2, \withqm{\phi}))\\
%            &\gWP(\sDeclare{$T$}{$x$}, \withqm{\phi})
%            &&= \withqm{\phi[\defaultValue{T}/x]}\\
%            &\gWP(\sVarAssign{x}{e}, \withqm{\phi})
%            &&= \withqm{\phiCons{\phi[e/x]}{\phiEq{$e$}{$e$}}}\\
%            %&\WP(\sFieldAssign{$x$}{$f$}{$y$}, \sphi)
%            %    &&= \phiCons{\phiAcc{$x$}{$f$}}{}
%            %    \maximp~ \{~ \sphi' ~|~ \phiImplies{\phiCons{\sphi'}{\phiCons{\phiAcc{$x$}{$f$}}{\phiEq{\edot{x}{f}}{$y$}}}}{\sphi} ~~~~\wedge\\
%            %    &&& \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\,\,\,\, \phiCons{\sphi'}{\phiCons{\phiAcc{$x$}{$f$}}{\phiEq{\edot{x}{f}}{$y$}}} \in \setFormulaA ~\}\\
%            &\gWP(\sFieldAssign{$x$}{$f$}{$y$}, \withqm{\phi})
%            &&= \withqm{\phiCons{(\phi \div \langle x, f \rangle)}{\phiAcc{$x$}{$f$}}}\\
%            &&&\!\!\!\!\!\!\!\!\!\!\!\!\text{~~ if } \phiImplies{\phiCons{(\phi \div \langle x, f \rangle)}{\phiCons{\phiAcc{$x$}{$f$}}{\phiEq{\edot{x}{f}}{$y$}}}}{\phi}\\
%            &\gWP(\sAlloc{$x$}{$C$}, \withqm{\phi})
%            &&= \withqm{\phi'}
%            \text{~~ where } \phi' = \phi \div x\\
%            &&&\!\!\!\!\!\!\!\!\!\!\!\!\text{~~ if } {\phiCons{\phi'}{\phiNeq{$x$}{\enull}}}\,\ttt{*}\,\phiImplies{\overline{\phiCons{\phiAcc{$x$}{$f_i$}}{\phiEq{\edot{x}{f_i}}{\defaultValue{$T_i$}}}}}{\phi}\\
%            &\gWP(\sAssert{$\phi_a$}, \withqm{\phi})
%            &&= \withqm{\phiCons{\phi}{|\phi_a|}}\\
%            %&\WP(\sCall{y}{z}{m}{x}, \sphi)
%            %&&= \maximp~ \{~ \sphi' ~|~
%            %y \not \in \FV(\sphi')~~~~\wedge\\
%            %&&&
%            %\phiImplies{\sphi'}{\phiCons{\phiNeq{$z$}{\enull}}{\mpre{m}[z,x/\ethis,\mparam{m}]}}~~~~\wedge\\
%            %&&&
%            %\phiImplies{\phiCons{\sphi'}{\mpost{m}[z,x,y/\ethis,\phiOld{\mparam{m}},\eresult]}}{\sphi}~\wedge\\
%            %&&&
%            %\phiCons{\sphi'}{\mpost{m}[z,x,y/\ethis,\phiOld{\mparam{m}},\eresult]} \in \setFormulaA ~\}\\
%            %&\gWP(\sCall{y}{z}{m}{x}, \gphi)
%            %&&= \withqm{\phi'}\\
%            %&&&
%            %\llap{where $\phi' = $ }
%            %\maximp~ \{~ \phi' ~|~
%            %y \not \in \FV(\phi')~\wedge\\
%            %&&&\quad
%            %\gphiImplies{\phi'}{\phiCons{\phiNeq{$z$}{\enull}}{\mpre{m}[z,x/\ethis,\mparam{m}]}}~\wedge\\
%            %&&&\quad
%            %\gphiImplies{\phiCons{\mpost{m}[z,x,y/\ethis,\phiOld{\mparam{m}},\eresult]}{\phi'}}{\gphi} ~\}\\
%        \end{alignat*}
%    \end{small}
%
%    \caption{\gvlidf: Weakest precondition implementation pointers}
%    %\jb{do this? even define and explain $\div$, $|\phi|$?}\ja{yes, ideally if you use it it should be defined at least and explained if possible.  At this point we need to prioritize your effort though!}
%    \label{appfig:gvlidf-wp}
%\end{figure}
%
%\FloatBarrier
%
%Note that Fig. \ref{appfig:gvlidf-wp} uses several helping functions:
%A “division” $\phi \div x$ calculates the maximum formula implied by $\phi$ but not containing $x$.
%This can be implemented by transitively expanding (in-)equalities and then removing conjunctive terms containing $x$.
%Similarly $\phi \div A$ calculates the maximum formula implied by $\phi$ that has a footprint disjoint to $A$.
%
%Furthermore, there exists an accessibility-predicate-free version $\snorm{\phi}$ of any formula $\phi$.
%Having no footprint, such a formula can be concatenated to other formulas using the separating conjunction (which then behaves like “regular” disjunction).
%Note however, that $\snorm{\phi}$ may not be self-framed (as soon as it names a field) and thus relies on being framed.
%Therefore, such formulas can only be used in conjunction with imprecise formulas, where the $\qm$ guarantees the (re-)framing of the static part.
%Example:
%\begin{small}
%$$\snorm{\ttt{\textbf{acc}(x.f) * (x.f = 3) * \textbf{acc}(y.f) * (b = 5)}} = \ttt{(x $\neq$ y) * (x.f = 3) * (y.f = y.f) * (b = 5)}$$
%\end{small}
%As part of an imprecise formula, access to both fields is restored (through concretization).
%Specifically, $\withqm{\snorm{\phi}} = \withqm{\phi}$ holds for all $\phi \in \setFormula$.
%
%%Implementations for such operations exist (and are implemented in the prototype implementation) but go beyond the scope of this paper.
%\end{comment}
%
%\section{Proofs}~\\
%
%\begin{proof}[Proof of Lemma \ref{lemma:agt-ol-eval} - Consistent Formula Evaluation]~\\
%    Goal:
%    $$\exists \phi \in \gamma(\gphi).~ \evalphiGen{\rho}{\phi} \iff \evalphiGen{\rho}{\static{\gphi}}$$
%
%    \begin{description}
%        \item[Case $\gphi$ precise ($\gphi = \phi'$)]
%        It follows from definition of $\gamma$ and $\predicate{static}$ (section \ref{ssec:interpret-grad-frm}) that $\gamma(\gphi) = \{ \phi' \}$ and that $\static{\gphi} = \phi'$
%        The goal trivially holds.
%
%        \item[Case $\gphi$ precise ($\gphi = \withqmGen{\phi'}$)]
%        Applying the definitions, the goal becomes:
%        \begin{displaymath}
%        \exists \phi \in \setFormulaA.~ \phiImplies{\phi}{\phi'} \wedge \evalphiGen{\rho}{\phi} \iff \evalphiGen{\rho}{\phi'}
%        \end{displaymath}
%
%        \begin{description}
%        \item[Case $\implies$]~\\
%        Given: $\phiImplies{\phi}{\phi'} ~\wedge~ \evalphiGen{\rho}{\phi}$
%
%        By definition of implication (Def. \ref{def:form-implication}),  $\evalphiGen{\rho}{\phi}$ implies $\evalphiGen{\rho}{\phi'}$.
%
%        \item[Case $\impliedby$]~\\
%        Instantiate the existential with $\phi'$.
%        Implication is reflexive.
%        \end{description}
%    \end{description}
%\end{proof}
%
%
%% Consistent Formula Implication
%\begin{proof}[Proof of Lemma \ref{lemma:agt-ol-eval} - Consistent Formula Implication]~\\
%    Goal:
%    $$\gphiImplies{\gphi_1}{\gphi_2} \iff \exists \phi_1 \in \gamma(\gphi_1), \phi_2 \in \gamma(\gphi_2).~ \phiImplies{\phi_1}{\phi_2}$$
%    where $\gphiImplies{}{}$ is defined as in Def. \ref{def:gvl-impl}.
%
%    \begin{description}
%        \item[Case $\gphi_1$ precise ($\gphi_1 = \phi'$)]
%        Applying the definitions to the goal and simplifying:
%        $$\phiImplies{\phi'}{\static{\gphi_2}} \iff \exists \phi_2 \in \gamma(\gphi_2).~ \phiImplies{\phi'}{\phi_2}$$
%
%        For precise $\gphi_2$, the goal trivially holds. For $\gphi_2 = \withqmGen{\phi''}$ with $\phi'' \in \setFormulaA$ we get
%
%        $$\phiImplies{\phi'}{\phi''} \iff \exists \phi_2 \in \setFormulaA.~ \phiImplies{\phi'}{\phi_2} \wedge \phiImplies{\phi_2}{\phi''}$$
%
%        \begin{description}
%            \item[Case $\implies$]~\\
%            One can instantiate $\phi_2$ with $\phi''$.
%
%            \item[Case $\impliedby$]~\\
%            Holds due to transitivity of implication.
%        \end{description}
%    \end{description}
%\end{proof}
%
%\begin{proof}[Proof of Lemma \ref{lemma:agt-wlp} - Consistent $\WP$]~\\
%	The cases (for the different statements) can be calculated by starting with the formal definition of the consistent lifting and simplifying it further and further.
%	We demonstrate this with the rule for assertions:
%	\begin{align*}
%&\gWP(\sAssert{\phi_a}, \gphi)\\
%=~& \alpha(\{~ \WP(\sAssert{\phi_a}, \phi) ~|~ \phi \in \gamma(\gphi) ~\})\\
%=~& \alpha(\{~ \phiAnd{\phi_a}{\phi} ~|~ \phi \in \gamma(\gphi) ~\})\\
%=~& \alpha(\{~ \phi ~|~ \phi \in \gamma(\phiAnd{\phi_a}{\gphi}) ~\})\\
%=~& \alpha(\gamma(\phiAnd{\phi_a}{\gphi}))\\
%=~& \phiAnd{\phi_a}{\gphi}\\
%	\end{align*}
%\end{proof}
%
%\begin{lemma}[Partial Galois connection]
%	Abstraction $\alpha$ (Def. \ref{def:abstraction}) and concretization $\gamma$ (Def. \ref{def:concretization}) form a partial Galois connection $\langle \alpha, \gamma \rangle$.
%\end{lemma}
%\begin{proof}~\\
%	\begin{enumerate}
%		\item Goal: If $\alpha(\overline{\phi})$ is defined, then $\overline{\phi} \subseteq \gamma(\alpha(\overline{\phi}))$
%
%		Follows directly from Def. \ref{def:abstraction} (see set predicate).
%
%		\item Goal: If $\alpha(\overline{\phi})$ is defined, then $\overline{\phi} \subseteq \gamma(\grad{\phi})$ implies $\alpha(\overline{\phi}) \mpt \grad{\phi}$
%
%		Follows directly from Def. \ref{def:abstraction} (see $\underset{\mpt}{\min}$).
%	\end{enumerate}
%\end{proof}
%
%\begin{proof}[Proof: Dynamic semantics with residual checks is equivalent with full checks]\label{proof:residual-checks}~\\
%	\begin{description}
%		\item[\tset{\gradT SsLocal}]
%		Reduction in question: $$\gsstep
%		{\langle \rho'_n, (\sSeq{s}{s_n}) \rangle \cdot ...}
%		{\langle \rho_n, s_n \rangle \cdot ...}$$
%
%		The naive semantics proposes to perform the following check:
%		$$\evalgphiGen{\rho_n}{\gphi} \text{ where } \gphi = \sgWP_n(s_n \cdot ... \cdot s_1 \cdot \nil, \phiTrue)$$
%		Note that the state we leave must have been valid, so we know that
%		$$\evalgphiGen{\rho'_n}{\sgWP_n(\sSeq{s}{s_n} \cdot ... \cdot s_1 \cdot \nil, \phiTrue)}$$
%		holds, which we can rewrite as:
%		$$\evalgphiGen{\rho'_n}{\gWP(s, \gphi)}$$
%
%		By definition of $\gSP$, it must be true that
%		$$\evalgphiGen{\rho_n}{\gSP(s, \gWP(s, \gphi))}$$
%		\ie this is knowledge we can use to {\em simplify} the full check $\evalgphiGen{\rho_n}{\gphi}$ as:
%		$$\evalgphiGen{\rho_n}{\gdiff(\gphi, \gSP(s, \gWP(s, \gphi)))}$$
%
%		By definition of $\gdiff$, $\gdiff(\gphi_a, \gphi_b)$ vanishes (becomes $\phiTrue$ or $\qm$) if $\static{\gphi_b}$ implies $\static{\gphi_a}$. % helping lemma!?
%		In the following we show that this is true in the above case, \ie $\phiImplies{\static{\gSP(s, \gWP(s, \gphi))}}{\gphi}$
%
%		By definition of $\SP$, we know that $\phiImplies{\SP(s, \WP(s, \phi))}{\phi}$ for all $\phi$.
%		Since $\phi$ and all intermediate results are precise (note that $s$ may not be a call, so there may also be no imprecise method contracts involved), this is equivalent to $\phiImplies{\gSP(s, \gWP(s, \phi))}{\phi}$.
%		We instantiate $\phi = \static{\gphi}$:
%		$$\phiImplies{\gSP(s, \gWP(s, \static{\gphi}))}{\static{\gphi}}$$
%
%		This coincides with the goal since $\gWP(s, \static{\gphi}) = \static{\gWP(s, \gphi)}$ and $\gSP(s, \static{\gphi}) = \static{\gSP(s, \gphi)}$.
%
%		\item[\tset{\gradT SsCall}]
%		Reduction in question: $$\gsstep
%		{\langle \rho_{n-1}, (\sSeq{\sInvoke{y}{m}{x}}{s_{n-1}}) \rangle \cdot ...}
%		{\langle \rho_n, \mbody{m} \rangle \cdot ...}$$
%
%		The naive semantics proposes to perform the following check:
%		$$\evalgphiGen{\rho_n}{\gphi} \text{ where } \gphi = \sgWP_n(\mbody{m} \cdot ..., \phiTrue) = \gWP_n(\mbody{m}, \mpost{m})$$
%
%		$\sstep{}{}$ checks for $\mpre{m}$ which can hence be assumed, so the check may be reduced to $\gdiff(\gWP(\mbody{m}, \mpost{m}), \mpre{m})$.
%
%		We later claim that this check vanishes if $\mpre{m}$ is precise.
%		This is due to the fact that the static checker checks $\gphiImplies{\mpre{m}}{\gWP(\mbody{m}, \mpost{m})}$.
%		If $\mpre{m}$ is precise we know that also $\gphiImplies{\static{\mpre{m}}}{\gWP(\mbody{m}, \mpost{m})}$ holds, which causes\\ $\gdiff(\gWP(\mbody{m}, \mpost{m}), \mpre{m})$ to vanish.
%
%		\item[\tset{\gradT SsCallFinish}]
%		The approach is the same as before, however $\phiImplies{\gSP(s, \gWP(s, \phi))}{\phi}$ does not necessarily hold if $s$ is a call with imprecise contract.
%		As a result,\\ $\evalgphiGen{\rho_n}{\gdiff(\gphi, \gSP(s, \gWP(s, \gphi)))}$ may not vanish and is hence the runtime assertion check we propose.
%
%		However, we later claim that this check vanishes for precise postcondition and otherwise equals the much simpler
%		$$\evalgphiGen
%		{\rho_n}
%		{\gdiff(\gdiff(\gphi, \mpre{m}[x/\mparam{m}]), \mpost{m}[x,y/\phiOld{\mparam{m}},\eresult])}$$
%
%		We calculate $\gSP(s, \gWP(s, \gphi))$ explicitly for $s = \sInvoke{y}{m}{x}$ to derive these claims.
%
%		First, we simplify $\SP(\sInvoke{y}{m}{x}, \phi)$ as far as possible:
%		\begin{small}
%		\begin{align*}
%			&\SP(s, \phi) \\
%			=~&\minimp \{~ \phi' \in \setFormula ~|~ \phiImplies{\phi}{\WP(\sInvoke{y}{m}{x}, \phi')} ~\}\\
%			=~&\minimp \{~ \phi' \in \setFormula ~|~ \phiImplies{\phi}{\maximp~ \{~ \phi'' ~|~
%				y \not \in \FV(\phi'')~\wedge~
%				(\phiImplies{\phi''}{\mpre{m}[x/\mparam{m}]})  }\\&~\wedge~
%				(\phiImplies{\phiAnd{\phi''}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\phi'}) ~\} ~\}\\
%			=~&\minimp \{~ \phi' \in \setFormula ~|~ \phiImplies{\phi}{\phi''} ~\wedge~
%				y \not \in \FV(\phi'')~\wedge~
%				(\phiImplies{\phi''}{\mpre{m}[x/\mparam{m}]}) \\&~\wedge~
%				(\phiImplies{\phiAnd{\phi''}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\phi'}) ~\}\\
%			=~&\minimp \{~ \phiAnd{\phi''}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]} ~|~ (\phiImplies{\phi}{\phi''}) ~\wedge~
%			y \not \in \FV(\phi'')  \\&~\wedge~
%			(\phiImplies{\phi''}{\mpre{m}[x/\mparam{m}]}) ~\}
%		\end{align*}
%		\end{small}
%
%		We further calculate (assuming that $\gWP(s, \gphi)$ is imprecise; if it was precise, neither $\gphi$ nor the method contract was precise, so rules of \svl apply which require no additional checks in the first place):
%		\begin{small}
%		\begin{align*}
%			&\gSP(s, \gWP(s, \gphi))\\
%			=~& \alpha(\{~ \minimp \{~ \phiAnd{\phi''}{\phi_q} ~|~ (\phiImplies{\phi}{\phi''}) ~\wedge~
%				y \not \in \FV(\phi'')~\wedge~
%				\phiImplies{\phi''}{\phi_p} ~\} ~|~ \phi \in \gamma(\gWP(s, \gphi)),\\ &\quad\quad \phi_p \in \gamma(\mpre{m}[x/\mparam{m}]), \phi_q \in \gamma(\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]) ~\})
%			\\
%			=~& \alpha(\{~ \minimp \{~ \phiAnd{\phi''}{\phi_q} ~|~ (\phiImplies{\phi}{\phi''}) ~\wedge~
%			y \not \in \FV(\phi'')~\wedge~
%			\phiImplies{\phi''}{\phi_p} ~\} ~|~ \phi \phiImplies{}{} \\&\quad \maximp~ \{~ \phi' ~|~
%			y \not \in \FV(\phi')~\wedge~
%			(\gphiImplies{\phi'}{\mpre{m}[x/\mparam{m}]})  \\&\quad\quad\quad\quad\quad ~\wedge~
%			(\gphiImplies{\phiAnd{\phi'}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\gphi}) ~\}, \\ &\quad\quad \phi_p \in \gamma(\mpre{m}[x/\mparam{m}]), \phi_q \in \gamma(\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]) ~\})
%			\\
%			%= \alpha(\{~ \minimp \{~ \phiAnd{\phi''}{\phi_q} ~|~ \phiImplies{\phi}{\phi''} ~\wedge~
%			%y \not \in \FV(\phi'')~\wedge~
%			%\phiImplies{\phi''}{\phi_p} ~\} ~|~ \phi \phiImplies{}{} \maximp~ \{~ \phi' ~|~
%			%y \not \in \FV(\phi')~\wedge~
%			%\gphiImplies{\phi'}{\mpre{m}[x/\mparam{m}]}~\wedge~
%			%\gphiImplies{\phiAnd{\phi'}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\gphi} ~\}, \phi_p \in \gamma(\mpre{m}[x/\mparam{m}]), \phi_q \in \gamma(\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]) ~\})
%			=~& \alpha(\{~ \minimp \{~ \phiAnd{\phi''}{\phi_q} ~|~ (\phiImplies{\phi}{\phi''}) ~\wedge~
%			y \not \in \FV(\phi'')~\wedge~
%			(\phiImplies{\phi''}{\phi_p}) ~\} ~|~ \phiImplies{\phi}{\phi'} ~\wedge~
%			y \not \in \FV(\phi') \\&\quad\quad~\wedge~
%			(\gphiImplies{\phi'}{\mpre{m}[x/\mparam{m}]})~\wedge~
%			(\gphiImplies{\phiAnd{\phi'}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]})}{\gphi}, \\ &\quad\quad \phi_p \in \gamma(\mpre{m}[x/\mparam{m}]), \phi_q \in \gamma(\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]) ~\})
%			\\
%			=~& \alpha(\{~ \minimp \{~ \phiAnd{\phi''}{\phi_q} ~|~ (\phiImplies{\phi}{\phi''}) ~\wedge~
%			(\phiImplies{\phi''}{\phi_p}) ~\} ~|~
%			y \not \in \FV(\phi) \\&\quad\quad~\wedge~
%			(\gphiImplies{\phiAnd{\phi}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\gphi}), \\ &\quad\quad \phi_p \in \gamma(\mpre{m}[x/\mparam{m}]), \phi_q \in \gamma(\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]) ~\})
%			\\
%			=~& \alpha(\{~ \phiAnd{\phi}{\phi_q} ~|~ (\phiImplies{\phi}{\phi_p})~\wedge~
%			y \not \in \FV(\phi) \\&\quad\quad~\wedge~
%			(\gphiImplies{\phiAnd{\phi}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\gphi}), \\ &\quad\quad \phi_p \in \gamma(\mpre{m}[x/\mparam{m}]), \phi_q \in \gamma(\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]) ~\})
%			\\
%			=~& \alpha(\{~ \phiAnd{\phi}{\static{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}} ~|~ (\phiImplies{\phi}{\static{\mpre{m}[x/\mparam{m}]}})~\wedge~ \\&\quad\quad~\wedge~
%			y \not \in \FV(\phi) ~\wedge~ (\gphiImplies{\phiAnd{\phi}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\gphi}) ~\})
%			\\
%			=~& \alpha(\{~ \phiAnd{\phi}{\phiAnd{\static{\mpre{m}[x/\mparam{m}]}}{\static{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}} \\&\quad\quad\;~|~
%			y \not \in \FV(\phi) ~\wedge~ (\gphiImplies{\phiAnd{\phi}{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}{\static{\gphi}}) ~\})
%			\\
%			=~&\!
%			\begin{cases}
%				\withqmGen{\phiAnd{\phiAnd{\static{\mpre{m}[x/\mparam{m}]}\!}{\!\static{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}\!}{\!\static{\gphi}}} \\ \quad \quad \quad \quad \text{if $\mpost{m}$ precise} \\
%				\withqmGen{{\phiAnd{\static{\mpre{m}[x/\mparam{m}]}\!}{\!\static{\mpost{m}[x,y/\phiOld{\mparam{m}},\eresult]}}}} \\ \quad \quad \quad \quad \text{otherwise} \\
%			\end{cases}
%		\end{align*}
%		\end{small}
%
%		The first case causes the check to vanish since $\static{\gphi}$ itself is part of $\gSP(s, \gWP(s, \gphi))$.
%		The second check translates to the proposed residual check.
%	\end{description}
%\end{proof}
%
%\begin{proof}[Proof of Lemma \ref{lemma:gvl-sound} - Soundness of \gvl]\label{proof:soundness}~\\
%	\begin{description}
%		\item[Progress]
%		We are given a valid state $\pi \in \setProgramState$.
%		Soundness of \svl implies that $\sstep{}{}$ will step.
%		(Note that we have modified $\sstep{}{}$ to deal with imprecise contracts by resorting to consistent formula evaluation. However, the introduction of imprecision can only ever increase the chances that formula evaluation succeeds and hence a reduction is performed.)
%		Therefore, $\gsstep{}{}$ will also step by definition.
%		\item[Preservation]
%		$\gsstep{}{}$ either steps to the error state or the state stepped to by $\sstep{}{}$.
%		The error state trivially satisfies preservation (see Lemma \ref{lemma:gvl-sound}).
%		We only step to the non-error state if the preservation condition (validity of the resulting state) holds since we explicitly check for it.
%	\end{description}
%\end{proof}
%
%\begin{proof}[Proof of Prop. \ref{prop:gvlidf-static-gg} - Static Gradual Guarantee]~\\
%	Validity of functions and programs relies on consistent implication and consistent $\WP$.
%	By construction, increasing the imprecision of the arguments of $\WP$ increases the imprecision of the result.
%	Likewise, consistent implication becomes or remains satisfied if the imprecision of its arguments increases.
%	As a result, if the static checker accepts a program, it will still accept it after increasing the imprecision of method contracts.
%\end{proof}
%
%\begin{proof}[Proof of Prop. \ref{prop:gvlidf-dynamic-gg} - Dynamic Gradual Guarantee]\label{proof:dgg}~\\
%	We analyze the definition of $\gsstep{}{}$.
%	Increasing imprecision of contracts will increase the imprecision of $\sgWP$ and hence increase the chances that that the non-error case applies.
%	Hence, if $\pi ~\gsstepArrow_{p_1}~ \pi'_1$ (for some $\pi'_1 \in \setProgramState$) then $\pi ~\gsstepArrow_{p_2}~ \pi'_2$ (for some $\pi'_2 \in \setProgramState$).
%	Since the non-error case draws its result from $\sstep{}{}$, we focus on it to prove $\pi'_1 = \pi'_2$.
%	In fact, by definition of $\sstep{}{}$, {\em if} all premises are satisfied, the resulting state is never influenced by method contracts, they merely influence whether a reduction may take place or not.
%	As a result, identical states that are known to successfully reduce must again result in identical states.
%\end{proof}
%
%\begin{proof}[Proof of Prop. \ref{cor:gvl-pay-as-you-go} - Pay-as-you-go overhead]~\\
%	\gvl checks the runtime assertions
%	\begin{small}
%	$$\gdiff(\gWP(\mbody{m}, \mpost{m}), \mpre{m})$$
%	\end{small}
%	and
%	\begin{small}
%	$$\gdiff(\gdiff(\sgWP_n(s_n \cdot ..., \phiTrue), \mpre{m}[x/\mparam{m}]), \mpost{m}[x,y/\phiOld{\mparam{m}},\eresult])$$
%	\end{small}
%	(see section \ref{sec:gvl-residual-checks}).
%	In proof \ref{proof:residual-checks} we have shown that these checks vanish in a completely precise setting, \ie $\predicate{checksize}(p) = 0$
%	The assertions above depend on pre- and postconditions in a way that they grow as contracts get more and more imprecise.
%	Specifically, $\predicate{size}(\gdiff(\gphi, \gphi_1)) \le \predicate{size}(\gdiff(\gphi, \gphi_2))$ if $\gphi_1 \mpt \gphi_2$.
%	As a result, increasing precision of contracts in $p$ may cause $\predicate{checksize}(p)$ to increase.
%\end{proof}
%
%\begin{proof}[Proof of Prop. \ref{prop:ggvlidf-dynamic-gg} - Dynamic Gradual Guarantee]~\\
%	We check the goal for each reduction rule.
%	\begin{description}
%		\item[\tset{\gradT SsLocal}]
%		$\pi_1$ is more precise than $\pi_2$.
%		Hence, if $\sstep{}{}$ can reduce $\pi_1$, then the same is true for $\pi_2$ (the top most stack frame of $\pi_2$ has more access than that of $\pi_1$ which only increases the chance that evaluating formulas succeeds).
%		As a result, also $\gsstep{}{}$ is able to reduce both states, no \error~ may happen.
%		Since footprints are left untouched $\pi'_1 \approxident \pi'_2$ holds.
%
%		\item[\tset{\gradT SsCall}]~\\
%		With the same reasoning as before (see proof \ref{proof:dgg}) we can derive: if $\pi_1 ~\gsstepArrow_{p_1}~ \pi'_1$ (for some $\pi'_1 \in \setProgramState$) then $\pi_2 ~\gsstepArrow_{p_2}~ \pi'_2$ (for some $\pi'_2 \in \setProgramState$)\\
%		$\pi'_1 \approxident \pi'_2$ holds since the footprint forwarded to the top most stack frame is larger in the presence of imprecision.
%
%		\item[\tset{\gradT SsCallFinish}]~\\
%		With the same reasoning as before we can derive: if $\pi_1 ~\gsstepArrow_{p_1}~ \pi'_1$ (for some $\pi'_1 \in \setProgramState$) then $\pi_2 ~\gsstepArrow_{p_2}~ \pi'_2$ (for some $\pi'_2 \in \setProgramState$)\\
%		$\pi'_1 \approxident \pi'_2$ holds since the two top most footprints are merely merged, keeping the invariant satisfied.
%	\end{description}
%\end{proof}
%
%\begin{proof}[Proof of Lemma \ref{lemma:agt-ol-eval} - Consistent Formula Evaluation]~\\
%    Goal:
%    $$\evalgphiGen{m}{\gphi} \iff \exists \sphi \in \gamma(\gphi).~ \evalphiGen{m}{\sphi}$$
%    with $\evalgphiGen{}{}$ defined as in Lemma. \ref{lemma:agt-ol-eval}.
%    \begin{description}
%        \item[Case $\implies$]~\\
%        \begin{description}
%            \item[Case \tset{\gradT EvalStatic}]
%            \begin{align*}
%                \evalgphiGen{m}{\sphi}
%                \implies
%                \evalphiGen{m}{\sphi}
%                \implies
%                \exists \sphi' \in \gamma(\sphi).~ \evalphiGen{m}{\sphi'}
%            \end{align*}
%
%            \item[Case \tset{\gradT EvalGrad}]
%            \begin{align*}
%                &\evalgphiGen{m}{\withqm{\phi}}\\
%                \implies
%                &\exists A \in {static footprint?}.~ \evalphiGen{m}{\phi} ~\wedge~
%                A \sfrmphi \phi ~\wedge~
%                \forall \langle e, f \rangle \in A.~ \evalphiGen{m}{\phiAcc{$e$}{$f$}}
%            \end{align*}
%            The footprint $A$ for which above logical formula holds may reference fields that alias in $m$.
%            There exists an $A' \subseteq A$ in which each set of such aliases is reduced down to one element (say, the one that is lexicographically smallest).
%            At the same time, we define $\phi'$ to be $\phi$, but with all expressions replaced according to above reduction of $A$ to $A'$.
%
%            Example (\ttt{b.x} and \ttt{a.f.x} alias):
%            \begin{align*}
%                \phi &= \phiCons{\phiEq{b}{a.f}}{\phiCons{\phiEq{b.x}{3}}{\phiNeq{a.f.x}{5}}}\\
%                A &= \{ \langle \ttt{a}, \ttt{f} \rangle, \langle \ttt{b}, \ttt{x} \rangle,\langle \ttt{a.f}, \ttt{x} \rangle \}\\
%                ~\\
%                \phi' &= \phiCons{\phiEq{b}{a.f}}{\phiCons{\phiEq{a.f.x}{3}}{\phiNeq{a.f.x}{5}}}\\
%                A' &= \{ \langle \ttt{a}, \ttt{f} \rangle, \langle \ttt{a.f}, \ttt{x} \rangle \}
%            \end{align*}
%
%            As a result, $A'$ still frames $\phi'$ and $\phi'$ is equivalent to $\phi$.
%            Since $A'$ no longer contains aliasing elements, we can extend $\phi'$ with corresponding accessibility predicates, rendering it self-framed.
%
%            From example before: $$\phiCons{\phiCons{\phiAcc{a}{f}}{\phiAcc{a.f}{x}}}{\phiCons{\phiEq{b}{a.f}}{\phiCons{\phiEq{a.f.x}{3}}{\phiNeq{a.f.x}{5}}}}$$
%
%            The resulting formula $\sphi''$ is self-framed, implies $\phi$ and holds in $m$.
%            The goal follows:
%            $\exists \sphi'' \in \gamma(\withqm{\phi}).~ \evalphiGen{m}{\sphi''}$
%
%        \end{description}
%        \item[Case $\impliedby$]~\\
%        Given: $\sphi' \in \gamma(\gphi) \wedge \evalphiGen{m}{\sphi'}$
%        \begin{description}
%            \item[Case $\gphi = \sphi$]
%            \begin{align*}
%                &\sphi' \in \gamma(\sphi) \wedge \evalphiGen{m}{\sphi'}\\
%                \implies
%                &\evalphiGen{m}{\sphi}
%            \end{align*}
%            Apply $\tset{\gradT EvalStatic}$.
%
%            \item[Case $\gphi = \withqm{\phi}$]
%            \begin{align*}
%                &\sphi' \in \gamma(\withqm{\phi}) \wedge \evalphiGen{m}{\sphi'}
%            \end{align*}
%            $\tset{\gradT EvalGrad}$ already applies (with $A = \emptyset$, since $\sphi'$ is self-framed), however it yields $\evalgphiGen{m}{\withqm{\sphi'}}$ instead of $\evalgphiGen{m}{\withqm{\phi}}$.
%
%            Since $\sphi'$ implies $\phi$, the premises of $\tset{\gradT EvalGrad}$ must also be true for $\phi$:
%            Weakening $\phi'$ by dropping access augments $A$, any other form of weakening has no consequences.
%        \end{description}
%    \end{description}
%\end{proof}
%
%\begin{proof}[Proof of soundness of \gvlidf]~\\
%	Proof \ref{proof:soundness} applies as it makes no assumptions that were specific to \gvl, but rather draws conclusions from the strategy used to derive the gradual semantics.
%	The same strategy was used in \gvlidf.
%\end{proof}
%
\end{document}
