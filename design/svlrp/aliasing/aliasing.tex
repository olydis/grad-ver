\section{Aliasing}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Definitions}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

An \tbf{object variable} is one of the following:
\begin{itemize}
  \item a class instance variable i.e. a variable $v$ such that $v : C$ for some class $C$,
  \item a class instance field reference i.e. a field reference $e.f$ where $e.f : C$ for some class $C$,
  \item \cnull \ as a value such that $\cnull : C$ for some class $C$.
\end{itemize}
Let $\O$ be a set of object variables.
An $O \subset \O$ \tbf{aliases} if and only if
each $o \in O$ refers to the same memory in the heap as each other,
written propositionally as
$$
  \forall o, o\p \in O : o = o\p \iff \aliases(O)
$$
While it is possible to keep track of negated aliasings (of the form  $\pnot \aliases\set{ o_\alpha }$), this will not be needed for either aliasing tree construction or self-framing desicions. So, it will not be tracked i.e. $x \neq y$ does not contribute anything to an aliasing context.

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Aliasing Context}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

Let $\phi$ be a formula.
The \tbf{aliasing context} $\A$ of $\phi$ is a tree of set of aliasing proposition about aliasing of object variables that appear in $\phi$.
$\A$ needs to be a tree because the conditional and unfolding sub-formulas that may appear in $\phi$ allow for branching aliasing contexts not expressible flatly at the top level.
In the case of conditionals i.e. sub-formulas of the form $\cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2$, two branches sprout from the original context.
In the case of unfoldings i.e. sub-formulas of the form $\cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi$, one branch sprouts from the original context.
Each node in the tree corresponds to a set of aliasing propositions, and each branch refers to a branch of a unique conditional in $\phi$.
The parts of the tree are labeled in such a way that modularly allows a specified sub-formula of $\phi$ to be matched to the unique aliasing sub-context that corresponds to it.
For example, consider the following formula:
\begin{align*}
  \phi
  :=
  \  & \hspace{0em} (o_1 = o_2) \ \ast
  \\ & \hspace{0em} (\cif \ (b_1)
  \\ & \hspace{1em}    \cthen \ (
  \\ & \hspace{2em}      (o_1 \neq o_3) \ \ast \
  \\ & \hspace{2em}      (\cif \ (b_2)
  \\ & \hspace{3em}        \ \cthen \ (o_1 = o_4) \
  \\ & \hspace{3em}        \ \celse \ (b_3)))
  \\ & \hspace{1em}    \ \celse \ (o_1 = o_3)) \ \ast
  \\ & \hspace{0em} (o_1 = o_4)
\end{align*}
where $b_1, b_2$ are arbitrary boolean expressions that do not assert aliasing propositions.
$\phi$ has a formula-structure represented by the tree in figure~\ref{fig:aliasing-context-formula-example}.
The formula-structure tree for $\phi$ corresponds node-for-node and edge-for-edge to the aliasing context tree in figure~\ref{fig:aliasing-context-example}.
\\
%
\begin{figure}[h!]
  \label{fig:aliasing-context-formula-example}
  \caption{Formula structure tree for $\phi$.}
  \vspace{1em}
  \input{aliasing/aliasing-context-formula-example.tex}
\end{figure}
%
\begin{figure}[h!]
  \label{fig:aliasing-context-example}
  \caption{$\A(\phi)$, the aliasing context tree for $\phi$.}
  \vspace{1em}
  \input{aliasing/aliasing-context-example.tex}
\end{figure}
%
More generally, for $\phi$ a formula and $\phi\p$ a sub-formula of $\phi$, write $\A_\phi(\phi\p)$ as the \tbf{total aliasing context} of $\phi\p$ which includes aliasing propositions inherited from its ancestors in the aliasing context tree of $\phi$. These aliasing contexts are combined via $\contextunion$ which will be defined in the next section.
For example, the total aliasing context at the sub-formula $(o_1 = o_4)$ of $\phi$ is:
\begin{align*}
  \A_\phi(o_1 = o_4) := & \
  \{
    \aliased\set{o_1, o_2, o_4}
  \}
\end{align*}
along with the fact that it has no child branches.
Usually $\A_\phiroot(\phi\p)$ is abbreviated to $\A(\phi\p)$ when the top level formula $\phi$ is implicit and $\phi\p$ is a sub-formula of $\phiroot$.

An aliasing context $\A$ may entail $\aliased(O)$ for some $O \subset \O$.
Since $\A$ is efficiently represented as a set of propositions about sets, it may be the case that $\aliased(O) \not\in \A$ yet still the previous judgement holds.
For example, this is true when $\exists O\p \subset \O$ such that $O \subset O\p$ and $\aliased(O\p) \in \A$. So, the explicit definition for making this judgement is as follows:
\begin{align*}
\A \entails \aliased(O)
\iff
\exists O\p \subset \O : (O \subset O\p) \ \land \ (\aliased(O\p) \in \A)
\end{align*}
The notations $\aliased(O) \in \A$ is a little misleading because $\A$ is in fact a tree and not just a set. To be explicit, $\aliased(O) \in \A$ is defined to be set membership of the set of aliasing propositions in the total aliasing context at $\A$.

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Constructing an Aliasing Context}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

An aliasing context of a formula $\phi$ is a tree, where nodes represent local aliasing contexts and branches represent the branches of conditional sub-formulas nested in $\phi$. So, an aliasing context is defined structurally as
\begin{align*}
  \A \ ::= \context{A}{\set{l_\alpha : \A_\alpha}}
\end{align*}
where $A$ is a set of propositions about aliasing and the $l_\alpha : \A_\alpha$ are the nesting aliasing contexts that correspond to the branches of conditionals and unfoldings directly nested in $\phi$, the $l_\alpha$ being labels for each child context.

Given a root formula $\phi_\tsf{root}$, the aliasing context of $\phi_\tsf{root}$ is written $\A(\phi_\tsf{root})$. With the root invariant, the following recursive algorithm constructs $\A(\phi)$ for any sub-formula of $\phi_\tsf{root}$ (including $\A(\phi_\tsf{root}$)).
%
\begin{align*}
\begin{array}{rclcl}
\A(\phi) &:=& \tsf{match} \ \phi \ \tsf{with} \\
&& v &\mt&
  \context{\empty}{\empty}
\\
&& x &\mt&
  \context{\empty}{\empty}
\\
&& e_1 \ \band \ e_2 &\mt&
  \A(e_1) \contextunion \A(e_2)
\\
&& e_1 \bor e_2 &\mt&
  \A( \cif \ e_1 \ \cthen \ \ctrue \ \celse \ e_2 )
\\
&& e_1 \oplus e_2 &\mt&
  \context{\empty}{\empty}
\\
&& o_1 = o_2 &\mt&
  \context{\set{\aliases\set{o_1, o_2}}}{\empty} % TODO:
\\
&& e_1 \odot e_2 &\mt&
  \context{\empty}{\empty}
\\
&& e.f &\mt&
  \context{\empty}{\empty}
\\
&& \cacc(e.f) &\mt&
  \context{\empty}{\empty}
\\
&& \phi_1 \ast \phi_2 &\mt&
  \A(\phi_1) \contextunion \A(\phi_2)
\\
&& \phi_1 \land \phi_2 &\mt&
  \A(\phi_1) \contextunion \A(\phi_2)
\\
&& \alpha_C(\vec{e}) &\mt&
  \context{\empty}{\empty}
\\
&& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
  \context{\empty}{\set{ e : \A(e) \contextunion \A(\phi_1) ,\ \pnot e : (\A(\pnot e)) \contextunion \A(\phi_2) }}
\\
&& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p &\mt&
  \context{\empty}{\set{ \cunfolding(\alpha_C(\vec{e})) : \A(\tsf{unfold} \ \alpha_C(\vec{e})) \contextunion \A(\phi\p) }}
\end{array}
\end{align*}
%
Note the following:
\begin{itemize}
  \item The $\pnot e$ expression in the result of the rule for $\A(\cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2)$ means to negate the boolean expression of $e$
  \item The $e_1 \bor e_2$ expression is translated into $\cif \ e_1 \ \cthen \ \ctrue \ \celse \ e_2$ for the purpose of aliasing. So, boolean or operations in forumals yield branching just like conditional expressions.
  \item The $\tsf{unfold} \ \alpha_C(\vec{e})$ expression in the result of the rulle for $\A(\cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p)$ is translated to a single unfolding of the body of $\alpha_C(\vec{e})$ with the arguments substituted appropriately.
\end{itemize}
As examples,
\begin{align*}
  \A( \pnot (x =   y) ) = & \ \A(x \neq y) = \context{\empty}{\empty} \\
  \A( \pnot (x\neq y) ) = & \ \A(x =    y) = \context{\set{ \aliased\set{x,y} }}{\empty}
\end{align*}
Context union, $\contextunion$, and context intersection, $\contextintersection$, are operations that combine aliasing contexts and are defined below.
%
\begin{align*}
&
\context{A_1}{\set{ l_\alpha : \A_\alpha }} \contextunion
\context{A_2}{\set{ l_\beta : \A_\beta }} :=
\\ & \hspace{4em}
\langle
  \set{
    \aliased\set{
      o\p
      \mid
      \forall o\p :
      (A_1 \entails \aliased\set{o, o\p}) \ \lor \
      (A_2 \entails \aliased\set{o, o\p}) }
    \mid
    \forall o
  },
\\ & \hspace{4em}
  \set{ l_\alpha : \A_\alpha } \cup \set{ l_\beta : \A_\beta }
\rangle
%
\\[1em]
%
&
\context{A_1}{\set{ l_\alpha : \A_\alpha }} \contextintersection
\context{A_2}{\set{ l_\beta : \A_\beta }} :=
\\ & \hspace{4em}
\langle
  \set{
    \aliased\set{
      o\p
      \mid
      \forall o\p :
      (A_1 \entails \aliased\set{o, o\p}) \ \land \
      (A_2 \entails \aliased\set{o, o\p}) }
    \mid
    \forall o
  },
\\ & \hspace{4em}
  \set{ l_\alpha : \A_\alpha } \cap \set{ l_\beta : \A_\beta }
\rangle
\end{align*}

% TODO: remove section since now don't track non-aliases?
% \subsection{Inconsistent Aliasing Contexts}
%
% As defined, it is possible for inconsistent aliasing contexts to arise. As a simple example, the formula $\phi := x = y \ \band \ x \neq y$ would yield the aliasing context
% \begin{align*}
%   \A(\phi) = & \
%   \A(x = y) \contextunion \A(x \neq y \\ = & \
%   \context{\set{ \aliased\set{x,y} }} \empty \ \contextunion \
%   \context{\set{ \pnot \aliased\set{x,y} }} \empty \\ = & \
%   \context{\set{ \aliased\set{x,y}, \pnot \aliased\set{x,y} }} \empty.
% \end{align*}
% An inconsistent aliasing context is unsatisfiable, so if such an aliasing context arises then the root formula is considered not well-formed, and an \tsf{Inconsistent aliasing context} exception is raised. This causes an error rather than just treats the formula as unsatisfiable. Thus, framing, satisfiability, and so on can be decided under the assumption that all aliasing contexts are consistent.
