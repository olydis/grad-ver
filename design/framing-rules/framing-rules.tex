\documentclass{article}

\usepackage[letterpaper, margin=1.0in]{geometry}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{titling}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}

\setlength{\droptitle}{-2em}
\title{Framing Rules}
\author{Henry Blanchette}
\date{}

\newcommand{\tsf}{\textsf}
\newcommand{\tit}{\textit}
\newcommand{\tbf}{\textbf}
\newcommand{\ttt}{\texttt}
\newcommand{\access}{\tsf{access}}
\newcommand{\assume}{\tsf{assume}}
\newcommand{\footprint}[1]{\lfloor #1 \rfloor}
\newcommand{\frames}{\vDash_I}
\newcommand{\selfframes}{\vdash_{\tsf{frm}I}}
\newcommand{\selfframeswith}[1]{\vdash^#1_{\tsf{frm}I}}
\newcommand{\mt}{\mapsto}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\cast}{\circledast}
\renewcommand{\vec}{\overline}
\newcommand{\p}{^\prime}
\renewcommand{\empty}{\varnothing}
\newcommand{\entails}{\vdash}
\newcommand{\pnot}{\sim}

% code keywords
\newcommand{\cif}{\ttt{if}}
\newcommand{\cthen}{\ttt{then}}
\newcommand{\celse}{\ttt{else}}
\newcommand{\cacc}{\ttt{acc}}
\newcommand{\cunfolding}{\ttt{unfolding}}
\newcommand{\cin}{\ttt{in}}
\newcommand{\bor}{\mid\mid}
\newcommand{\band}{\&\&}

% formal keywords
\newcommand{\id}{\tit{id}}
\newcommand{\aliasing}{\tsf{aliasing}}
\newcommand{\unique}{\tsf{unique}}
\newcommand{\consistent}{\tsf{consistent}}
\newcommand{\granted}{\tsf{granted}}
\newcommand{\grantedPi}{\granted_\Pi}
\newcommand{\notgranted}{\tsf{not-granted}}
\newcommand{\notgrantedPi}{\notgranted_\Pi}
\newcommand{\required}{\tsf{required}}
\newcommand{\requiredPi}{\required_\Pi}

\newcommand{\aliases}{\tsf{aliases}}
\newcommand{\aliasesPi}{\aliases_\Pi}
\newcommand{\nonaliases}{\tsf{non-aliases}}
\newcommand{\nonaliasesPi}{\nonaliases_\Pi}

\newcommand{\merge}{\sqcup}
\newcommand{\overlap}{\sqcap}

\newcommand{\accessed}{\tsf{accessed}}
\newcommand{\assumed}{\tsf{assumed}}
\newcommand{\aliased}{\tsf{aliased}}

\newcommand{\unaliases}{\tsf{undermined-aliases}}
\newcommand{\compatible}{\uplus}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\begin{document}
%-----------------------------------------------------------------------------------------------------------------------------

\maketitle

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\section{Definitions}

\textit{Note:} in this document ``formula'' refers to ``precise formula,'' however gradual formulas will eventually be supported.

\noindent
A \textbf{permission} is to either access a field, written $\access(e.f)$, or to assume a predicate holds of its arguments, written $\assume(\alpha_C(\vec{e}))$.

\noindent
A formula $\phi$ \textbf{requires} a permission $\pi$ if $\phi$ contains an access or assumption that $\pi$ premits. The set of all permissions that $\phi$ requires (the set of permissions required to frame $\phi$) is called the \textbf{requirements} of $\phi$.

\noindent
A formula $\phi$ \textbf{grants} permission $\pi$ if it contains an adjuct that yields $\pi$.

\noindent
A set of permissions $\Pi$ \textbf{frames} a formula $\phi$ if and only if $\phi$ requires only permissions contained in $\Pi$, written $$ \Pi \frames \phi. $$

\noindent
The \textbf{footprint} of a formula $\phi$ is the smallest permission mask that frames $\phi$, written $$ \footprint \phi. $$

\noindent
A formula $\phi$ is \textbf{self-framing} if and only if for any set of permissions $\phi$, $\Pi \frames \phi$, written $$ \selfframes \phi. $$
In other words, $\phi$ is self-framing if and only if it grants all the permissions that it requires.

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Framing without Aliasing}

For this section framing desicions do not consider aliasing, for the sake of an introduction.

\subsection{Deciding Framing without Aliasing}

\noindent
The following algorithm decides $\Pi \frames \phi$ for a given set of permissions $\Pi$ and formula $\phi$.
\begin{align*}
\begin{array}{r|lrl}
\Pi \frames \phi
\iff \tsf{match} \ \phi \ \tsf{with}
%
% expressions
%
& v, x                &\mt& \top
\\
& e_1 \oplus e_2      &\mt& \Pi \frames e_1, e_2
\\
& e_1 \odot e_2       &\mt& \Pi \frames e_1, e_2
\\
& e.f                 &\mt& \Pi \frames e
                      \land \cacc(e.f) \in \Pi
\\
% formulas
%
& \cacc(e.f)          &\mt& \Pi \frames e
\\
% ordered version
% & \phi_1 \cast \phi_2 &\mt& \Pi \frames \phi_1
%                       \land \Pi \cup \granted(\phi_1) \frames \phi_2
% unordered version
& \phi_1 \cast \phi_2 &\mt& \Pi \cup \tsf{granted}(\phi_1 \cast \phi_2) \frames \phi_1, \phi_2
\\
& \alpha_C(\vec{e})   &\mt& \Pi \frames \vec{e}
\\
& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
                      &\mt& \Pi \frames e, \phi_1, \phi_2
\\
& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi
                      &\mt& \assume(\alpha_C(\vec{e})) \in \Pi
                      \land \Pi \frames \alpha_C(\vec{e})
                      \land \Pi \frames \phi
\end{array}
\end{align*}

\noindent
The following algorithm collects the set of permissions granted by a given formula $\phi$.
\begin{align*}
\begin{array}{r|lrl}
\granted(\phi)
:= \tsf{match} \ \phi \ \tsf{with}
%
% expressions
%
& e &\mt& \empty
\\
%
% formulas
%
& \cacc(e.f)          &\mt& \set{ \access(e.f) }
\\
& \phi_1 \cast \phi_2 &\mt& \granted(\phi_1)
                      \cup  \granted(\phi_2)
\\
& \alpha_C(\vec{e})   &\mt& \set{ \assume(\alpha_C(\vec{e})) }
\\
& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
                      &\mt& \granted(\phi_1) \cap \granted(\phi_2)
\\
& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi
                      &\mt& \granted(\phi)
\end{array}
\end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Notes}

\begin{itemize}
\item The conditional expression $e$ in a formula of the form $(\cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2)$ is considered indeteminant for the purposes of statically deciding framing.

\item The body formula $\phi$ in a formula of the form $(\cunfolding \ \cacc_C(\vec{e})) \ \cin \ \phi)$ does not have to make use of the $\assume(\cacc_C(\vec{e}))$ required by the structure.
\end{itemize}

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Deciding Self-Framing without Aliasing}

\noindent
The following algorithm decides $\selfframes \phi$ for a given formula $\phi$.
\begin{align*}
\selfframes \phi \iff \empty \frames \phi
\end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Aliasing}

Let $I$ be the set of identifiers.
A pair of identifiers $x,y \in I$ are \tbf{unique} if they are not the same identifier.
The proposition that $x,y$ are unique is written $\unique(x,y)$ (note that this is importantly different notation from $x=y$).
The proposition that two identifiers refer to the same memory in the heap is written $x = y$.
A set of identifiers $\set{ x_\alpha }$ is \tbf{aliasing} if and and only if each $x_\alpha$ refers to the same memory in the heap i.e.
$$
x_{\alpha_1} = \cdots = x_{\alpha_k} \ \text{where} \ \set{\alpha} = \set{\alpha_1, \dots, \alpha_k}.
$$
The proposition that $\set{ x_\alpha }$ is aliasing is written $\aliasing \set{ x_\alpha }$.

An \tbf{aliasing context} is a set $A$ of aliasing propositions.
As a set of propositions, the consistency of $A$ can be considered.
Explicitly, $A$ is consistent if and only if
$$
\nexists x,y \in I : \unique(x,y) \land A \entails \aliasing \set{x,y} \land \pnot \aliasing \set{x,y}
$$
The proposition that $A$ is consistent is written $\consistent(A)$.

An alias context is \tbf{overlapping} if and only if there exist at least two unique sets of identifiers such that they have a non-empty intersection and both are asserted aliasing in $A$ i.e.
$$
\exists I_1, I_2 \subset I
:     (I_1 \neq I_2)
\land (I_1 \cap I_2 \neq \empty)
\land (\aliasing (I_1) \in A)
\land (\aliasing (I_2) \in A)
$$
An overlapping alias context is inefficient for deciding the propositions that it entails.
Fortunately the framing-deciding algorthm I present ensures that its tracked alias context never becomes becomes overlapping.

A alias context $A$ is \tbf{full} if and only if
$$
\forall I_\alpha \subset I
:
A \entails P(I_\alpha) \implies \exists \ P(I_{\alpha\p}) \in A : I_\alpha \subset I_{\alpha\p}
$$
where $P$ is an aliasing predicate (either \aliasing \ or $\pnot\aliasing$).
In other words, a full alias context is the most efficient representation of its total propositional strength.
Note that, of course, a full alias context that contains $\aliasing\set{x}$ need not contain $\pnot \pnot \aliasing\set{x}, \pnot \pnot \pnot \pnot \aliasing\set{x}, \dots$ although it does indeed entail these propositions.
This is useful for efficient computation, as demonstrated in the following.

Given $A$ an alias context and $x \in I$ an identifier, define:
\begin{align*}
  \tsf{aliases-of}(x)
  := & \
  \text{the largest set such that} \
  x \in \tsf{aliases-of}(x) \land A \entails \aliasing (\tsf{aliases-of}(x))
  \\
  \tsf{not-aliases-of}(x)
  := & \
  \text{the largest set such that} \
  \forall x\p \in \tsf{not-aliases-of}(x) : A \entails \pnot \aliasing\set{x,y\p}
\end{align*}
If $A$ is non-overlapping and full,
the computation of $\tsf{aliases-of}(x)$ is simply the extraction from $A$ the proposition that asserts aliasing of a set of identifiers that contains $x$
and the computation of $\tsf{not-aliases-of}(x)$ is the collection of all identifiers other than $x$ mentioned in propositions of $A$ that assert the negation of aliasing with $x$. For example,
$$
A := \set{ \aliasing\set{x,y}, \aliasing\set{z}, \pnot\aliasing\set{x,z}, \pnot\aliasing\set{y,z} }
$$
$$
\begin{array}{c|c|c}
\tit{id} & \tsf{aliases-of}(\tit{id}) & \tsf{not-aliases-of}(\tit{id})
\\ \hline
x & \set{x,y} & \set{z} \\
y & \set{x,y} & \set{z} \\
z & \set{z}   & \set{x,y}
\end{array}
$$

% TODO: define alias context merging and overlapping (for union and intersection used in the deciding framing with aliasing algorithm)

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Framing with Aliasing}

\input{framing-rules-aliasing.tex}

%-----------------------------------------------------------------------------------------------------------------------------
\end{document}
%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
