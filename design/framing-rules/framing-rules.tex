\documentclass{article}

\usepackage[letterpaper, margin=1.5in]{geometry}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{titling}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}

\setlength{\droptitle}{-2em}
\title{Framing Rules}
\author{Henry Blanchette}
\date{}

\newcommand{\tsf}{\textsf}
\newcommand{\tit}{\textit}
\newcommand{\tbf}{\textbf}
\newcommand{\ttt}{\texttt}
\newcommand{\access}{\tsf{access}}
\newcommand{\assume}{\tsf{assume}}
\newcommand{\footprint}[1]{\lfloor #1 \rfloor}
\newcommand{\frames}{\vDash_I}
\newcommand{\selfframes}{\vdash_{\tsf{frm}I}}
\newcommand{\selfframeswith}[1]{\vdash^#1_{\tsf{frm}I}}
\newcommand{\mt}{\mapsto}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\cast}{\circledast}
\renewcommand{\vec}{\overline}
\newcommand{\p}{^\prime}
\renewcommand{\empty}{\varnothing}
\newcommand{\entails}{\vdash}
\newcommand{\pnot}{\sim}

% code keywords
\newcommand{\cif}{\ttt{if}}
\newcommand{\cthen}{\ttt{then}}
\newcommand{\celse}{\ttt{else}}
\newcommand{\cacc}{\ttt{acc}}
\newcommand{\cunfolding}{\ttt{unfolding}}
\newcommand{\cin}{\ttt{in}}

% formal keywords
\newcommand{\id}{\tit{id}}
\newcommand{\aliasing}{\tsf{aliasing}}
\newcommand{\unique}{\tsf{unique}}
\newcommand{\consistent}{\tsf{consistent}}

\newcommand{\merge}{\sqcap}
\newcommand{\overlap}{\sqcup}

\newcommand{\available}{\tsf{available}}

\newcommand{\granted}{\tsf{granted}}
\newcommand{\aliased}{\tsf{aliased}}

\newcommand{\aliases}{\tsf{aliases}}
\newcommand{\nonaliases}{\tsf{non-aliases}}
\newcommand{\unaliases}{\tsf{undermined-aliases}}
\newcommand{\compatible}{\uplus}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\begin{document}
%-----------------------------------------------------------------------------------------------------------------------------

\maketitle

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\section{Definitions}

\textit{Note:} in this document ``formula'' refers to ``precise formula,'' however gradual formulas will eventually be supported.

\noindent
A \textbf{permission} is to either access a field, written $\access(e.f)$, or to assume a predicate holds of its arguments, written $\assume(\alpha_C(\vec{e}))$.

\noindent
A formula $\phi$ \textbf{requires} a permission $\pi$ if $\phi$ contains an access or assumption that $\pi$ premits. The set of all permissions that $\phi$ requires (the set of permissions required to frame $\phi$) is called the \textbf{requirements} of $\phi$.

\noindent
A formula $\phi$ \textbf{grants} permission $\pi$ if it contains an adjuct that yields $\pi$.

\noindent
A set of permissions $\Pi$ \textbf{frames} a formula $\phi$ if and only if $\phi$ requires only permissions contained in $\Pi$, written $$ \Pi \frames \phi. $$

\noindent
The \textbf{footprint} of a formula $\phi$ is the smallest permission mask that frames $\phi$, written $$ \footprint \phi. $$

\noindent
A formula $\phi$ is \textbf{self-framing} if and only if for any set of permissions $\phi$, $\Pi \frames \phi$, written $$ \selfframes \phi. $$
In other words, $\phi$ is self-framing if and only if it grants all the permissions that it requires.

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Framing without Aliasing}

For this section framing desicions do not consider aliasing, for the sake of an introduction.

\subsection{Deciding Framing without Aliasing}

\noindent
The following algorithm decides $\Pi \frames \phi$ for a given set of permissions $\Pi$ and formula $\phi$.
\begin{align*}
\begin{array}{r|lrl}
\Pi \frames \phi
\iff \tsf{match} \ \phi \ \tsf{with}
%
% expressions
%
& v, x                &\mt& \top
\\
& e_1 \oplus e_2      &\mt& \Pi \frames e_1, e_2
\\
& e_1 \odot e_2       &\mt& \Pi \frames e_1, e_2
\\
& e.f                 &\mt& \Pi \frames e
                      \land \cacc(e.f) \in \Pi
\\
% formulas
%
& \cacc(e.f)          &\mt& \Pi \frames e
\\
% ordered version
% & \phi_1 \cast \phi_2 &\mt& \Pi \frames \phi_1
%                       \land \Pi \cup \granted(\phi_1) \frames \phi_2
% unordered version
& \phi_1 \cast \phi_2 &\mt& \Pi \cup \tsf{granted}(\phi_1 \cast \phi_2) \frames \phi_1, \phi_2
\\
& \alpha_C(\vec{e})   &\mt& \Pi \frames \vec{e}
\\
& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
                      &\mt& \Pi \frames e, \phi_1, \phi_2
\\
& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi
                      &\mt& \assume(\alpha_C(\vec{e})) \in \Pi
                      \land \Pi \frames \alpha_C(\vec{e})
                      \land \Pi \frames \phi
\end{array}
\end{align*}

\noindent
The following algorithm collects the set of permissions granted by a given formula $\phi$.
\begin{align*}
\begin{array}{r|lrl}
\granted(\phi)
:= \tsf{match} \ \phi \ \tsf{with}
%
% expressions
%
& e                   &\mt& \empty \\
%
% formulas
%
& \cacc(e.f)          &\mt& \set{ \access(e.f) }
\\
& \phi_1 \cast \phi_2 &\mt& \granted(\phi_1)
                      \cup  \granted(\phi_2)
\\
& \alpha_C(\vec{e})   &\mt& \set{ \assume(\alpha_C(\vec{e})) }
\\
& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
                      &\mt& \granted(\phi_1) \cap \granted(\phi_2)
\\
& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi
                      &\mt& \granted(\phi)
\end{array}
\end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Notes}

\begin{itemize}
\item The conditional expression $e$ in a formula of the form $(\cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2)$ is considered indeteminant for the purposes of statically deciding framing.

\item The body formula $\phi$ in a formula of the form $(\cunfolding \ \cacc_C(\vec{e})) \ \cin \ \phi)$ does not have to make use of the $\assume(\cacc_C(\vec{e}))$ required by the structure.
\end{itemize}

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Deciding Self-Framing without Aliasing}

\noindent
The following algorithm decides $\selfframes \phi$ for a given formula $\phi$.
\begin{align*}
\selfframes \phi \iff \empty \frames \phi
\end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Aliasing}

Let $I$ be the set of identifiers.
A pair of identifiers $x,y \in I$ are \tbf{unique} if they are not the same identifier.
The proposition that $x,y$ are unique is written $\unique(x,y)$ (note that this is importantly different notation from $x=y$).
The proposition that two identifiers refer to the same memory in the heap is written $x = y$.
A set of identifiers $\set{ x_\alpha }$ is \tbf{aliasing} if and and only if each $x_\alpha$ refers to the same memory in the heap i.e.
$$
x_{\alpha_1} = \cdots = x_{\alpha_k} \ \text{where} \ \set{\alpha} = \set{\alpha_1, \dots, \alpha_k}.
$$
The proposition that $\set{ x_\alpha }$ is aliasing is written $\aliasing \set{ x_\alpha }$.

An \tbf{aliasing context} is a set $A$ of aliasing propositions.
As a set of propositions, the consistency of $A$ can be considered.
Explicitly, $A$ is consistent if and only if
$$
\nexists x,y \in I : \unique(x,y) \land A \entails \aliasing \set{x,y} \land \pnot \aliasing \set{x,y}
$$
The proposition that $A$ is consistent is written $\consistent(A)$.

An alias context is \tbf{overlapping} if and only if there exist at least two unique sets of identifiers such that they have a non-empty intersection and both are asserted aliasing in $A$ i.e.
$$
\exists I_1, I_2 \subset I
:     (I_1 \neq I_2)
\land (I_1 \cap I_2 \neq \empty)
\land (\aliasing (I_1) \in A)
\land (\aliasing (I_2) \in A)
$$
An overlapping alias context is inefficient for deciding the propositions that it entails.
Fortunately the framing-deciding algorthm I present ensures that its tracked alias context never becomes becomes overlapping.

A alias context $A$ is \tbf{full} if and only if
$$
\forall I_\alpha \subset I
:
A \entails P(I_\alpha) \implies \exists \ P(I_{\alpha\p}) \in A : I_\alpha \subset I_{\alpha\p}
$$
where $P$ is an aliasing predicate (either \aliasing \ or $\pnot\aliasing$).
In other words, a full alias context is the most efficient representation of its total propositional strength.
Note that, of course, a full alias context that contains $\aliasing\set{x}$ need not contain $\pnot \pnot \aliasing\set{x}, \pnot \pnot \pnot \pnot \aliasing\set{x}, \dots$ although it does indeed entail these propositions.
This is useful for efficient computation, as demonstrated in the following.

Given $A$ an alias context and $x \in I$ an identifier, define:
\begin{align*}
  \tsf{aliases-of}(x)
  := & \
  \text{the largest set such that} \
  x \in \tsf{aliases-of}(x) \land A \entails \aliasing (\tsf{aliases-of}(x))
  \\
  \tsf{not-aliases-of}(x)
  := & \
  \text{the largest set such that} \
  \forall x\p \in \tsf{not-aliases-of}(x) : A \entails \pnot \aliasing\set{x,y\p}
\end{align*}
If $A$ is non-overlapping and full,
the computation of $\tsf{aliases-of}(x)$ is simply the extraction from $A$ the proposition that asserts aliasing of a set of identifiers that contains $x$
and the computation of $\tsf{not-aliases-of}(x)$ is the collection of all identifiers other than $x$ mentioned in propositions of $A$ that assert the negation of aliasing with $x$. For example,
$$
A := \set{ \aliasing\set{x,y}, \aliasing\set{z}, \pnot\aliasing\set{x,z}, \pnot\aliasing\set{y,z} }
$$
$$
\begin{array}{c|c|c}
\tit{id} & \tsf{aliases-of}(\tit{id}) & \tsf{not-aliases-of}(\tit{id})
\\ \hline
x & \set{x,y} & \set{z} \\
y & \set{x,y} & \set{z} \\
z & \set{z}   & \set{x,y}
\end{array}
$$

% TODO: define alias context merging and overlapping (for union and intersection used in the deciding framing with aliasing algorithm)

%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Framing with Aliasing}

For this section framing desicions \tit{do} consider aliasing.

\subsection{New Permissions}

The rules for framing without aliasing were particularly innacurate because they did not completely handle the separate access permissions to the heap.
In order to incorporate this, we introduce the permission to separate a part of the heap, written $\available(e.f)$.
Now the formula $\cacc(e.f)$ requires the $\available(e.f)$ permission and, additionally, grants the $- \ \available(e.f)$ permission which cancles out the ``used up'' $\available(e.f)$ permission.
As will be shown explicitly in the following algorithms, a formula is checked for framing at the top level with a starting set of permissions including $\available(e.f)$ for every $e.f$, accounting for the fact that the entirety of the heap is available at the top level.

\subsection{Deciding Framing with Aliasing}

Given $\Pi$ a permission set, $A$ an alias context, and $\phi$ a formula, the proposition that $\Pi, A$ \tbf{frames} $\phi$ is written
$$
\Pi, A \frames \phi
$$
The following algorithm decides $\Pi, A \frames \phi$.
\begin{align*}
\begin{array}{rclrl}
\Pi, A \frames \phi \iff \phi &=
%
% expressions
%
&     v
&\mt& \top
\\
&&    x
&\mt& \top
\\
&&    e_1 \oplus e_2
&\mt& \Pi, A \frames e_1, e_2
\\
&&    e_1 \ \&\& \ e_2
&\mt& \Pi, (\aliased(A,e_1) \merge \aliased(A,e_2)) \frames e_1, e_2
\\
&&    e_1 \mid\mid e_2
&\mt& \Pi, (\aliased(A,e_1) \overlap \aliased(A,e_2)) \frames e_1, e_2
\\
&&    x = y
&\mt& A \entails \pnot(\pnot \aliasing( \tsf{aliases-of}(x) \cup \tsf{aliases-of}(y) ))
\\
&&    x \odot y
&\mt& A \entails \pnot(\pnot(\pnot \aliasing( \tsf{aliases-of}(x) \cup \tsf{aliases-of}(y) )))
\\
&&    e_1 \odot e_2
&\mt& A, \Pi \frames e_1, e_2
\\
&&    e.f
&\mt& \Pi, A \frames e \land \cacc(e.f) \in \Pi
\\
% formulas
%
&&    \cacc(e.f)
&\mt& \Pi, A \frames e \land \available(e.f) \in \Pi
\\
&&    \phi_1 * \phi_2
&\mt& (\Pi \cup \granted(A, \phi_1 * \phi_2)), (\aliased(A, \phi_1 * \phi_2)) \entails \phi_1, \phi_2
\\
&&   \phi_1 \land \phi_2
&\mt& \Pi, (\aliased(A, \phi_2 \land \phi_2)) \frames \phi_1, \phi_2
\\
&&    \alpha_C(\vec{e})
&\mt& \Pi, A \frames \vec{e}
\\
&&    \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
&\mt& (\Pi, A \frames e)
\land (\Pi, \aliased(A, e) \frames \phi_1) \\ &&&&
\land (\Pi, \set{ \pnot P \mid P \in \aliased(A, e) } \frames \phi_2)
\\
&&    \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p
&\mt& (\assume(\alpha_C(\vec{e})) \in \Pi)
\land (\Pi, A \frames \phi\p)
\end{array}
\end{align*}

\begin{align*}
\begin{array}{rclrl}
\granted : A \times \phi \rightarrow A &&&& \\
\granted(A, \phi) := \phi & =
%
% expressions
%
&     v
&\mt& %TODO
\\
&&     x
&\mt& %TODO
\\
&&     e_1 \oplus e_2
&\mt& %TODO
\\
&&     e_2 \odot e_2
&\mt& %TODO
\\
&&     ef
&\mt& %TODO
\\
&&    \cacc(e.f)
&\mt& %TODO
\\
&&     \phi_1 \cast \phi_2
&\mt& %TODO
\\
&&     \alpha_C(\vec{e})
&\mt& %TODO
\\
&&     \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
&\mt& %TODO
\\
&&     \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p
&\mt& %TODO
\end{array}
\end{align*}

\begin{align*}
\begin{array}{rclrl}
\aliased : A \times \phi \rightarrow A &&&& \\
\aliased(A, \phi) := \phi & =
%
% expressions
%
&     v
&\mt& %TODO
\\
&&     x
&\mt& %TODO
\\
&&     e_1 \oplus e_2
&\mt& %TODO
\\
&&     e_2 \odot e_2
&\mt& %TODO
\\
&&     ef
&\mt& %TODO
\\
&&    \cacc(e.f)
&\mt& %TODO
\\
&&     \phi_1 \cast \phi_2
&\mt& %TODO
\\
&&     \alpha_C(\vec{e})
&\mt& %TODO
\\
&&     \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2
&\mt& %TODO
\\
&&     \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p
&\mt& %TODO
\end{array}
\end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Notes}

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Deciding Self-Framing with Aliasing}

\noindent
The following algorithm decides $\selfframes \phi$ for a given formula $\phi$.
% \begin{align*}
% \selfframes \phi \iff \empty \frames \phi
% \end{align*}

%-----------------------------------------------------------------------------------------------------------------------------
\end{document}
%-----------------------------------------------------------------------------------------------------------------------------
%-----------------------------------------------------------------------------------------------------------------------------
