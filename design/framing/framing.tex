\newpage
\section{Framing}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Definitions}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

For framing, a formula is considered inside a \tbf{permission context}, a set of permissions, where a \tbf{permission} $\pi$ is to do one of the following:
\begin{itemize}
  \item to reference $e.f$, written $\accessed(e.f)$.
  \item to assume $\alpha_C(\vec{e})$, written $\assumed(\alpha_C(\vec{e}))$. This allows the a single unrolling of $\alpha_C(\vec{e})$.
\end{itemize}
%
Let $\phi$ be a formula.
$\phi$ may \tbf{require} a permission $\pi$. For example, the formula $e.f = 1$ requires $\accessed(e.f)$, because it references $e.f$. The set of all permissions that $\phi$ requires is called the \tbf{requirements} of $\phi$. $\phi$ may also \tbf{grant} a permission $\pi$. For example, the formula $\cacc(e.f)$ grants the permission $\accessed(e.f)$.

Altogether, $\phi$ is \tbf{framed} by a set of permissions $\Pi$ if all permissions required by $\phi$ are either in $\Pi$ or granted by $\phi$. The proposition that $\Pi$ frames $\phi$ is written
$$
  \Pi \frames \phi
$$
Of course, $\phi$ may grant some of the permissions it requires but not all. The set of permissions that $\phi$ requires but does not grant is called the \tbf{footprint} of $\phi$. The footprint of $\phi$ is written
$$
  \footprint{\phi}
$$
Finally, a $\phi$ is called \tbf{self-framing} if and only if for any set of permissions $\Pi$, $\Pi \frames \phi$. The proposition that $\phi$ is self-framing is written
$$
  \selfframing \phi
$$
Note that $\selfframing \phi \iff \empty \frames \phi$, in other words $\phi$ is self-framing if and only if it grants all of the permissions it requires. Or in other words still, $\footprint{\phi} = \empty$.

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection{Deciding Framing}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

Deciding $\Pi \frames \phi$ must take into account the requirements, granteds, and aliases contained in $\Pi$ and the sub-formulas of $\phi$.
The following recursive algorithm decides $\Pi \frames \phi_{root}$, where $\A$ is implicitly assumed to be the top-level aliasing context (where the top-level in this context is the level that $\phi_{root}$ exists at in the program).

\begin{align*}
\begin{array}{rclcl}
\Pi \frames \phi &\iff& \tsf{match} \ \phi \ \tsf{with} &&
\\
&& v &\mt&
  \top
\\
&& x &\mt&
  \top
\\
&& e_1 \oplus e_2 &\mt&
  \Pi \frames e_1, e_2
\\
&& e_1 \odot e_2 &\mt&
  \Pi \frames e_1, e_2
\\
&& e.f &\mt&
  (\Pi \frames e) \ \land \ (\Pi \entails \accessed_\phi(e.f))
\\
&& \cacc(e.f) &\mt&
  (\Pi \frames e)  \ \land \
  % (\Pi \entails \pnot \pnot \pnot \accessed_\phi(e.f))
  \pnot (\Pi \entails \accessed_\phi(e.f))
\\
&& \phi_1 \ast \phi_2 &\mt&
  (\Pi \cup \granted(\phi_2) \frames \phi_1) \ \land \\ &&&&
  (\Pi \cup \granted(\phi_1) \frames \phi_2)
\\
&& \phi_1 \land \phi_2 &\mt&
  \Pi \frames \phi_1, \phi_2
\\
&& \alpha_C(e_1, \dots, e_k) &\mt&
  \Pi \frames e_1, \dots, e_2
\\
&& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
  \Pi \frames e, \phi_1, \phi_2
\\
&& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p &\mt&
  (\Pi \entails \assumed_\phi(\alpha_C(\vec{e}))) \ \land \
  (\Pi \frames \phi\p)
%
\\[1em]
%
\granted(\phi) &:=& \tsf{match} \ \phi \ \tsf{with} &&
\\
&& e &\mt&
  \empty
\\
&& \cacc(e.f) &\mt&
  \set{ \accessed(e.f) }
\\
&& \phi_1 \oast \phi_2 &\mt&
  \granted(\phi_1) \cup \granted(\phi_2)
\\
&& \alpha_C(\vec{e}) &\mt&
  \set{ \assumed(\alpha_C(\vec{e})) }
\\
&& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
  \granted(\phi_1) \cap \granted(\phi_2)
\\
&& \cunfolding \ \alpha_C(e_1, \dots, e_k) \ \cin \ \phi\p &\mt&
  \granted(\phi\p)
% %
% \\[1em]
% %
% \aliases_\phi(o) &:=& \set{ o\p \mid \A(\phi) \entails \aliased\set{o, o\p} } &
\end{array}
\end{align*}

\noindent
Where $\accessed_\phi$ and $\assumed_\phi$ indicate the respective propositions considered within the total alias context (including inherited aliasing contexts). More explicitly,
\begin{align*}
\Pi \entails \accessed_\phi(o.f) \iff &
  \exists o\p \in O :
  (\A(\phi) \entails \aliased\set{o, o\p}) \ \land \
  (\accessed(o\p.f) \in \Pi)
\\
\Pi \entails \assumed_\phi(\alpha_C(e_1, \dots, e_k)) \iff &
  (\forall i :
    e_i = e\p_i \ \lor \ % \\ & \hspace{2em}
    \exists (o, o\p) = (e_i, e\p_i) : \A(\phi) \entails \aliased\set{o, o\p}
  )
  \\ & \ \land \
  (\assumed(\alpha_C(e\p_1, \dots, e\p_k)) \in \Pi)
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Notes}
% ----------------------------------------------------------------------------------------------------------------------------

\begin{itemize}
  \item TODO: explain how non-object-variable expressions cannot alias to anything (thus the e.f case in granted and required)
\end{itemize}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Examples}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

In the following examples, assume that the considered formulas are well-formed.

% ----------------------------------------------------------------------------------------------------------------------------
\subsubsection*{Example 1}

Define
\begin{align*}
\phiroot := & \ x = y \ast \cacc(x.f) \ast \cacc(y.f).
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \ \context{ \set{\aliased\set{x,y}} }{ \empty }.
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff &
\empty \frames \phiroot
\\ \iff &
\empty \frames x = y \ast \cacc(x.f) \ast \cacc(y.f)
\\ \iff &
\empty \frames (x = y) \ast (\cacc(x.f) \ast \cacc(y.f))
\\ \iff &
(\granted((\cacc(x.f) \ast \cacc(y.f))) \frames x = y) \ \land \\ &
(\granted(x = y) \frames \cacc(x.f) \ast \cacc(y.f))
\\ \iff &
\top \ \land (\empty \frames \cacc(x.f) \ast \cacc(y.f))
\\ \iff &
(\granted(y.f) \frames \cacc(x.f)) \ \land \
(\granted(x.f) \frames \cacc(y.f))
\\ \iff &
(
  (\set{ \accessed(y.f) } \frames x) \ \land \\ & \hspace{2em}
  \pnot ((\set{ \accessed(y.f) } \frames x) \entails \accessed_{(\cacc{x.f})}(x.f))
)
\ \land \tag{$\star$} \\ &
(\granted(\cacc(x.f)) \frames \cacc(y.f))
\\ \iff &
\bot.
\end{align*}
Where $(\star)$ is decided to be $\bot$, thus yielding the entire conjunct to be decided $\bot$, because in the sub-formula $\phi := \cacc(x.f),$
$$
  (\A(\phi) \entails \aliased\set{x,y}) \ \entails \
  (\set{ \accessed(y.f) } \entails \accessed_{\phi}(x.f))
$$
contradicts the requirement of $\phi$ that
$$
  \pnot (\set{ \accessed(y.f) } \frames x) \entails \accessed_\phi(x.f))
$$

% ----------------------------------------------------------------------------------------------------------------------------
\subsubsection*{Example 2}
% ----------------------------------------------------------------------------------------------------------------------------

Define
\begin{align*}
\phiroot := & \
\cacc(x.f) \ \ast \
(\cif \ b_1 \ \cthen \ x.f = 1 \ \celse \ \cacc(x.f))
\end{align*}
Then
\begin{align*}
\A(\phiroot) = & \
\context{\empty}{\set{
    %TODO
}}
\end{align*}
And so,
\begin{align*}
\selfframing \phiroot
\iff &
\empty \frames \phiroot \\
& %
\end{align*}

% % ----------------------------------------------------------------------------------------------------------------------------
% \subsection*{Example X}
% % ----------------------------------------------------------------------------------------------------------------------------
%
% Define
% \begin{align*}
% \phiroot := & \ %
% \end{align*}
% Then
% \begin{align*}
% \A(\phiroot) = & \ %
% \end{align*}
% And so,
% \begin{align*}
% \selfframing \phiroot
% \iff &
% \empty \frames \phiroot \\
% & %
% \end{align*}
