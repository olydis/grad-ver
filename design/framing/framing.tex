\newpage
\section{Framing}

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\subsection{Definitions}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

For framing, a formula is considered inside a \tbf{permission context}, a set of permissions, where a \tbf{permission} $\pi$ is to do one of the following:
\begin{itemize}
  \item to reference $e.f$, written $\accessed(e.f)$.
  \item to assume $\alpha_C(\vec{e})$, written $\assumed(\alpha_C(\vec{e}))$. This allows the a single unrolling of $\alpha_C(\vec{e})$.
\end{itemize}
%
Let $\phi$ be a formula.
$\phi$ may \tbf{require} a permission $\pi$. For example, the formula $e.f = 1$ requires $\accessed(e.f)$, because it references $e.f$. The set of all permissions that $\phi$ requires is called the \tbf{requirements} of $\phi$. $\phi$ may also \tbf{grant} a permission $\pi$. For example, the formula $\cacc(e.f)$ grants the permission $\accessed(e.f)$.

Altogether, $\phi$ is \tbf{framed} by a set of permissions $\Pi$ if all permissions required by $\phi$ are either in $\Pi$ or granted by $\phi$. The proposition that $\Pi$ frames $\phi$ is written
$$
  \Pi \frames \phi
$$
Of course, $\phi$ may grant some of the permissions it requires but not all. The set of permissions that $\phi$ requires but does not grant is called the \tbf{footprint} of $\phi$. The footprint of $\phi$ is written
$$
  \footprint{\phi}
$$
Finally, a $\phi$ is called \tbf{self-framing} if and only if for any set of permissions $\Pi$, $\Pi \frames \phi$. The proposition that $\phi$ is self-framing is written
$$
  \selfframes \phi
$$
Note that $\selfframes \phi \iff \empty \frames \phi$, in other words $\phi$ is self-framing if and only if it grants all the permissions it requires.

% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------
\newpage
\subsection{Deciding Framing}
% ----------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------

Deciding $\Pi \frames \phi$ must take into account the requirements, granteds, and aliases contained in $\Pi$ and the sub-formulas of $\phi$.
The following recursive algorithm decides $\Pi \frames \phi_{root}$, where $\A$ is implicitly assumed to be the top-level aliasing context (where the top-level in this context is the level that $\phi_{root}$ exists at in the program).

\begin{align*}
\begin{array}{rclcl}
\Pi \frames \phi &\iff& \tsf{match} \ \phi \ \tsf{with} &&
\\
&& v &\mt&
  \top
\\
&& x &\mt&
  \top
\\
&& e_1 \oplus e_2 &\mt&
  \Pi \frames e_1, e_2
\\
&& e_1 \odot e_2 &\mt&
  \Pi \frames e_1, e_2
\\
&& e.f &\mt&
  (\Pi \frames e) \ \land \ (\Pi \entails \accessed_\phi(e.f))
\\
&& \cacc(e.f) &\mt&
  (\Pi \frames e)  \ \land \
  % (\Pi \entails \pnot \pnot \pnot \accessed_\phi(e.f))
  \pnot (\Pi \entails \accessed_\phi(e.f))
\\
&& \phi_1 \ast \phi_2 &\mt&
  (\Pi \frames \phi_1) \ \land \
  (\Pi \cup \granted(\phi_1) \frames \phi_2)
\\
&& \phi_1 \land \phi_2 &\mt&
  \Pi \frames \phi_1, \phi_2
\\
&& \alpha_C(e_1, \dots, e_k) &\mt&
  \Pi \frames e_1, \dots, e_2
\\
&& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
  \Pi \frames e, \phi_1, \phi_2
\\
&& \cunfolding \ \alpha_C(\vec{e}) \ \cin \ \phi\p &\mt&
  (\Pi \entails \assumed_\phi(\alpha_C(\vec{e}))) \ \land \
  (\Pi \frames \phi\p)
%
\\[1em]
%
\granted(\phi) &:=& \tsf{match} \ \phi \ \tsf{with} &&
\\
&& e &\mt&
  \empty
\\
&& \cacc(e.f) &\mt&
  \set{ \accessed(e.f) }
\\
&& \phi_1 \ast \phi_2 &\mt&
  \granted(\phi_1) \cup \granted(\phi_2)
\\
&& \phi_1 \land \phi_2 &\mt&
  \granted(\phi_1) \cup^\land \granted(\phi_2)
\\
&& \alpha_C(e_1, \dots, e_k) &\mt&
  % argument expressions are not being asserted as true,
  % so don't grant any permissions
  \set{ \assumed(\alpha_C(e_1, \dots, e_k)) }
\\
&& \cif \ e \ \cthen \ \phi_1 \ \celse \ \phi_2 &\mt&
  \granted(\phi_1) \cap \granted(\phi_2)
\\
&& \cunfolding \ \alpha_C(e_1, \dots, e_k) \ \cin \ \phi\p &\mt&
  \granted(\phi\p)
%
\\[1em]
%
\aliases_\phi(o) &:=& \set{ o\p \mid \A(\phi) \entails \aliased\set{o, o\p} } &
\end{array}
\end{align*}

\noindent
Where $\accessed_\phi$ and $\assumed_\phi$ indicate the respective propositions considered within the total alias context (including inherited aliasing contexts). More explicitly,
\begin{align*}
\Pi \entails \accessed_\phi(o.f) \iff &
  \exists o\p \in O :
  (\A(\phi) \entails \aliased\set{o, o\p}) \ \land \
  (\accessed(o\p.f) \in \Pi)
\\
\Pi \entails \assumed_\phi(\alpha_C(e_1, \dots, e_k)) \iff &
  (\forall i :
    e_i = e\p_i \ \lor \ % \\ & \hspace{2em}
    \exists (o, o\p) = (e_i, e\p_i) : \A(\phi) \entails \aliased\set{o, o\p}
  )
  \\ & \ \land \
  (\assumed(\alpha_C(e\p_1, \dots, e\p_k)) \in \Pi)
\end{align*}

% ----------------------------------------------------------------------------------------------------------------------------
\subsubsection{Notes}
% ----------------------------------------------------------------------------------------------------------------------------

\begin{itemize}
  \item TODO: explain how non-object-variable expressions cannot alias to anything (thus the e.f case in granted and required)
\end{itemize}
