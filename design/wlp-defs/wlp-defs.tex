\documentclass {article}

\usepackage[letterpaper]{geometry}
\usepackage{amsthm, amsmath, amssymb, stmaryrd}
 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\title {Verifier WLP Definitions}
\author {Jenna Wise, Johannes Bader, Jonathan Aldrich, \'{E}ric Tanter}
\date {\today}

%% Commands
\newcommand{\true}{\text{true}}
\newcommand{\eif}[3]{if \ ( #1 ) \ \{ #2 \} \ else \ \{#3\}}
\newcommand{\fphi}{\widehat{\phi}}
\newcommand{\tphi}{\widetilde{\phi}}
\newcommand{\acc}[1]{\text{acc}(#1)}
\newcommand{\imp}{\Rightarrow}
\newcommand{\timp}{\ \widetilde{\Rightarrow}\ }
\newcommand{\maximp}[2]{\underset{\Rightarrow}{\text{max}}\left\{#1 \mid #2\right\}}

\newcommand{\wlp}[2]{\text{WLP}(#1,#2)}
\newcommand{\twlp}[2]{\widetilde{\text{WLP}}(#1,#2)}
\newcommand{\swlp}[2]{\text{sWLP}(#1,#2)}
\newcommand{\swlpi}[2]{\text{sWLP}_i(#1,#2)}

% uppercase word defs
\newcommand{\satdef}{\textsc{SatFormula}}

\begin{document}

\maketitle

%\begin{figure*}[ht!]
%\begin{flalign*}
%%\spc{skip}{\phi} = \phi
%%\and
%%\spc{s_1;s_2}{\phi} = \spc{s_2}{\spc{s_1}{\phi}}
%%\and
%%\spc{T\ x}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x}.(\theta \wedge x = \text{defaultValue}(T)) \wedge \psi
%%\and
%%\spc{x := e}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x]\psi
%%\and
%%\spc{x := y.f}{\exists \overline{x}.\theta \wedge (\psi \ast y.f \mapsto e)} =  \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x](\psi \ast y.f \mapsto e)
%%\and
%%\spc{x.f := y}{\exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto e)} = \exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto y)\\
%%\and
%%\spc{x := new\ C}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . [x'/x]\theta \wedge ([x'/x]\psi\ \overline{\ast\ x.f_i \mapsto \text{defaultValue}(T_i)})\ \text{where fields}(C)=\overline{T_i\ f_i} \\
%%\and
%%\spc{y := z.m(\overline{x})}{\exists \overline{y}.\theta \wedge \psi} = \begin{cases} \exists \overline{y}, y' . ([y'/y]\theta_{frame} \wedge \theta_Q) \wedge ([y'/y]\psi_{frame} \ast \psi_Q) & \text{if}\ \exists \overline{y}.(\theta \wedge \psi) \imp \exists \overline{y}.(\theta_{frame} \wedge \theta_P) \wedge (\psi_{frame} \ast \psi_P) \\ undefined & \text{otherwise} \end{cases}
%%\\ \text{where}\ \left[z/this,\overline{x_i/\text{params}(m)_i}\right]\text{pre(m)}=\theta_P \wedge \psi_P\ \text{and}\ \left[z/this, y/result, \overline{x_i/\text{old}(\text{params}(m)_i)}\right]\text{post(m)}=\theta_Q \wedge \psi_Q 
%%\and
%%\spc{assert\ \phi_a}{\phi} = \begin{cases} \phi & \text{if}\ \phi \imp \phi_a \\ undefined & \text{otherwise} \end{cases}
%%% WLP
%\wlp{skip}{\phi} &= \phi & \\
%\wlp{s_1;s_2}{\phi} &= \wlp{s_1}{\wlp{s_2}{\phi}}& \\
%\wlp{T\ x}{\phi} &= \phi &\\
%\wlp{x := e}{\phi} &= [e/x]\phi &\\
%\wlp{x := y.f}{\theta \wedge \psi} &= [e/x]\theta \wedge ([e/x]\psi \ast y.f \rightarrow e) &\\
%\wlp{x.f := y}{\theta \wedge \psi} &= \maximp{\theta' \wedge \psi'}{\theta' \wedge (\psi' \ast x.f \rightarrow y) \imp \theta \wedge \psi} &\\
%\wlp{x := new\ C}{\phi} &= &\\
%\wlp{y := z.m(\overline{x})}{\phi} &= &\\
%\wlp{assert\ \phi}{\phi} &=  &\\
%\end{flalign*}
%%\caption{Weakest Liberal Precondition Calculus}
%%\label{wp-rules}
%\end{figure*}

\section{Weakest liberal precondition calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

%$\wlp{T\ x}{\fphi} = \fphi\left[\text{defaultValue}(T)/x\right] $ -- NEEDS TO CHANGE

%\vspace{0.5cm}

$\wlp{T \ x := e}{\fphi} =\maximp{\fphi'}{\fphi' \imp \fphi[e/x] \quad \wedge \quad \fphi' \imp \acc{e}} $

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $
%\underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid \fphi' \imp \text{acc}(x) \quad \wedge \quad \fphi' \imp \text{acc}(y) \quad \wedge \quad$ 

%\indent  \hspace{4cm} $\fphi' \imp \left(\left(x \odot y \imp \wlp{s_1}{\fphi}\right) \quad \wedge \quad \left(\neg(x \odot y) \imp \wlp{s_2}{\fphi}\right)\right) \Big{\}}$

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} = \acc{x.f} \ \ast \ \maximp{\fphi'}{\fphi' \ast \acc{x.f} \ast (x.f = y) \imp \fphi \ \wedge \ \fphi' * \acc{x.f} \in \satdef} $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = \maximp{\fphi'}{ \fphi' \ast (x \neq null) \ast \overline{\acc{x.f_i}} \imp \fphi}$

%\overline{\acc{x.f_i} \ast (x.f_i = \text{defaultValue}(T_i))} 

\indent  \hspace{4cm} where fields$(C) = \overline{T_i \ f_i}$

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = \underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid y \not \in \text{FV}(\fphi') \quad \wedge \quad \fphi' \imp (z \neq null) \ \ast \ \text{pre}(C,m)\left[z/this, \overline{x_i/\text{params}(C,m)_i}\right] $ 
\indent \hspace{4cm} $ \wedge \quad \fphi' \ast \text{post}(C,m)\left[z/this, \overline{x_i/\text{old}(\text{params}(C,m)_i)}, y/result \right] \imp \fphi \Big{\}}$

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = \maximp{\fphi'}{\fphi' \imp \fphi \quad \wedge \quad \fphi' \imp \phi_a} $

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\vspace{0.5cm}

\noindent \textbf{Note:} 

\textbf{Dynamic method calls.} Dynamic method calls are left undefined, because we are not verifying programs with dynamic dispatch at this time (all method calls should be static method calls). They are included in the grammar for future implementation.

\textbf{If \& Release \& hold.} Definitions coming soon.

\textbf{Predicates in the logic.} Although the grammar allows for abstract predicate families, we do not support them yet. Therefore, we assume formulas look like:

$$ \phi ::= \true \mid e \odot e \mid acc(e.f) \mid \phi \ast \phi $$

\section{Algorithmic WLP calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

$\wlp{T \ x := e}{\fphi} = 
	\begin{cases}
	 \fphi[e/x] & if \ \fphi[e/x] \imp acc(e) \\
	 acc(e) \ast \fphi[e/x] & otherwise
	\end{cases} $

Check that $\wlp{T \ x := e}{\fphi} \ast x = e \imp \fphi$ and that $\wlp{T \ x := e}{\fphi}$ is satisfiable.

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} =  
	\begin{cases}
	 \fphi[y/x.f] & if \ \fphi[y/x.f] \imp acc(x.f) \\
	 acc(x.f) \ast \fphi[y/x.f] & otherwise
	\end{cases}$

Check that $\wlp{x.f := y}{\fphi} \ast x.f = y \imp \fphi$ and that $\wlp{x.f := y}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = acc(x.f) \ast x.f = p \ast x.f = q \ast a = b $

$\fphi = acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = 
	\begin{cases}
	 \fphi \div x & if \ (\fphi \div x) \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \imp \fphi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$, $\fphi \div x$ means to transitively expand (in-)equalities ($\odot$) and then remove conjunctive terms containing $x$, and $\overline{x \neq e_i}$ are conjunctive terms in $\fphi$. 

Check $\wlp{x := new\ C}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = x \neq null \ast acc(x.f)$

$\fphi = x \neq null \ast acc(x.f) \ast x.f = 1 \ast x.f = y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast x = z$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast y = z$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x \neq y \ast y = z$

$\fphi = x \neq null \ast acc(x.f) \ast acc(x.f.f) \ast x.f.f \neq y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(y.f) \ast x = y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast y > x.f \ast x.f > z \ast r \geq x.f \ast x.f \geq s$ --- should fail, bad postcondition


\textbf{Note:}

$x := new \ C$ creates a fresh object and assigns it to $x$ without setting default values to the object's fields; therefore, postconditions cannot say anything about the value of $x$ other than it does not equal other values (no aliasing with $x$) and they cannot say anything about the values of the fields of $x$.

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = $

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = $
%	\begin{cases}
%	 \fphi \ast \phi_a & if \ fp(\fphi) \cap fp(\phi_a) = \emptyset \\
%	 \overline{acc((x.f)_i)} \ast \fphi \div \ast \phi_a \div & otherwise
%	\end{cases}$

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\section{Algorithmic WLP calculus definitions over gradual formulas}
\hspace{0.5cm}

$\twlp{s}{\fphi} = \wlp{s}{\fphi} $ where $s$ is not a call statement

\vspace{0.5cm}

$\twlp{skip}{? \ast \phi} = \ ? \ast \phi$

\vspace{0.5cm}

$\twlp{s_1;s_2}{? \ast \phi} = \twlp{s_1}{\twlp{s_2}{? \ast \phi}} $

\vspace{0.5cm}

$\twlp{T \ x := e}{? \ast \phi} = \ ? \ast \phi[e/x] \ast e = e$

\textbf{Important cases to consider:}

$? \ast \phi = \ ? \ast p = q \ast y.f = 2$ --- no mention of $e$ or $x$ for substitution; need extra $\ast \ e = e$ because of this case

\textbf{OR}

$\twlp{T \ x := e}{? \ast \phi} =
	 \begin{cases}
	 ? \ast \phi[e/x] & if \ \phi[e/x] \imp acc(e) \\
	 ? \ast acc(e) \ast \phi[e/x] & otherwise
	\end{cases}$
	
Check that $\twlp{T \ x := e}{? \ast \phi} \ast x = e \timp ? \ast \phi$ and that $\twlp{T \ x := e}{? \ast \phi}$ is satisfiable.

\vspace{0.5cm}

%$\twlp{\eif{x \odot y}{s_1}{s_2}}{? \ast \phi} = $
%
%\vspace{0.5cm}

$\twlp{x.f := y}{? \ast \phi} =
	\begin{cases}
	 ? \ast \phi[y/x.f] & if \ \phi[y/x.f] \imp acc(x.f) \\
	 ? \ast acc(x.f) \ast \phi[y/x.f] & otherwise
	\end{cases}$

Check that $\twlp{x.f := y}{? \ast \phi} \ast x.f = y \timp \ ? \ast \phi$ and that $\twlp{x.f := y}{? \ast \phi}$ is satisfiable.

\textbf{Important cases to consider:}

$? \ast \phi = \ ? \ast acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\twlp{x := new\ C}{? \ast \phi} = 
	\begin{cases}
	 ? \ast \phi \div x & if \ (\phi \div x) \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \imp \phi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$, $\phi \div x$ means to transitively expand (in-)equalities ($\odot$) and then remove conjunctive terms containing $x$, and $\overline{x \neq e_i}$ are conjunctive terms in $\phi$. 

Check that $\twlp{x := new\ C}{? \ast \phi} \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \timp ? \ast \phi$ and that $\twlp{x := new\ C}{? \ast \phi}$ is satisfiable.

\textbf{Important cases to consider:}

Similar to the ones for the non-gradual version; replacing $\fphi$ with $\phi$.

%\vspace{0.5cm}
%
%$\twlp{y := z.m(\overline{x})}{} = undefined$
%
%\vspace{0.5cm}
%
%$\twlp{y := z.m_C(\overline{x})}{} = $

\vspace{0.5cm}

$\twlp{assert\ \phi_a}{? \ast \phi} = $

%\vspace{0.5cm}
%
%$\twlp{release \ \phi_a}{? \ast \phi} = $
%
%\vspace{0.5cm}
%
%$\twlp{hold \ \phi_a \ \{s\}}{? \ast \phi} = $
%
%\vspace{0.5cm}

\textbf{Note:} The static parts of gradual formulas do not need to be self-framed unless the gradual formula is completely precise (completely static). The imprecision can account for the framing.

\section{Gradual formula implication and satisfiability}

\textbf{TBD}

\end{document}
