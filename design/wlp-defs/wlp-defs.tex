\documentclass {article}

\usepackage[letterpaper]{geometry}
\usepackage{amsthm, amsmath, amssymb, stmaryrd}
 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\title {Verifier WLP Definitions}
\author {Jenna Wise, Johannes Bader, Jonathan Aldrich, Joshua Sunshine}
\date {\today}

%% Commands
\newcommand{\true}{\text{true}}
\newcommand{\eif}[3]{if \ ( #1 ) \ \{ #2 \} \ else \ \{#3\}}
\newcommand{\fphi}{\widehat{\phi}}
\newcommand{\tphi}{\widetilde{\phi}}
\newcommand{\acc}[1]{\text{acc}(#1)}
\newcommand{\imp}{\Rightarrow}
\newcommand{\maximp}[2]{\underset{\Rightarrow}{\text{max}}\left\{#1 \mid #2\right\}}

\newcommand{\wlp}[2]{\text{WLP}(#1,#2)}
\newcommand{\twlp}[2]{\widetilde{\text{WLP}}(#1,#2)}
\newcommand{\swlp}[2]{\text{sWLP}(#1,#2)}
\newcommand{\swlpi}[2]{\text{sWLP}_i(#1,#2)}

% uppercase word defs
\newcommand{\satdef}{\textsc{SatFormula}}

\begin{document}

\maketitle

%\begin{figure*}[ht!]
%\begin{flalign*}
%%\spc{skip}{\phi} = \phi
%%\and
%%\spc{s_1;s_2}{\phi} = \spc{s_2}{\spc{s_1}{\phi}}
%%\and
%%\spc{T\ x}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x}.(\theta \wedge x = \text{defaultValue}(T)) \wedge \psi
%%\and
%%\spc{x := e}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x]\psi
%%\and
%%\spc{x := y.f}{\exists \overline{x}.\theta \wedge (\psi \ast y.f \mapsto e)} =  \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x](\psi \ast y.f \mapsto e)
%%\and
%%\spc{x.f := y}{\exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto e)} = \exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto y)\\
%%\and
%%\spc{x := new\ C}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . [x'/x]\theta \wedge ([x'/x]\psi\ \overline{\ast\ x.f_i \mapsto \text{defaultValue}(T_i)})\ \text{where fields}(C)=\overline{T_i\ f_i} \\
%%\and
%%\spc{y := z.m(\overline{x})}{\exists \overline{y}.\theta \wedge \psi} = \begin{cases} \exists \overline{y}, y' . ([y'/y]\theta_{frame} \wedge \theta_Q) \wedge ([y'/y]\psi_{frame} \ast \psi_Q) & \text{if}\ \exists \overline{y}.(\theta \wedge \psi) \imp \exists \overline{y}.(\theta_{frame} \wedge \theta_P) \wedge (\psi_{frame} \ast \psi_P) \\ undefined & \text{otherwise} \end{cases}
%%\\ \text{where}\ \left[z/this,\overline{x_i/\text{params}(m)_i}\right]\text{pre(m)}=\theta_P \wedge \psi_P\ \text{and}\ \left[z/this, y/result, \overline{x_i/\text{old}(\text{params}(m)_i)}\right]\text{post(m)}=\theta_Q \wedge \psi_Q 
%%\and
%%\spc{assert\ \phi_a}{\phi} = \begin{cases} \phi & \text{if}\ \phi \imp \phi_a \\ undefined & \text{otherwise} \end{cases}
%%% WLP
%\wlp{skip}{\phi} &= \phi & \\
%\wlp{s_1;s_2}{\phi} &= \wlp{s_1}{\wlp{s_2}{\phi}}& \\
%\wlp{T\ x}{\phi} &= \phi &\\
%\wlp{x := e}{\phi} &= [e/x]\phi &\\
%\wlp{x := y.f}{\theta \wedge \psi} &= [e/x]\theta \wedge ([e/x]\psi \ast y.f \rightarrow e) &\\
%\wlp{x.f := y}{\theta \wedge \psi} &= \maximp{\theta' \wedge \psi'}{\theta' \wedge (\psi' \ast x.f \rightarrow y) \imp \theta \wedge \psi} &\\
%\wlp{x := new\ C}{\phi} &= &\\
%\wlp{y := z.m(\overline{x})}{\phi} &= &\\
%\wlp{assert\ \phi}{\phi} &=  &\\
%\end{flalign*}
%%\caption{Weakest Liberal Precondition Calculus}
%%\label{wp-rules}
%\end{figure*}

\section{Weakest liberal precondition calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

$\wlp{T\ x}{\fphi} = \fphi\left[\text{defaultValue}(T)/x\right] $ -- NEEDS TO CHANGE

\vspace{0.5cm}

$\wlp{x := e}{\fphi} =\maximp{\fphi'}{\fphi' \imp \fphi[e/x] \quad \wedge \quad \fphi' \imp \acc{e}} $

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $
%\underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid \fphi' \imp \text{acc}(x) \quad \wedge \quad \fphi' \imp \text{acc}(y) \quad \wedge \quad$ 

%\indent  \hspace{4cm} $\fphi' \imp \left(\left(x \odot y \imp \wlp{s_1}{\fphi}\right) \quad \wedge \quad \left(\neg(x \odot y) \imp \wlp{s_2}{\fphi}\right)\right) \Big{\}}$

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} = \acc{x.f} \ \ast \ \maximp{\fphi'}{\fphi' \ast \acc{x.f} \ast (x.f = y) \imp \fphi \ \wedge \ \fphi' * \acc{x.f} \in \satdef} $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = \maximp{\fphi'}{ \fphi' \ast (x \neq null) \ast \overline{\acc{x.f_i}} \imp \fphi}$

%\overline{\acc{x.f_i} \ast (x.f_i = \text{defaultValue}(T_i))} 

\indent  \hspace{4cm} where fields$(C) = \overline{T_i \ f_i}$

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = \underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid y \not \in \text{FV}(\fphi') \quad \wedge \quad \fphi' \imp (z \neq null) \ \ast \ \text{pre}(C,m)\left[z/this, \overline{x_i/\text{params}(C,m)_i}\right] $ 
\indent \hspace{4cm} $ \wedge \quad \fphi' \ast \text{post}(C,m)\left[z/this, \overline{x_i/\text{old}(\text{params}(C,m)_i)}, y/result \right] \imp \fphi \Big{\}}$

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = \maximp{\fphi'}{\fphi' \imp \fphi \quad \wedge \quad \fphi' \imp \phi_a} $

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\vspace{0.5cm}

\noindent \textbf{Note:} 

\textbf{Dynamic method calls.} Dynamic method calls are left undefined, because we are not verifying programs with dynamic dispatch at this time (all method calls should be static method calls). They are included in the grammar for future implementation.

\textbf{If \& Release \& hold.} Definitions coming soon.

\textbf{Predicates in the logic.} Although the grammar allows for abstract predicate families, we do not support them yet. Therefore, we assume formulas look like:

$$ \phi ::= \true \mid e \odot e \mid acc(e.f) \mid \phi \ast \phi $$

\section{Helpful function definitions}

\textbf{TBD}

\section{Algorithmic WLP calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

$\wlp{T\ x}{\fphi} =  $

\vspace{0.5cm}

$\wlp{x := e}{\fphi} = 
	\begin{cases}
	 \fphi[e/x] & if \ \fphi[e/x] \imp acc(e) \\
	 acc(e) \ast \fphi[e/x] & otherwise
	\end{cases} $

Check that $\wlp{x := e}{\fphi} \ast x = e \imp \fphi$ and that $\wlp{x := e}{\fphi}$ is satisfiable.

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} =  
	\begin{cases}
	 \fphi[y/x.f] & if \ \fphi[y/x.f] \imp acc(x.f) \\
	 acc(x.f) \ast \fphi[y/x.f] & otherwise
	\end{cases}$

Check that $\wlp{x.f := y}{\fphi} \ast x.f = y \imp \fphi$ and that $\wlp{x.f := y}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = acc(x.f) \ast x.f = p \ast x.f = q \ast a = b $

$\fphi = acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = 
	\begin{cases}
	 \fphi \div x & if \ (\fphi \div x) \ast x \neq null \ast \overline{acc(x.f_i)} \imp \fphi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$ and $\fphi \div x$ means to transitively expand (in-)equalities ($\odot$) and then removing conjunctive terms containing x. 

\textbf{Important cases to consider:}

$\fphi = x \neq null \ast acc(x.f)$

$\fphi = x \neq null \ast acc(x.f) \ast x.f = 1 \ast x.f = y$

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast x = z$

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast y = z$

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = $

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = $
%
%	\begin{cases}
%	 \fphi \ast \phi_a & if \ fp(\fphi) \cap fp(\phi_a) = \emptyset \\
%	 \overline{acc((x.f)_i)} \ast \fphi \div \ast \phi_a \div & otherwise
%	\end{cases}$

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\vspace{0.5cm}

\end{document}
