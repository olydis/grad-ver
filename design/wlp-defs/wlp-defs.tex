\documentclass {article}

\usepackage[letterpaper]{geometry}
\usepackage{amsthm, amsmath, amssymb, stmaryrd}
 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\title {Verifier WLP Definitions}
\author {Jenna Wise, Johannes Bader, Jonathan Aldrich, \'{E}ric Tanter}
\date {\today}

%% Commands
\newcommand{\lcar}{\left<}
\newcommand{\rcar}{\right>}
\newcommand{\true}{\text{true}}
\newcommand{\eif}[3]{if \ ( #1 ) \ \{ #2 \} \ else \ \{#3\}}
\newcommand{\fphi}{\widehat{\phi}}
\newcommand{\tphi}{\widetilde{\phi}}
\newcommand{\acc}[1]{\text{acc}(#1)}
\newcommand{\imp}{\Rightarrow}
\newcommand{\timp}{\ \widetilde{\Rightarrow}\ }
\newcommand{\maximp}[2]{\underset{\Rightarrow}{\text{max}}\left\{#1 \mid #2\right\}}

\newcommand{\wlp}[2]{\text{WLP}(#1,#2)}
\newcommand{\twlp}[2]{\widetilde{\text{WLP}}(#1,#2)}
\newcommand{\swlp}[2]{\text{sWLP}(#1,#2)}
\newcommand{\swlpi}[2]{\text{sWLP}_i(#1,#2)}

% uppercase word defs
\newcommand{\satdef}{\textsc{SatFormula}}

\begin{document}

\maketitle

%\begin{figure*}[ht!]
%\begin{flalign*}
%%\spc{skip}{\phi} = \phi
%%\and
%%\spc{s_1;s_2}{\phi} = \spc{s_2}{\spc{s_1}{\phi}}
%%\and
%%\spc{T\ x}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x}.(\theta \wedge x = \text{defaultValue}(T)) \wedge \psi
%%\and
%%\spc{x := e}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x]\psi
%%\and
%%\spc{x := y.f}{\exists \overline{x}.\theta \wedge (\psi \ast y.f \mapsto e)} =  \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x](\psi \ast y.f \mapsto e)
%%\and
%%\spc{x.f := y}{\exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto e)} = \exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto y)\\
%%\and
%%\spc{x := new\ C}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . [x'/x]\theta \wedge ([x'/x]\psi\ \overline{\ast\ x.f_i \mapsto \text{defaultValue}(T_i)})\ \text{where fields}(C)=\overline{T_i\ f_i} \\
%%\and
%%\spc{y := z.m(\overline{x})}{\exists \overline{y}.\theta \wedge \psi} = \begin{cases} \exists \overline{y}, y' . ([y'/y]\theta_{frame} \wedge \theta_Q) \wedge ([y'/y]\psi_{frame} \ast \psi_Q) & \text{if}\ \exists \overline{y}.(\theta \wedge \psi) \imp \exists \overline{y}.(\theta_{frame} \wedge \theta_P) \wedge (\psi_{frame} \ast \psi_P) \\ undefined & \text{otherwise} \end{cases}
%%\\ \text{where}\ \left[z/this,\overline{x_i/\text{params}(m)_i}\right]\text{pre(m)}=\theta_P \wedge \psi_P\ \text{and}\ \left[z/this, y/result, \overline{x_i/\text{old}(\text{params}(m)_i)}\right]\text{post(m)}=\theta_Q \wedge \psi_Q 
%%\and
%%\spc{assert\ \phi_a}{\phi} = \begin{cases} \phi & \text{if}\ \phi \imp \phi_a \\ undefined & \text{otherwise} \end{cases}
%%% WLP
%\wlp{skip}{\phi} &= \phi & \\
%\wlp{s_1;s_2}{\phi} &= \wlp{s_1}{\wlp{s_2}{\phi}}& \\
%\wlp{T\ x}{\phi} &= \phi &\\
%\wlp{x := e}{\phi} &= [e/x]\phi &\\
%\wlp{x := y.f}{\theta \wedge \psi} &= [e/x]\theta \wedge ([e/x]\psi \ast y.f \rightarrow e) &\\
%\wlp{x.f := y}{\theta \wedge \psi} &= \maximp{\theta' \wedge \psi'}{\theta' \wedge (\psi' \ast x.f \rightarrow y) \imp \theta \wedge \psi} &\\
%\wlp{x := new\ C}{\phi} &= &\\
%\wlp{y := z.m(\overline{x})}{\phi} &= &\\
%\wlp{assert\ \phi}{\phi} &=  &\\
%\end{flalign*}
%%\caption{Weakest Liberal Precondition Calculus}
%%\label{wp-rules}
%\end{figure*}

\section{Weakest liberal precondition calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

%$\wlp{T\ x}{\fphi} = \fphi\left[\text{defaultValue}(T)/x\right] $ -- NEEDS TO CHANGE

%\vspace{0.5cm}

$\wlp{T \ x := e}{\fphi} =\maximp{\fphi'}{\fphi' \imp \fphi[e/x] \quad \wedge \quad \fphi' \imp \acc{e}} $

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $
%\underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid \fphi' \imp \text{acc}(x) \quad \wedge \quad \fphi' \imp \text{acc}(y) \quad \wedge \quad$ 

%\indent  \hspace{4cm} $\fphi' \imp \left(\left(x \odot y \imp \wlp{s_1}{\fphi}\right) \quad \wedge \quad \left(\neg(x \odot y) \imp \wlp{s_2}{\fphi}\right)\right) \Big{\}}$

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} = \acc{x.f} \ \ast \ \maximp{\fphi'}{\fphi' \ast \acc{x.f} \ast (x.f = y) \imp \fphi \ \wedge \ \fphi' * \acc{x.f} \in \satdef} $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = \maximp{\fphi'}{ \fphi' \ast (x \neq null) \ast \overline{\acc{x.f_i}} \imp \fphi}$

%\overline{\acc{x.f_i} \ast (x.f_i = \text{defaultValue}(T_i))} 

\indent  \hspace{4cm} where fields$(C) = \overline{T_i \ f_i}$

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = \underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid y \not \in \text{FV}(\fphi') \quad \wedge \quad \fphi' \imp (z \neq null) \ \ast \ \text{pre}(C,m)\left[z/this, \overline{x_i/\text{params}(C,m)_i}\right] $ 
\indent \hspace{4cm} $ \wedge \quad \fphi' \ast \text{post}(C,m)\left[z/this, \overline{x_i/\text{old}(\text{params}(C,m)_i)}, y/result \right] \imp \fphi \Big{\}}$

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = \maximp{\fphi'}{\fphi' \imp \fphi \quad \wedge \quad \fphi' \imp \phi_a} $

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\vspace{0.5cm}

\noindent \textbf{Note:} 

\textbf{Dynamic method calls.} Dynamic method calls are left undefined, because we are not verifying programs with dynamic dispatch at this time (all method calls should be static method calls). They are included in the grammar for future implementation.

\textbf{If \& Release \& hold.} Definitions coming soon.

\textbf{Predicates in the logic.} Although the grammar allows for abstract predicate families, we do not support them yet. Therefore, we assume formulas look like:

$$ \phi ::= \true \mid e \odot e \mid acc(e.f) \mid \phi \ast \phi $$

\section{Algorithmic WLP calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

\textbf{Note:} 

It may be helpful to check that the $\wlp{s}{\fphi}$ is well-formed and/or self-framed for some of the more complicated rules, which may be buggy in implementation.

\vspace{0.5cm}

\textbf{Note:}

We do not always calculate the correct WLP due to a limitation in the expressiveness of our specification language. Concrete formulas which do not contain enough information to determine whether two or more objects alias, wrongly assume that those two or more objects do not alias. This is because our current specification language is missing a logical OR or a conditional construct, which would allow us to write self-framed concrete formulas that capture the unknown aliasing between two or more objects. A conditional construct will be added and the definitions below adjusted in the near future.
% the weakest liberal precondition for assert, because concrete formulas cannot support the true weakest liberal precondition. Concrete formulas need to support logical OR. This issue occurs when aliasing constructs are missing from certain concrete formulas; in these cases, there is no way to tell whether accessibility predicates should be conjoined or one of them removed due to aliasing.

\vspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

$\wlp{T \ x := e}{\fphi} = 
	\begin{cases}
	 \fphi[e/x] & if \ \fphi[e/x] \imp acc(e) \\
	 acc(e) \ast \fphi[e/x] & otherwise
	\end{cases} $

Check that $\wlp{T \ x := e}{\fphi} \ast x = e \imp \fphi$ and that $\wlp{T \ x := e}{\fphi}$ is satisfiable.

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} =  
	\begin{cases}
	 \fphi[y/x.f] & if \ \fphi[y/x.f] \imp acc(x.f) \\
	 acc(x.f) \ast \fphi[y/x.f] & otherwise
	\end{cases}$

Check that $\wlp{x.f := y}{\fphi} \ast x.f = y \imp \fphi$ and that $\wlp{x.f := y}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = acc(x.f) \ast x.f = p \ast x.f = q \ast a = b $

$\fphi = acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = 
	\begin{cases}
	 \fphi \div x & if \ (\fphi \div x) \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \imp \fphi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$, $\fphi \div x$ means to transitively expand (in-)equalities ($\odot$) and then remove conjunctive terms containing $x$, and $\overline{x \neq e_i}$ are conjunctive terms in $\fphi$. 

Check $\wlp{x := new\ C}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = x \neq null \ast acc(x.f)$

$\fphi = x \neq null \ast acc(x.f) \ast x.f = 1 \ast x.f = y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast x = z$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast y = z$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x \neq y \ast y = z$

$\fphi = x \neq null \ast acc(x.f) \ast acc(x.f.f) \ast x.f.f \neq y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(y.f) \ast x = y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast y > x.f \ast x.f > z \ast r \geq x.f \ast x.f \geq s$ --- should fail, bad postcondition


\textbf{Note:}

$x := new \ C$ creates a fresh object and assigns it to $x$ without setting default values to the object's fields; therefore, postconditions cannot say anything about the value of $x$ other than it does not equal other values (no aliasing with $x$) and they cannot say anything about the values of the fields of $x$.

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = $ IN PROGRESS
%\fphi \ \overline{\div \ x_i} \div y \div acc * \text{pre}(C,m)\left[z/this, \overline{x_i/\text{params}(C,m)_i}\right]$

%where $\fphi \div x$ is as defined for the allocation rule, $\fphi \div F$ --- VERY MUCH IN PROGRESS; NOT CORRECT OR FINISHED

%\textbf{Important cases to consider:}
%What if $y = x_i$ for some argument $x_i$, $z$ could also be an argument, and $y = z$
%$\fphi = $

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = \fphi_{acc} \ \ast \mid \phi_a \mid \ast \mid \fphi \mid$

where $\mid \phi \mid$ means the formula $\phi$ without accessibility predicates and $\fphi_{acc}$ is the self-framed formula which contains the accessibility predicates that frame $\mid \phi_a \mid \ast \mid \fphi \mid$ and, in general, the accessibility predicates in $\phi_a$ and $\fphi$ that are not duplicated (even with respect to aliasing).

Also, check $\wlp{assert\ \phi_a}{\fphi} \imp \phi_a$, $\wlp{assert\ \phi_a}{\fphi} \imp \fphi$, and $\wlp{assert\ \phi_a}{\fphi}$ is satisfiable.

\textbf{Advice on how to compute $\fphi_{acc}$:}
\begin{enumerate}
% \item Transitively expand equalities in $\mid \phi_a \mid \ast \mid \fphi \mid$
\item Start with a list of the accessibility predicates in $\phi_a$ and $\fphi$
\item Add accessibility predicates to this list for self-framing $\phi_a$, as some may be missing since $\phi_a$ is not self-framed
	\begin{enumerate}
	\item Duplicates (including those due to aliasing) are fine, because they will be removed later
	\item But, not including obvious duplicates will improve performance
	\end{enumerate}
\item Add aliasing information from the actual conjoined accessibility predicates in $\phi_a$ and $\fphi$ to the non-accessibility parts of $\phi_a$ and $\fphi$ respectively. In other words, the accessibility predicates in $\phi_a$ ($\fphi$) separated by the separating conjunction indicate that if the fields ultimately being accessed within two or more of them are the same, then the objects being dereferenced in those field accesses do not alias, so add this information to the non-accessibility part of $\phi_a$ ($\fphi$) to not lose information
	\begin{enumerate}
	\item $acc(x.f) \ast acc(y.f) \ast x.f = 2$ implies $acc(x.f) \ast acc(y.f) \ast x.f = 2 \ast x \neq y$
	\item $acc(x.f) \ast acc(x.f.g) \ast acc(y.g) \ast acc(y.g.f) \ast x.f = 2$ implies \\ $acc(x.f) \ast acc(x.f.g) \ast acc(y.g) \ast acc(y.g.f) * x.f = 2 \ast x \neq y.g \ast y \neq x.f$
	\end{enumerate}
\item Determine the list of aliases and the list of non-aliases to each variable or field access dereferenced to a final field value in the current list of accessibility predicates using $\mid \phi_a \mid \ast \mid \fphi \mid$
	\begin{enumerate}
	\item Keep in mind that if $x.f \neq y.f$ then $x \neq y$ and that $x.f \neq y.f$ can be determined in many different ways, including through $x.f = 3 * y.f = 4$, so the SMT solver should be helpful and necessary for this
	\end{enumerate}
% Scan the conjunctive terms in $\mid \phi_a \mid \ast \mid \fphi \mid$ for field accesses
\item Remove duplicate accessibility predicates, including accessibility predicates which are duplicate due to aliasing (the list of aliases and list of non-aliases for each variable and field access dereferenced to a final field value in an acc predicate should help)
	\begin{enumerate}
	\item If it is unknown whether two objects alias due to missing information in $\phi_a$ and $\fphi$, then assume (for now) that they do not alias
	\end{enumerate}
% For each field access, check if an accessibility predicate exists for it in $\fphi_{acc}$ (including if an aliased accessibility predicate exists for it; the list of aliases for each variable should help)
	% \begin{itemize}
	% \item If so, continue scanning for field accesses
	% \item If not, add the accessibility predicate for the field access to $\fphi_{acc}$ using the separating conjunction
	% \end{itemize}
\item $\fphi_{acc}$ is the list of non-duplicated accessibility predicates conjoined with the separating conjunction
\end{enumerate}

\textbf{Important cases to consider:}

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x \neq null \ast x.f = 1 \ast x.f = y.f \ast y.f \neq p \ast y.f.f > 1$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x = y \ast x = z \ast x.f = 8 \ast y.f > 4$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x = y \ast y = z \ast z.f + 1 \leq 10 \ast \true$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x.f.f \neq y \ast x \neq p \ast p = q \ast x.f > y \ast y > z$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = y > x.f \ast x.f > z \ast r \geq x.f \ast x.f \geq s$

$\phi_a = acc(x.f) \ast y = 2$ and $\fphi = acc(z.f) \ast z.f = 4$

$\phi_a = acc(x.f) \ast x.f = 4$ and $\fphi = acc(z.f) \ast z.f = 4$

\textbf{Assumptions:}

We assume that objects are only referred to in formulas through variables or as field accesses, variables or field accesses which refer to objects are not used in binary operations ($\oplus$), and variables or field accesses which refer to objects are not used in comparison operators other than $\neq$ and $=$.

%	\begin{cases}
%	 \fphi \ast \phi_a & if \ fp_s(\fphi') \cap fp_s(\phi_a') = \emptyset \\
%	 \overline{acc((x.f)_i)} \ast \fphi - F \ast \phi_a - F & otherwise
%	\end{cases}$
%	
%where $\lcar x,f \rcar_i \in F = fp_s(\fphi') \cap fp_s(\phi_a')$ and $\phi - F$ means to remove the accessibility predicates which apply to elements of $F$.
%
%Also, $\fphi'$ and $\phi_a'$ are the transitively expanded versions of the corresponding formula with additional accessibility predicates added as necessary due to aliasing (see important cases below).
%
%\textbf{Important cases to consider:}
%
%$\fphi = acc(x.f) \ast x = p \ast p = q \ast a = b $
%
%--- becomes $\fphi' = acc(x.f) \ast x = p \ast p = q \ast x = q \ast a = b $
%
%--- and finally $\fphi' = acc(x.f) \ast acc(p.f) \ast acc(q.f) \ast x = p \ast p = q \ast x = q \ast a = b $
%
%$\fphi = acc(x.f) \ast x = y $ --- results in $\fphi' = acc(x.f) \ast acc(y.f) \ast x = y $

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\section{Algorithmic WLP calculus definitions over gradual formulas}
\hspace{0.5cm}

$\twlp{s}{\fphi} = \wlp{s}{\fphi} $ where $s$ is not a call statement

\vspace{0.5cm}

$\twlp{skip}{? \ast \phi} = \ ? \ast \phi$

\vspace{0.5cm}

$\twlp{s_1;s_2}{? \ast \phi} = \twlp{s_1}{\twlp{s_2}{? \ast \phi}} $

\vspace{0.5cm}

$\twlp{T \ x := e}{? \ast \phi} = \ ? \ast \phi[e/x] \ast e = e$

\textbf{Important cases to consider:}

$? \ast \phi = \ ? \ast p = q \ast y.f = 2$ --- no mention of $e$ or $x$ for substitution; need extra $\ast \ e = e$ because of this case

\textbf{OR}

$\twlp{T \ x := e}{? \ast \phi} =
	 \begin{cases}
	 ? \ast \phi[e/x] & if \ \phi[e/x] \imp acc(e) \\
	 ? \ast acc(e) \ast \phi[e/x] & otherwise
	\end{cases}$
	
Check that $\twlp{T \ x := e}{? \ast \phi} \ast x = e \timp ? \ast \phi$ and that $\twlp{T \ x := e}{? \ast \phi}$ is satisfiable.

\vspace{0.5cm}

%$\twlp{\eif{x \odot y}{s_1}{s_2}}{? \ast \phi} = $
%
%\vspace{0.5cm}

$\twlp{x.f := y}{? \ast \phi} =
	\begin{cases}
	 ? \ast \phi[y/x.f] & if \ \phi[y/x.f] \imp acc(x.f) \\
	 ? \ast acc(x.f) \ast \phi[y/x.f] & otherwise
	\end{cases}$

Check that $\twlp{x.f := y}{? \ast \phi} \ast x.f = y \timp \ ? \ast \phi$ and that $\twlp{x.f := y}{? \ast \phi}$ is satisfiable.

\textbf{Important cases to consider:}

$? \ast \phi = \ ? \ast acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\twlp{x := new\ C}{? \ast \phi} = 
	\begin{cases}
	 ? \ast \phi \div x & if \ (\phi \div x) \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \imp \phi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$, $\phi \div x$ means to transitively expand (in-)equalities ($\odot$) and then remove conjunctive terms containing $x$, and $\overline{x \neq e_i}$ are conjunctive terms in $\phi$. 

Check that $\twlp{x := new\ C}{? \ast \phi} \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \timp ? \ast \phi$ and that $\twlp{x := new\ C}{? \ast \phi}$ is satisfiable.

\textbf{Important cases to consider:}

Similar to the ones for the non-gradual version; replacing $\fphi$ with $\phi$.

%\vspace{0.5cm}
%
%$\twlp{y := z.m(\overline{x})}{} = undefined$
%
%\vspace{0.5cm}
%
%$\twlp{y := z.m_C(\overline{x})}{} = $

\vspace{0.5cm}

$\twlp{assert\ \phi_a}{? \ast \phi} = \ ? \ast \wlp{assert\ \phi_a}{\phi}$

Check that $\twlp{assert\ \phi_a}{? \ast \phi} \timp ? \ast \phi$, $\twlp{assert\ \phi_a}{? \ast \phi} \timp \phi_a$, and that 

\noindent $\twlp{assert\ \phi_a}{? \ast \phi}$ is satisfiable.

\textbf{Note:}

Since $\phi$ is not self-framed, then the resulting $\wlp{assert\ \phi_a}{\phi}$ will not necessarily be self-framed. This is okay due to ? accounting for the lack of self-framing and since $\wlp{assert\ \phi_a}{\phi}$ does not lose any information from $\phi_a$ or $\phi$ (in fact, it gains information with respect to $\phi_a$). So, allow this call to $\wlp{assert\ \phi_a}{\fphi}$ even though $\phi$ is not self-framed.

\textbf{Important cases to consider:}

Similar to the ones for the non-gradual version; replacing $\fphi$ with $\phi$.

\vspace{0.5cm}
%
%$\twlp{release \ \phi_a}{? \ast \phi} = $
%
%\vspace{0.5cm}
%
%$\twlp{hold \ \phi_a \ \{s\}}{? \ast \phi} = $
%
%\vspace{0.5cm}

\textbf{Note:} The static parts of gradual formulas do not need to be self-framed unless the gradual formula is completely precise (completely static). The imprecision can account for the framing.

\section{Gradual formula implication and satisfiability}

\textbf{TBD}

\end{document}
