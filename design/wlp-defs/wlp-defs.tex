\documentclass {article}

\usepackage[letterpaper]{geometry}
\usepackage{amsthm, amsmath, amssymb, stmaryrd}
 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\title {Verifier WLP Definitions}
\author {Jenna Wise, Johannes Bader, Jonathan Aldrich, \'{E}ric Tanter}
\date {\today}

%% Commands
\newcommand{\lcar}{\left<}
\newcommand{\rcar}{\right>}
\newcommand{\true}{\text{true}}
\newcommand{\eif}[3]{if \ ( #1 ) \ \{ #2 \} \ else \ \{#3\}}
\newcommand{\fphi}{\widehat{\phi}}
\newcommand{\tphi}{\widetilde{\phi}}
\newcommand{\acc}[1]{\text{acc}(#1)}
\newcommand{\imp}{\Rightarrow}
\newcommand{\timp}{\ \widetilde{\Rightarrow}\ }
\newcommand{\maximp}[2]{\underset{\Rightarrow}{\text{max}}\left\{#1 \mid #2\right\}}

\newcommand{\wlp}[2]{\text{WLP}(#1,#2)}
\newcommand{\twlp}[2]{\widetilde{\text{WLP}}(#1,#2)}
\newcommand{\swlp}[2]{\text{sWLP}(#1,#2)}
\newcommand{\swlpi}[2]{\text{sWLP}_i(#1,#2)}

% uppercase word defs
\newcommand{\satdef}{\textsc{SatFormula}}

\begin{document}

\maketitle

%\begin{figure*}[ht!]
%\begin{flalign*}
%%\spc{skip}{\phi} = \phi
%%\and
%%\spc{s_1;s_2}{\phi} = \spc{s_2}{\spc{s_1}{\phi}}
%%\and
%%\spc{T\ x}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x}.(\theta \wedge x = \text{defaultValue}(T)) \wedge \psi
%%\and
%%\spc{x := e}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x]\psi
%%\and
%%\spc{x := y.f}{\exists \overline{x}.\theta \wedge (\psi \ast y.f \mapsto e)} =  \exists \overline{x},x' . ([x'/x]\theta \wedge x = [x'/x]e) \wedge [x'/x](\psi \ast y.f \mapsto e)
%%\and
%%\spc{x.f := y}{\exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto e)} = \exists \overline{x}.\theta \wedge (\psi \ast x.f \mapsto y)\\
%%\and
%%\spc{x := new\ C}{\exists \overline{x}.\theta \wedge \psi} = \exists \overline{x},x' . [x'/x]\theta \wedge ([x'/x]\psi\ \overline{\ast\ x.f_i \mapsto \text{defaultValue}(T_i)})\ \text{where fields}(C)=\overline{T_i\ f_i} \\
%%\and
%%\spc{y := z.m(\overline{x})}{\exists \overline{y}.\theta \wedge \psi} = \begin{cases} \exists \overline{y}, y' . ([y'/y]\theta_{frame} \wedge \theta_Q) \wedge ([y'/y]\psi_{frame} \ast \psi_Q) & \text{if}\ \exists \overline{y}.(\theta \wedge \psi) \imp \exists \overline{y}.(\theta_{frame} \wedge \theta_P) \wedge (\psi_{frame} \ast \psi_P) \\ undefined & \text{otherwise} \end{cases}
%%\\ \text{where}\ \left[z/this,\overline{x_i/\text{params}(m)_i}\right]\text{pre(m)}=\theta_P \wedge \psi_P\ \text{and}\ \left[z/this, y/result, \overline{x_i/\text{old}(\text{params}(m)_i)}\right]\text{post(m)}=\theta_Q \wedge \psi_Q 
%%\and
%%\spc{assert\ \phi_a}{\phi} = \begin{cases} \phi & \text{if}\ \phi \imp \phi_a \\ undefined & \text{otherwise} \end{cases}
%%% WLP
%\wlp{skip}{\phi} &= \phi & \\
%\wlp{s_1;s_2}{\phi} &= \wlp{s_1}{\wlp{s_2}{\phi}}& \\
%\wlp{T\ x}{\phi} &= \phi &\\
%\wlp{x := e}{\phi} &= [e/x]\phi &\\
%\wlp{x := y.f}{\theta \wedge \psi} &= [e/x]\theta \wedge ([e/x]\psi \ast y.f \rightarrow e) &\\
%\wlp{x.f := y}{\theta \wedge \psi} &= \maximp{\theta' \wedge \psi'}{\theta' \wedge (\psi' \ast x.f \rightarrow y) \imp \theta \wedge \psi} &\\
%\wlp{x := new\ C}{\phi} &= &\\
%\wlp{y := z.m(\overline{x})}{\phi} &= &\\
%\wlp{assert\ \phi}{\phi} &=  &\\
%\end{flalign*}
%%\caption{Weakest Liberal Precondition Calculus}
%%\label{wp-rules}
%\end{figure*}

\section{Weakest liberal precondition calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

%$\wlp{T\ x}{\fphi} = \fphi\left[\text{defaultValue}(T)/x\right] $ -- NEEDS TO CHANGE

%\vspace{0.5cm}

$\wlp{T \ x := e}{\fphi} =\maximp{\fphi'}{\fphi' \imp \fphi[e/x] \quad \wedge \quad \fphi' \imp \acc{e}} $

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $
%\underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid \fphi' \imp \text{acc}(x) \quad \wedge \quad \fphi' \imp \text{acc}(y) \quad \wedge \quad$ 

%\indent  \hspace{4cm} $\fphi' \imp \left(\left(x \odot y \imp \wlp{s_1}{\fphi}\right) \quad \wedge \quad \left(\neg(x \odot y) \imp \wlp{s_2}{\fphi}\right)\right) \Big{\}}$

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} = \acc{x.f} \ \ast \ \maximp{\fphi'}{\fphi' \ast \acc{x.f} \ast (x.f = y) \imp \fphi \ \wedge \ \fphi' * \acc{x.f} \in \satdef} $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = \maximp{\fphi'}{ \fphi' \ast (x \neq null) \ast \overline{\acc{x.f_i}} \imp \fphi}$

%\overline{\acc{x.f_i} \ast (x.f_i = \text{defaultValue}(T_i))} 

\indent  \hspace{4cm} where fields$(C) = \overline{T_i \ f_i}$

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = \underset{\Rightarrow}{\text{max}} \Big{\{} \fphi' \mid y \not \in \text{FV}(\fphi') \quad \wedge \quad \fphi' \imp (z \neq null) \ \ast \ \text{pre}(C,m)\left[z/this, \overline{x_i/\text{params}(C,m)_i}\right] $ 
\indent \hspace{4cm} $ \wedge \quad \fphi' \ast \text{post}(C,m)\left[z/this, \overline{x_i/\text{old}(\text{params}(C,m)_i)}, y/result \right] \imp \fphi \Big{\}}$

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = \maximp{\fphi'}{\fphi' \imp \fphi \quad \wedge \quad \fphi' \imp \phi_a} $

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\vspace{0.5cm}

\noindent \textbf{Note:} 

\textbf{Dynamic method calls.} Dynamic method calls are left undefined, because we are not verifying programs with dynamic dispatch at this time (all method calls should be static method calls). They are included in the grammar for future implementation.

\textbf{If \& Release \& hold.} Definitions coming soon.

\textbf{Predicates in the logic.} Although the grammar allows for abstract predicate families, we do not support them yet. Therefore, we assume formulas look like:

$$ \phi ::= \true \mid e \odot e \mid acc(e.f) \mid \phi \ast \phi $$

\section{Algorithmic WLP calculus definitions over self-framed non-gradual formulas}
\hspace{0.5cm}

\textbf{Note:} 

It may be helpful to check that the $\wlp{s}{\fphi}$ is well-formed and/or self-framed for some of the more complicated rules, which may be buggy in implementation.

\vspace{0.5cm}

$\wlp{skip}{\fphi} = \fphi  $

\vspace{0.5cm}

$\wlp{s_1;s_2}{\fphi} = \wlp{s_1}{\wlp{s_2}{\fphi}} $

\vspace{0.5cm}

$\wlp{T \ x := e}{\fphi} = 
	\begin{cases}
	 \fphi[e/x] & if \ \fphi[e/x] \imp acc(e) \\
	 acc(e) \ast \fphi[e/x] & otherwise
	\end{cases} $

Check that $\wlp{T \ x := e}{\fphi} \ast x = e \imp \fphi$ and that $\wlp{T \ x := e}{\fphi}$ is satisfiable.

\vspace{0.5cm}

$\wlp{\eif{x \odot y}{s_1}{s_2}}{\fphi} = $

\vspace{0.5cm}

$\wlp{x.f := y}{\fphi} =  
	\begin{cases}
	 \fphi[y/x.f] & if \ \fphi[y/x.f] \imp acc(x.f) \\
	 acc(x.f) \ast \fphi[y/x.f] & otherwise
	\end{cases}$

Check that $\wlp{x.f := y}{\fphi} \ast x.f = y \imp \fphi$ and that $\wlp{x.f := y}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = acc(x.f) \ast x.f = p \ast x.f = q \ast a = b $

$\fphi = acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\wlp{x := new\ C}{\fphi} = 
	\begin{cases}
	 \fphi \div x & if \ (\fphi \div x) \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \imp \fphi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$, $\fphi \div x$ means to transitively expand (in-)equalities ($\odot$) and then remove conjunctive terms containing $x$, and $\overline{x \neq e_i}$ are conjunctive terms in $\fphi$. 

Check $\wlp{x := new\ C}{\fphi}$ is satisfiable.

\textbf{Important cases to consider:}

$\fphi = x \neq null \ast acc(x.f)$

$\fphi = x \neq null \ast acc(x.f) \ast x.f = 1 \ast x.f = y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast x = z$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x = y \ast y = z$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast x \neq y \ast y = z$

$\fphi = x \neq null \ast acc(x.f) \ast acc(x.f.f) \ast x.f.f \neq y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(y.f) \ast x = y$ --- should fail, bad postcondition

$\fphi = x \neq null \ast acc(x.f) \ast y > x.f \ast x.f > z \ast r \geq x.f \ast x.f \geq s$ --- should fail, bad postcondition


\textbf{Note:}

$x := new \ C$ creates a fresh object and assigns it to $x$ without setting default values to the object's fields; therefore, postconditions cannot say anything about the value of $x$ other than it does not equal other values (no aliasing with $x$) and they cannot say anything about the values of the fields of $x$.

\vspace{0.5cm}

$\wlp{y := z.m(\overline{x})}{\fphi} = undefined$

\vspace{0.5cm}

$\wlp{y := z.m_C(\overline{x})}{\fphi} = \fphi \ \overline{\div \ x_i} \div y \div acc * \text{pre}(C,m)\left[z/this, \overline{x_i/\text{params}(C,m)_i}\right]$

where $\fphi \div x$ is as defined for the allocation rule, $\fphi \div F$ --- VERY MUCH IN PROGRESS; NOT CORRECT OR FINISHED

\textbf{Important cases to consider:}
What if $y = x_i$ for some argument $x_i$, $z$ could also be an argument, and $y = z$
$\fphi = $

\vspace{0.5cm}

$\wlp{assert\ \phi_a}{\fphi} = \fphi_{acc} \ \ast \mid \phi_a \mid \ast \mid \fphi \mid$

where $\mid \phi \mid$ means the formula $\phi$ without accessibility predicates and $\fphi_{acc}$ is the self-framed formula which contains the accessibility predicates that frame $\mid \phi_a \mid \ast \mid \fphi \mid$.

Also, check $\wlp{assert\ \phi_a}{\fphi} \imp \phi_a$, $\wlp{assert\ \phi_a}{\fphi} \imp \fphi$, and $\wlp{assert\ \phi_a}{\fphi}$ is satisfiable.

\textbf{Note:}

This is not the weakest liberal precondition for assert, because concrete formulas cannot support the true weakest liberal precondition. Concrete formulas need to support logical OR. This issue occurs when aliasing constructs are missing from certain concrete formulas; in these cases, there is no way to tell whether accessibility predicates should be conjoined or one of them removed due to aliasing.

\textbf{Advice on how to compute $\fphi_{acc}$:}
\begin{enumerate}
% \item Transitively expand equalities in $\mid \phi_a \mid \ast \mid \fphi \mid$
\item Determine the list of aliases to each variable or field access using $\mid \phi_a \mid \ast \mid \fphi \mid$
\item Start with the accessibility predicates in $\phi_a$ and $\fphi$
% Scan the conjunctive terms in $\mid \phi_a \mid \ast \mid \fphi \mid$ for field accesses
\item Remove duplicate accessibility predicates, including accessibility predicates which are duplicate due to aliasing (the list of aliases for each variable and field access should help)
% For each field access, check if an accessibility predicate exists for it in $\fphi_{acc}$ (including if an aliased accessibility predicate exists for it; the list of aliases for each variable should help)
	% \begin{itemize}
	% \item If so, continue scanning for field accesses
	% \item If not, add the accessibility predicate for the field access to $\fphi_{acc}$ using the separating conjunction
	% \end{itemize}
\item $\fphi_{acc}$ is the list of non-duplicated accessibility predicates conjoined with the separating conjunction
\end{enumerate}

\textbf{Important cases to consider:}

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x \neq null \ast x.f = 1 \ast x.f = y.f \ast y.f \neq p \ast y.f.f > 1$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x = y \ast x = z \ast x.f = 8 \ast y.f > 4$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x = y \ast y = z \ast z.f + 1 \leq 10 \ast \true$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = x.f.f \neq y \ast x \neq p \ast p = q \ast x.f > y \ast y > z$

$\mid \phi_a \mid \ast \mid \fphi \mid \ = y > x.f \ast x.f > z \ast r \geq x.f \ast x.f \geq s$

$\phi_a = acc(x.f) \ast y = 2$ and $\fphi = acc(z.f) \ast z.f = 4$

$\phi_a = acc(x.f) \ast x.f = 4$ and $\fphi = acc(z.f) \ast z.f = 4$

\textbf{Assumptions:}

We assume that objects are only referred to in formulas through variables or as field accesses, variables or field accesses which refer to objects are not used in binary operations ($\oplus$), and variables or field accesses which refer to objects are not used in comparison operators other than $\neq$ and $=$.

%	\begin{cases}
%	 \fphi \ast \phi_a & if \ fp_s(\fphi') \cap fp_s(\phi_a') = \emptyset \\
%	 \overline{acc((x.f)_i)} \ast \fphi - F \ast \phi_a - F & otherwise
%	\end{cases}$
%	
%where $\lcar x,f \rcar_i \in F = fp_s(\fphi') \cap fp_s(\phi_a')$ and $\phi - F$ means to remove the accessibility predicates which apply to elements of $F$.
%
%Also, $\fphi'$ and $\phi_a'$ are the transitively expanded versions of the corresponding formula with additional accessibility predicates added as necessary due to aliasing (see important cases below).
%
%\textbf{Important cases to consider:}
%
%$\fphi = acc(x.f) \ast x = p \ast p = q \ast a = b $
%
%--- becomes $\fphi' = acc(x.f) \ast x = p \ast p = q \ast x = q \ast a = b $
%
%--- and finally $\fphi' = acc(x.f) \ast acc(p.f) \ast acc(q.f) \ast x = p \ast p = q \ast x = q \ast a = b $
%
%$\fphi = acc(x.f) \ast x = y $ --- results in $\fphi' = acc(x.f) \ast acc(y.f) \ast x = y $

\vspace{0.5cm}

$\wlp{release \ \phi_a}{\fphi} = $

\vspace{0.5cm}

$\wlp{hold \ \phi_a \ \{s\}}{\fphi} = $

\section{Algorithmic WLP calculus definitions over gradual formulas}
\hspace{0.5cm}

$\twlp{s}{\fphi} = \wlp{s}{\fphi} $ where $s$ is not a call statement

\vspace{0.5cm}

$\twlp{skip}{? \ast \phi} = \ ? \ast \phi$

\vspace{0.5cm}

$\twlp{s_1;s_2}{? \ast \phi} = \twlp{s_1}{\twlp{s_2}{? \ast \phi}} $

\vspace{0.5cm}

$\twlp{T \ x := e}{? \ast \phi} = \ ? \ast \phi[e/x] \ast e = e$

\textbf{Important cases to consider:}

$? \ast \phi = \ ? \ast p = q \ast y.f = 2$ --- no mention of $e$ or $x$ for substitution; need extra $\ast \ e = e$ because of this case

\textbf{OR}

$\twlp{T \ x := e}{? \ast \phi} =
	 \begin{cases}
	 ? \ast \phi[e/x] & if \ \phi[e/x] \imp acc(e) \\
	 ? \ast acc(e) \ast \phi[e/x] & otherwise
	\end{cases}$
	
Check that $\twlp{T \ x := e}{? \ast \phi} \ast x = e \timp ? \ast \phi$ and that $\twlp{T \ x := e}{? \ast \phi}$ is satisfiable.

\vspace{0.5cm}

%$\twlp{\eif{x \odot y}{s_1}{s_2}}{? \ast \phi} = $
%
%\vspace{0.5cm}

$\twlp{x.f := y}{? \ast \phi} =
	\begin{cases}
	 ? \ast \phi[y/x.f] & if \ \phi[y/x.f] \imp acc(x.f) \\
	 ? \ast acc(x.f) \ast \phi[y/x.f] & otherwise
	\end{cases}$

Check that $\twlp{x.f := y}{? \ast \phi} \ast x.f = y \timp \ ? \ast \phi$ and that $\twlp{x.f := y}{? \ast \phi}$ is satisfiable.

\textbf{Important cases to consider:}

$? \ast \phi = \ ? \ast acc(x.f) \ast acc(x.f.f) \ast x = y $

\vspace{0.5cm}

$\twlp{x := new\ C}{? \ast \phi} = 
	\begin{cases}
	 ? \ast \phi \div x & if \ (\phi \div x) \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \imp \phi \\
	 undefined & otherwise
	\end{cases}$ 

where fields$(C) = \overline{T_i \ f_i}$, $\phi \div x$ means to transitively expand (in-)equalities ($\odot$) and then remove conjunctive terms containing $x$, and $\overline{x \neq e_i}$ are conjunctive terms in $\phi$. 

Check that $\twlp{x := new\ C}{? \ast \phi} \ast x \neq null \ast \overline{x \neq e_i} \ast \overline{acc(x.f_i)} \timp ? \ast \phi$ and that $\twlp{x := new\ C}{? \ast \phi}$ is satisfiable.

\textbf{Important cases to consider:}

Similar to the ones for the non-gradual version; replacing $\fphi$ with $\phi$.

%\vspace{0.5cm}
%
%$\twlp{y := z.m(\overline{x})}{} = undefined$
%
%\vspace{0.5cm}
%
%$\twlp{y := z.m_C(\overline{x})}{} = $

\vspace{0.5cm}

$\twlp{assert\ \phi_a}{? \ast \phi} = $

%\vspace{0.5cm}
%
%$\twlp{release \ \phi_a}{? \ast \phi} = $
%
%\vspace{0.5cm}
%
%$\twlp{hold \ \phi_a \ \{s\}}{? \ast \phi} = $
%
%\vspace{0.5cm}

\textbf{Note:} The static parts of gradual formulas do not need to be self-framed unless the gradual formula is completely precise (completely static). The imprecision can account for the framing.

\section{Gradual formula implication and satisfiability}

\textbf{TBD}

\end{document}
