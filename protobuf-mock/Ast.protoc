// protoc file autogenerated from OCaml type definitions
package Ast;

// ast.ml:2
message ident {
  required string _ = 1;
}

// ast.ml:4
message typ {
  enum _tag {
    Int_tag = 1;
    Top_tag = 2;
    Class_tag = 3;
  }
  
  required _tag tag = 1;
  oneof value {
    ident Class = 4;
  }
}

// ast.ml:9
message expop {
  enum _tag {
    Plus_tag = 1;
    Minus_tag = 2;
    Times_tag = 3;
    Div_tag = 4;
  }
  
  required _tag tag = 1;
}

// ast.ml:15
message cmpop {
  enum _tag {
    NEQ_tag = 1;
    EQ_tag = 2;
    LT_tag = 3;
    GT_tag = 4;
  }
  
  required _tag tag = 1;
}

// ast.ml:21
message exp {
  enum _tag {
    Var_tag = 1;
    Val_tag = 2;
    Binop_tag = 3;
    Field_tag = 4;
  }
  
  // ast.ml:25
  message _Binop {
    required exp _0 = 1;
    required expop _1 = 2;
    required exp _2 = 3;
  }
  
  // ast.ml:25
  message _Field {
    required exp _0 = 1;
    required ident _1 = 2;
  }
  
  required _tag tag = 1;
  oneof value {
    ident Var = 2;
    int64 Val = 3;
    _Binop Binop = 4;
    _Field Field = 5;
  }
}

// ast.ml:29
message formula {
  enum _tag {
    True__tag = 1;
    Cmp_tag = 2;
    Alpha_tag = 3;
    Access_tag = 4;
    Sep_tag = 5;
  }
  
  // ast.ml:37
  message _Cmp {
    required exp _0 = 1;
    required cmpop _1 = 2;
    required exp _2 = 3;
  }
  
  // ast.ml:37
  message _Alpha {
    required dummy _0 = 1;
    repeated exp _1 = 2;
  }
  
  // ast.ml:37
  message _Access {
    required exp _0 = 1;
    required ident _1 = 2;
  }
  
  // ast.ml:37
  message _Sep {
    required formula _0 = 1;
    required formula _1 = 2;
  }
  
  required _tag tag = 1;
  oneof value {
    _Cmp Cmp = 3;
    _Alpha Alpha = 4;
    _Access Access = 5;
    _Sep Sep = 6;
  }
}

// ast.ml:39
message phi {
  enum _tag {
    Concrete_tag = 1;
    Gradual_tag = 2;
  }
  
  required _tag tag = 1;
  oneof value {
    formula Concrete = 2;
    formula Gradual = 3;
  }
}

// ast.ml:44
message contract {
  required contract requires = 1;
  required contract ensures = 2;
}

// ast.ml:48
message stmt {
  enum _tag {
    Skip_tag = 1;
    Seq_tag = 2;
    Decl_tag = 3;
    Assign_tag = 4;
    If_tag = 5;
    FieldAssign_tag = 6;
    New_tag = 7;
    MethodCall_tag = 8;
    Assert_tag = 9;
    Release_tag = 10;
    Hold_tag = 11;
  }
  
  // ast.ml:61
  message _Seq {
    required stmt _0 = 1;
    required stmt _1 = 2;
  }
  
  // ast.ml:61
  message _Decl {
    required typ _0 = 1;
    required ident _1 = 2;
  }
  
  // ast.ml:61
  message _Assign {
    required ident _0 = 1;
    required exp _1 = 2;
  }
  
  // ast.ml:61
  message _If {
    required ident _0 = 1;
    required cmpop _1 = 2;
    required ident _2 = 3;
    required stmt _3 = 4;
    required stmt _4 = 5;
  }
  
  // ast.ml:61
  message _FieldAssign {
    required ident _0 = 1;
    required ident _1 = 2;
    required ident _2 = 3;
  }
  
  // ast.ml:61
  message _New {
    required ident _0 = 1;
    required ident _1 = 2;
  }
  
  // ast.ml:61
  message _MethodCall {
    required ident _0 = 1;
    required ident _1 = 2;
    repeated ident _2 = 3;
  }
  
  // ast.ml:61
  message _Hold {
    required formula _0 = 1;
    repeated stmt _1 = 2;
  }
  
  required _tag tag = 1;
  oneof value {
    _Seq Seq = 3;
    _Decl Decl = 4;
    _Assign Assign = 5;
    _If If = 6;
    _FieldAssign FieldAssign = 7;
    _New New = 8;
    _MethodCall MethodCall = 9;
    formula Assert = 10;
    formula Release = 11;
    _Hold Hold = 12;
  }
}

// ast.ml:63
message methd {
  // ast.ml:69
  message _inp {
    required ident _0 = 1;
    required typ _1 = 2;
  }
  
  required ident name = 1;
  required typ outty = 2;
  repeated _inp inp = 3;
  required contract dynamic = 4;
  required contract static = 5;
  required stmt body = 6;
}

// ast.ml:71
message cls {
  // ast.ml:74
  message _fields {
    required typ _0 = 1;
    required ident _1 = 2;
  }
  
  required ident name = 1;
  repeated _fields fields = 2;
  repeated methd methods = 3;
}

// ast.ml:76
message program {
  repeated cls _0 = 1;
  required stmt _1 = 2;
}
