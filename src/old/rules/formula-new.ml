(* Contains all the logic for access predicates, etc.
 *
 * TODO: Refactoring -- The organization of this stuff is just generally a mess
 *
 *   Simiilarly, the only reason we don't have the Idf.satisfiable function in
 *   this file is that we need it to rely on both Formula and SAT.
 *
 * Formulas are values of type 'a t, where the 'a can be `precise' or
 * `imprecise'. This done at the type level so we can ensure that we don't
 * call static WLP on a gradual formula (etc). This does lead to complications
 * elsewhere (such as needing to write gradualWLP in continuation passing
 * style), as well as generally more complex code.
*)

open Core
open Functools
open Ast_types
open Ast_pb

module A = Ast

module LM = List.Assoc

exception Unsat
exception Malformed

(* -------------------------------------------------------------------------------------------------------------------------*)
(* Id *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* P (Program) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* cls *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* predicate *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* T (type) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* method *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* contract *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* circle-plus (binary operation) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* circle-dot (binary comparison) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* s (statement) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* e (expression) *)

let rec substitute : expression -> value -> expression =
  fun x y -> y

(* -------------------------------------------------------------------------------------------------------------------------*)
(* x (variable) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* v (value) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* n (number) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* formula *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* tphi (imprecise formula) *)

(* -------------------------------------------------------------------------------------------------------------------------*)
(* phi (concrete formula) *)
